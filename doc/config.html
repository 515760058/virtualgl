<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  
  <title>VirtualGL Configuration Guide</title><style type="text/css">
body {
background-color: rgb(255, 255, 255);
font-family: Arial,Helvetica,sans-serif;
}
a {
text-decoration: none;
}
dt {
font-weight: bold;
margin-left: 25px;
margin-top: 20px;
}
.valid {
border-width: 0px;
}
pre {
border: 1px solid rgb(0, 0, 255);
padding: 4px;
font-family: courier,monospace;
font-size: 14px;
background-color: rgb(238, 238, 255);
margin-left: 25px;
margin-right: 25px;
}
tr {
background-color: rgb(238, 238, 255);
color: rgb(32, 32, 32);
text-align: left;
}
th {
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
text-align: left;
}
td {
vertical-align: top;
text-align: left;
}
.colorheader {
padding: 2px;
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
margin-left: 3px;
margin-right: 3px;
}
.newwin {
border-width: 0px;
}
.tip {
border: 1px solid rgb(0, 0, 0);
padding: 1px 5px;
font-weight: bold;
background-color: rgb(255, 255, 0);
margin-right: 10px;
}
.note {
border: 1px solid rgb(0, 0, 0);
padding: 2px;
font-weight: bold;
background-color: blue;
color: rgb(255, 255, 255);
}
.monospace {
font-family: monospace
}
hr {
margin-bottom: 7px;
}
h2 {
padding: 5px;
color: rgb(255, 255, 255);
background-color: rgb(25, 25, 112);
}
h3 {
padding: 2px;
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
margin-left: 3px;
margin-right: 3px;
}
.top {
text-align: right;
}
  </style></head>

<body>
<h1>VirtualGL 2.0 Configuration
Guide<br>
</h1>
<div style="text-align: left;">
<h2>Server Settings</h2>
</div>
<font face="Arial, Helvetica">
<p align="left">You can
control the operation of the VirtualGL server in four different
ways.&nbsp; Each method of configuration takes precedence over the
previous method:</p></font>
<ol>
  <li>Setting a configuration environment variable globally (e.g. in <span class="monospace">/etc/profile</span>)</li>
  <li>Setting a configuration environment variable on a per-user basis (e.g. in <span class="monospace">~/.bashrc</span>)</li>
  <li>Setting a configuration environment variable only for the current shell session (e.g. <span class="monospace">export VGL_XXX={whatever}</span>)</li>
  <li>Passing a configuration option as an argument to <span class="monospace">vglrun</span>.&nbsp; This effectively overrides any environment variables corresponding to that configuration option.<br>
  </li>
</ol>
<font face="Arial, Helvetica"></font><p align="left"><span class="note">Note:</span>&nbsp;
Most of these are
read only once during execution, when the application faker initializes.</p>
<br>
<table style="width: 100%;" cellpadding="5" cellspacing="3">
  <tbody>
    <tr>
      <td style="font-weight: bold;" class="colorheader">Environment<br>
Variable<br>
Name</td>
      <td style="font-weight: bold; vertical-align: top; background-color: rgb(0, 0, 0);"><span class="colorheader monospace">vglrun</span><br class="colorheader">
      <span class="colorheader">Command-Line</span><br class="colorheader">
      <span class="colorheader">Override</span></td>
<td style="font-weight: bold;" class="colorheader">Description</td>
      <td style="font-weight: bold;" class="colorheader">Default<br>
Value</td>
    </tr>
    <tr>
      <td class="monospace" style="width: 42px; vertical-align: baseline; font-weight: bold;">VGL_QUAL<br>
<br>
      </td>
      <td><span class="monospace" style="font-weight: bold;">-q &lt;1-100&gt;</span></td>
<td style="width: 100%; vertical-align: top;"><span style="font-weight: bold;">an
integer between 1 and 100 (inclusive)</span><br style="font-weight: bold;">
This allows you to manually specify the quality of the JPEG
compression.&nbsp; Lower is faster but also grainier.&nbsp; The default
setting should produce visually lossless performance.<br>
      </td>
      <td style="font-weight: bold;">95</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_SUBSAMP<br>
<br>
      </td>
      <td><span class="monospace" style="font-weight: bold;">-samp &lt;411|422|444&gt;</span></td>
<td style="width: 100%; vertical-align: top;"><span style="font-weight: bold;">411,
422, or 444</span><br style="font-weight: bold;">
This allows you to manually specify the level of chrominance
subsampling in the JPEG compressor.
      <p>By default, VirtualGL
uses no chrominance subsampling (AKA "4:4:4 subsampling") when it
compresses images for delivery to the client.&nbsp; Subsampling is
premised on the fact that the
human eye is more sensitive to changes in brightness than to changes in
color.&nbsp; Since the JPEG image format uses a colorspace in which
brightness (luminance) and color (chrominance) are separated into
different channels, one can sample the brightness for every pixel and
the color for every other pixel and produce visually a 16-million color
image using on average only 16 bits per pixel instead of 24.&nbsp;
This is called "4:2:2 subsampling", since for every 4 pixels of
luminance, there are only 2 pixels of each chrominance
component.&nbsp; Likewise, one can sample every fourth chrominance
component to produce a 16-million color image with only 12 bits per
pixel.&nbsp; The latter is called "4:1:1 subsampling."&nbsp;
Subsampling increases the performance and reduces the network usage,
since there is less data to move around, but it can produce some
visible artifacts.&nbsp; Subsampling artifacts are rarely observed
with volume data, since it usually only contains 256 colors to begin
with.&nbsp; But narrow, aliased lines and other sharp features on a
black background will tend to produce subsampling artifacts.<br>
      <br>
      <span style="font-weight: bold;">The Axis Indicator from a
Popular Visualization App<br>
      </span><br style="font-weight: bold;">
      <table style="border-collapse: collapse;" border="0" cellpadding="0" cellspacing="0">
        <tbody>
          <tr>
            <td>
            <p align="center">4:4:4<br>
Q95</p>
            </td>
            <td>
            <p align="center">4:2:2<br>
Q95</p>
            </td>
            <td>
            <p align="center">4:1:1<br>
Q95</p>
            </td>
          </tr>
          <tr>
            <td><img style="border: 0px solid ; width: 70px; height: 80px;" alt="" src="config/444.gif"></td>
            <td><img style="border: 0px solid ; width: 70px; height: 80px;" alt="" src="config/422.gif"></td>
            <td><img style="border: 0px solid ; width: 70px; height: 80px;" alt="" src="config/411.gif"></td>
          </tr>
        </tbody>
      </table></p>
      <p><span class="note">Note:</span>&nbsp;&nbsp; If you select
4:1:1 subsampling, VirtualGL will in fact try to use 4:2:0
instead.&nbsp; 4:2:0 samples every other pixel both horizontally and
vertically rather than sampling every fourth pixel horizontally.&nbsp;
But not all JPEG codecs support 4:2:0, so 4:1:1 is used when 4:2:0 is
not available.<br>
      </p>
      <p><br>
      </p>

      </td>
      <td style="font-weight: bold;">444</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_SPOIL<br>
=&lt;0, 1&gt;<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">+spoil</span><br style="font-weight: bold;">
or<br style="font-weight: bold;">
      <span style="font-weight: bold;" class="monospace">-spoil</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">Enable/disable frame
spoiling</span><br>
By default, VirtualGL will drop frames so as not to slow down the
rendering rate of the server's graphics engine.&nbsp; This should
produce the
best results with interactive applications, but it may be desirable to
turn off frame spoiling when running benchmarks or other
non-interactive applications.&nbsp; Turning off frame spoiling will
force one frame to be read back and
sent on each buffer swap, thus allowing benchmarks to accurately
measure the frame rate of the entire VirtualGL pipeline.&nbsp;
Disabling frame spoiling will also prevent non-interactive applications
from wasting graphics resources by rendering frames that will never be
seen.&nbsp; With frame spoiling turned off, the rendering
pipeline behaves as if it's fill-rate limited to about 30 or 40
Megapixels/second, the maximum throughput of the VirtualGL system on
current CPU's.</td>
      <td style="font-weight: bold;">1
(spoiling enabled)</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_GLLIB<br>
      </td>
      <td>none</td>
<td valign="top" width="100%"><span style="font-weight: bold;">the
location of an
alternate OpenGL .so</span><br style="font-weight: bold;">
Normally, VirtualGL loads the first OpenGL .so that it finds in the
dynamic linker path (usually the one found in <span class="monospace">/usr/lib</span>, <span class="monospace">/usr/lib64</span>, <span class="monospace">/usr/openwin/lib</span>, or <span class="monospace">/usr/openwin/lib/sparcv9</span>.)&nbsp;
You can
use this setting to explicitly specify another OpenGL .so to use.<br>
      <br>
Normally, you shouldn't need to muck with this unless something doesn't
work.</td>
      <td style="font-weight: bold;"></td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_X11LIB<br>
      </td>
      <td>none</td>
<td valign="top" width="100%"><span style="font-weight: bold;">the
location of an
alternate X11 .so<br>
      </span>Normally, VirtualGL
loads the first X11 .so that it finds in the dynamic linker path
(usually the one found in <span class="monospace">/usr/X11R6/lib</span>, <span class="monospace">/usr/X11R6/lib64</span>, <span class="monospace">/usr/openwin/lib</span>, or <span class="monospace">/usr/openwin/lib/sparcv9</span>.)&nbsp;
You can use this setting to explicitly specify another X11 .so to
use.<br>
      <br>
Normally, you shouldn't need to muck with this unless something doesn't
work.</td>
      <td style="font-weight: bold;"></td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_DISPLAY<br>
<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">-d &lt;display or GLP device&gt;</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">the
display or GLP device on which 3D
rendering is done</span><br>
If you have a multi-pipe server configuration and want the OpenGL
rendering to be done on a display other than :0, set this to :1 or
whatever.&nbsp; This could be used, for instance, to support many
app instances on a beefy server with multiple 3D graphics cards.<br>
      <br>
      <span style="font-weight: bold;">GLP mode:</span><br>
Setting this option to<span class="monospace"></span> <span class="monospace">GLP</span> will enable GLP mode and select the first available GLP device for rendering.&nbsp; You can also set the option to<span class="monospace"></span> the pathname of a specific GLP device (e.g. <span class="monospace">/dev/fbs/jfb0</span>.)</td>
      <td style="font-weight: bold;">:0</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_CLIENT<br>
<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">-client &lt;client display&gt;</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">the
display on which the
client software is running</span><br style="font-weight: bold;">
VirtualGL uses a dedicated TCP/IP connection to transmit compressed
images of
the OpenGL rendering area from the server to the client.&nbsp;
Thus, the server needs to know on which machine the client software is
running.&nbsp; It normally can surmise this from the <span class="monospace">DISPLAY</span>
environment variable.&nbsp; But in cases where X11 is tunneled
through a Low-Bandwidth X (LBX) or SSh proxy, the <span class="monospace">DISPLAY</span> environment
variable on the server may not point to the client machine.&nbsp;
In these cases, set <span class="monospace">VGL_CLIENT</span> to the
display where the application's GUI
will end up.</td>
      <td style="font-weight: bold;">read
from the <span class="monospace">DISPLAY</span>
environment</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_PORT<br>
<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">-p &lt;port&gt;</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">the
TCP port to use when
connecting to the client</span></td>
      <td style="font-weight: bold;">4242
for non-SSL,&nbsp; 4243 for SSL</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_USESSL<br>
=&lt;0, 1&gt;<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">+s</span><br class="monospace">
or<br>
      <span style="font-weight: bold;" class="monospace">-s</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">tunnel
the VirtualGL
compressed image stream inside a secure socket layer</span><br style="font-weight: bold;">
      <br>
      <span class="note">Note:</span>&nbsp;
You must be running the secure client for this to work.&nbsp; See
the VirtualGL User's Guide for more details. </td>
      <td style="font-weight: bold;">0
(SSL disabled)</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_COMPRESS<br>
=&lt;0, 1&gt;<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">-c &lt;0, 1&gt;</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">Enable/disable image
compression</span><br style="font-weight: bold;">
When image compression is disabled, VirtualGL will bypass its
compressed image delivery system and instead use X11 image drawing
commands
to composite the 3D area of the window back into the window.&nbsp; This
is primarily useful in conjunction with VNC, Citrix for Unix, or
another remote display mechanism that performs X11 rendering on the
server and contains its own image compression and delivery
mechanisms.&nbsp; Performing uncompressed X11 blits to an X server
running elsewhere on the network is not typically going to be a very
high-performance option.</td>
      <td style="font-weight: bold;">1
(image compression enabled)</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_PROFILE<br>
=&lt;0, 1&gt;<br>
      </td>
      <td><span style="font-weight: bold;" class="monospace">+profile</span><br>
or<br>
      <span style="font-weight: bold;" class="monospace">-profile</span></td>
<td valign="top" width="100%"><span style="font-weight: bold;">Enable/disable profiling
output</span><br style="font-weight: bold;">
If enabled, this will cause the server to continuously measure and
display the pixel throughput of the overall pipeline and of the
readback and compression stages.</td>
      <td style="font-weight: bold;">0
(profiling disabled)</td>
    </tr><tr>
      <td><span style="font-weight: bold;" class="monospace">VGL_SYNC<br>
=&lt;0, 1&gt;</span></td>
      <td>none</td>
      <td><span style="font-weight: bold;">Enable/disable strict 2D/3D synchronization (necessary to pass GLX conformance tests)<br>
      </span>Normally, VirtualGL's operation is asynchronous from the
point of view of the application.&nbsp; The application swaps the
buffers or calls glFInish() or glFlush() or glXWaitGL(), and VirtualGL
reads back the framebuffer and sends the pixels to the client's display
... eventually.&nbsp; This will work fine for a vast majority of
applications, but it is not strictly conformant.&nbsp; Rarely, an
application may call glXWaitGL() or glFinish() and expect to be able to
immediately access the resulting pixels using X11 functions such as
XGetImage().&nbsp; Enabling <span class="monospace">VGL_SYNC</span> is
a somewhat extreme measure that may be needed to get such applications
to work properly.&nbsp; It was developed as a way to pass the GLX
conformance suite (conformx, specifically.)&nbsp; When <span class="monospace">VGL_SYNC</span> is enabled, every call to glFinish() or glXWaitGL() will cause the contents of the server's framebuffer to be read back and <span style="font-style: italic;">synchronously</span> drawn into the client's window <span style="font-style: italic;">without frame spoiling</span>.&nbsp;
The call to glFinish() or glXWaitGL() does not return until the pixels
have been delivered into the client's window, thus enabling this mode
can have potentially dire effects on performance.<span style="font-weight: bold;"></span></td>
      <td><span style="font-weight: bold;">0 (synchronization disabled)</span></td>
    </tr>
    <tr>
      <td><span style="font-weight: bold;" class="monospace">VGL_MT<br>
=&lt;0, 1&gt;</span></td>
      <td><span style="font-weight: bold;" class="monospace">+mt</span><br>
or<br>
      <span style="font-weight: bold;" class="monospace">-mt</span></td>
      <td><span style="font-weight: bold;">Enable/disable multi-threaded compression</span><br>
If enabled, the server will divide the task of compressing the frame
among all of the available processors, which might speed up the overall
throughput if the server's JPEG codec is slow.&nbsp; Enabling
multi-threaded compression has no effect on a uniprocessor system.</td>
      <td><span style="font-weight: bold;">0 (multi-threaded compression disabled)</span></td>
    </tr>

  </tbody>
</table>
<br>
<h2 style="text-align: left;">Client
Settings</h2>
<br>
<table style="width: 100%;" cellpadding="5" cellspacing="3">
  <tbody>
    <tr>
      <td style="font-weight: bold;" class="colorheader">Environment<br>
Variable<br>
Name</td>
      <td style="font-weight: bold;" class="colorheader">Description</td>
      <td style="font-weight: bold;" class="colorheader">Default<br>
Value</td>
    </tr>
    <tr>
      <td style="font-weight: bold;" class="monospace" valign="baseline" width="42">VGL_PROFILE<br>
      </td>
      <td style="width: 100%; vertical-align: top;"><span style="font-weight: bold;">1
to turn on profiling
output</span><br style="font-weight: bold;">
If enabled, this will cause the client to continuously measure and
display the pixel throughput of the overall pipeline and of the
decompression and blitting stages.</td>
      <td style="font-weight: bold;">0
(profiling disabled)</td>
    </tr>
  </tbody>
</table>
<br>
<h4>Other Client Settings</h4>
<ul>
  <li>Invoking the client with<br>
    <pre>vglclient -p&lt;port number&gt;<br></pre>
will cause the client to listen on a TCP port other than the default
(4242 for non-SSL or 4243 for SSL.)&nbsp; Use this in conjunction
with the <span class="monospace">VGL_PORT</span>
environment variable on the server.</li>
</ul>
<ul>
  <li>Invoking the client with<br>
    <pre>vglclient -s</pre>
will cause it to accept only SSL connections from the server.&nbsp;
Use this in conjunction with the <span class="monospace">VGL_USESSL</span>
environment variable on the server.</li>
</ul>
<br>
</body></html>
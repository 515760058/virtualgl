* Advanced Configuration
{anchor: Advanced_Configuration}

** Server Settings

You can control the operation of the VirtualGL faker in four different ways.
Each method of configuration takes precedence over the previous method:

	#. Setting a configuration environment variable globally (for instance, in
		''/etc/profile'')

	#. Setting a configuration environment variable on a per-user basis (for instance, in
		''~/.bashrc'')

	#. Setting a configuration environment variable only for the current shell
		session (for instance, ''export VGL_XXX={whatever}'')

	#. Passing a configuration option as an argument to ''vglrun''.  This
		effectively overrides any previous environment variable setting
		corresponding to that configuration option.

|| Environment Variable \
	|| ''vglrun'' Command-Line Override || Description || Default Value ||
| ''VGL_CLIENT=''__''{c}''__ | ''-cl ''__''{c}''__ \
	| When using the VGL Image Transport, __''{c}''__ specifies the hostname or \
		IP address of the machine on which ''vglclient'' is running.  When using \
		the Sun Ray Image Transport, __''{c}''__ specifies the hostname or IP \
		address of the Sun Ray server.  Normally, ''VGL_CLIENT'' is set \
		automatically by the ''vglconnect'' or ''vglrun'' script, so don't \
		override it unless you know what you're doing. \
	|	Automatically set by ''vglconnect'' or ''vglrun'' \
	|
| ''VGL_COMPRESS=proxy''{nl} \
	''VGL_COMPRESS=jpeg''{nl} \
	''VGL_COMPRESS=rgb''{nl} \
	''VGL_COMPRESS=sr''{nl} \
	''VGL_COMPRESS=srrgb'' \
	| ''-c proxy''{nl} \
		''-c jpeg''{nl} \
		''-c rgb''{nl} \
		''-c sr''{nl} \
		''-c srrgb'' \
	| __proxy__ = Send images uncompressed using the X11 Image Transport.  This \
			is useful when displaying to a local X server or X proxy (see \
			{ref prefix="Section ": TurboVNC_Usage_Local}.) \
		{nl}{nl} \
		__jpeg__ = Compress images using JPEG and send using the VGL Image \
			Transport.  This is useful when displaying to a remote X server (see \
			{ref prefix="Chapter ": VGL_Image_Transport_Usage}.) \
		{nl}{nl} \
		__rgb__ = Encode images as uncompressed RGB and send using the \
			VGL Image Transport.  This is useful when displaying to a remote X \
			server or X proxy across a very fast network (see \
			{ref prefix="Section ": TurboVNC_Usage_Remote}.) \
		{nl}{nl} \
		__sr__ = Compress images using the Sun Ray default compression method \
			and send using the Sun Ray Image Transport.  This requires that the \
			proprietary Sun Ray plugin be installed on the VirtualGL server. \
			(see {ref prefix="Chapter ": Sun_Ray_Usage}.) \
		{nl}{nl} \
		__srrgb__ = Encode images as uncompressed RGB and send using the Sun Ray \
			Image Transport.  This requires that the proprietary Sun Ray plugin be \
			installed on the VirtualGL server (see \
			{ref prefix="Chapter ": Sun_Ray_Usage}.) \
		{nl}{nl} \
		If this option is not specified, then the default is set as follows: \
		{nl}{nl} \
		If the X server is a Sun Ray server and the Sun Ray plugin is installed \
		on the VirtualGL server, then VGL will default to using __sr__ \
		compression.  VGL will fall back to using __proxy__ compression if, for \
		any given frame, it is unable to send the frame using the Sun Ray Image \
		Transport.  This could occur if, for example, the Sun Ray client is on \
		a network that is not visible to the VirtualGL server. \
		{nl}{nl} \
		If the X server is not a Sun Ray server but the ''DISPLAY'' environment \
		variable begins with '':'' or ''unix:'', then VirtualGL assumes that the \
		X display connection is local and it defaults to using __proxy__ \
		compression.  Otherwise, it defaults to __jpeg__ compression. \
	| (See Description) \
	|
| ''VGL_DISPLAY=''__''{d}''__ | ''-d ''__''{d}''__ \
	| __''{d}''__ specifies the X display or GLP device to use for 3D rendering. \
		If the VirtualGL server has multiple 3D graphics cards and you want the \
		OpenGL rendering to be redirected to a display other than :0, then you \
		can set ''VGL_DISPLAY=:1.0'' or whatever.  This could be used, for \
		instance, to support many application instances on a beefy multi-pipe \
		graphics server. \
		{nl}{nl} \
		__GLP mode (Solaris/Sparc only):__ \
		{nl}{nl} \
		Setting this option to ''glp'' will enable GLP mode and use the first \
		framebuffer device listed in ''/etc/dt/config/GraphicsDevices'' to \
		perform 3D rendering.  You can also set this option to the \
		pathname of a specific GLP device (example: ''/dev/fbs/jfb0''.)  See \
		{ref prefix="Section ": GLP_Usage} for more details. \
	|	:0 \
	|
| ''VGL_FPS=''__''{f}''__ | ''-fps ''__''{f}''__ \
	| Limit the client/server frame rate to __''{f}''__ frames/second, where \
		__''{f}''__ is a floating point number > 0.0.  If frame spoiling is \
		disabled, then this effectively limits the server's 3D rendering frame \
		rate as well. \
		{nl}{nl} \
		__This option is not available in the Sun Ray Image Transport.__ \
	|	Do not limit frame rate \
	|
| ''VGL_GAMMA=0''{nl}''VGL_GAMMA=1''{nl}''VGL_GAMMA=''__''{g}''__ \
	| ''-g''{nl}''+g''{nl}''-gamma ''__''{g}''__ \
	| "Gamma" refers to the relationship between the intensity of light which \
		your computer's monitor is instructed to display and the intensity which \
		it actually displays.  The curve is an exponential curve of the form \
		__Y = X{^G}__, where X is between 0 and 1.  G is called the "gamma" of the \
		monitor.  PC monitors and TV's usually have a gamma of around 2.2. \
		{nl}{nl} \
		Some of the math involved in 3D rendering assumes a linear gamma \
		(G = 1.0), so technically speaking, 3D applications will not display with \
		mathematical correctness unless the pixels are "gamma corrected" to \
		counterbalance the non-linear response curve of the monitor.  But some \
		systems do not have any form of built-in gamma correction, and thus the \
		applications developed for such systems have usually been designed to \
		display properly without gamma correction.  Gamma correction involves \
		passing pixels through a function of the form __X = W{^1/G}__, where G \
		is the "gamma correction factor" and should be equal to the gamma of the \
		monitor.  So the final output is __Y = X{^G} = (W{^1/G}){^G} = W__, which \
		describes a linear relationship between the intensity of the pixels drawn \
		by the application and the intensity of the pixels displayed by the \
		monitor. \
		{nl}{nl} \
		__''VGL_GAMMA=1'' or ''vglrun +g'' : Enable gamma correction with default \
			settings__ \
		{nl}{nl} \
		This option tells VirtualGL to enable gamma correction using the best \
		available method.  If VirtualGL is remotely displaying to a Solaris/Sparc \
		X server which has gamma-corrected X visuals, then VGL will attempt to \
		assign one of these visuals to the application.  This causes the 3D \
		output of the application to be gamma corrected by the factor specified \
		in ''fbconfig'' on the client machine (default: 2.22.)  Otherwise, if the \
		X server does not have gamma-corrected X visuals or if the \
		gamma-corrected visuals it has do not match the application's needs, then \
		VirtualGL performs gamma correction internally and uses a default gamma \
		correction factor of 2.22.  This option emulates the default behavior of \
		OpenGL applications running locally on Sparc machines. \
		{nl}{nl} \
		__''VGL_GAMMA=0'' or ''vglrun -g'' : Disable gamma correction__ \
		{nl}{nl} \
		This option tells VGL not to use gamma-corrected visuals, even if they are \
		available on the X server, and disables VGL's internal gamma correction \
		system as well.  This emulates the default behavior of OpenGL \
		applications running locally on Linux or Solaris/x86 machines. \
		{nl}{nl} \
		__''VGL_GAMMA=''__''{g}''__ or ''vglrun -gamma ''__''{g}''__ : Enable \
			VGL's internal gamma correction system with a gamma correction factor \
			of __''{g}''__ \
		{nl}{nl} \
		If ''VGL_GAMMA'' is set to an arbitrary floating point value, then \
		VirtualGL performs gamma correction internally using the specified value \
		as the gamma correction factor.  You can also specify a negative \
		value to apply a "de-gamma" function.  Specifying a gamma correction \
		factor of G (where G < 0) is equivalent to specifying a gamma correction \
		factor of -1/G. \
	| ''VGL_GAMMA=1'' on Solaris/Sparc VGL servers, ''VGL_GAMMA=0'' otherwise \
	|
| ''VGL_GLLIB=''__''{l}''__ | {:} \
	| __''{l}''__ specifies the location of an alternate OpenGL library. \
		{nl}{nl} \
		Normally, VirtualGL loads the first OpenGL dynamic library that it finds \
		in the dynamic linker path (usually ''/usr/lib/libGL.so.1'', \
		''/usr/lib64/libGL.so.1'',  or ''/usr/lib/64/libGL.so.1''.)  You can use \
		this setting to explicitly specify another OpenGL dynamic library to \
		load. \
		{nl}{nl} \
		Normally, you shouldn't need to muck with this unless something doesn't \
		work.  However, this setting is necessary when using VirtualGL with \
		[[chromium.txt#Chromium][Chromium]]. \
	| {:} |
| ''VGL_GUI=''__''{k}''__ | {:} \
	| __''{k}''__ specifies the key sequence used to pop up the VirtualGL \
		Configuration dialog, or ''none'' to disable it. \
		{nl}{nl} \
		VirtualGL will normally monitor an application's X event queue and pop up \
		the VirtualGL Configuration dialog whenever ''CTRL-SHIFT-F9'' is pressed. \
		In the event that this interferes with a key sequence that the \
		application is already using, you can redefine the key sequence used to \
		pop up the VirtualGL Configuration dialog by setting ''VGL_GUI'' to some \
		combination of ''shift'', ''ctrl'', ''alt'', and one of \
		''f1, f2, ..., f12''.  You can also set ''VGL_GUI'' to ''none'' to \
		disable the configuration dialog altogether.  See \
		{ref prefix="Chapter ": Config_Dialog} for more details. \
	|	shift-ctrl-f9 \
	|
| ''VGL_INTERFRAME=0''{nl}''VGL_INTERFRAME=1'' | {:} \
	| The VGL and Sun Ray Image Transports will normally compare each frame \
		with the previous frame and send only the portions of the image which \
		have changed.  Setting ''VGL_INTERFRAME'' to ''0'' disables this \
		behavior. \
		{nl}{nl} \
		Normally, you shouldn't need to disable interframe comparison except in \
		rare situations.  This setting was introduced in order to work around a \
		specific interaction issue between VirtualGL and Pro/ENGINEER v3.  See \
		{ref prefix="Section ": Application_Recipes} for more information. \
		{nl}{nl} \
		__This option is not available in the X11 Image Transport__ \
		{nl}{nl} \
		__When using the VGL Image Transport, interframe comparison is affected \
			by the ''VGL_TILESIZE'' option__ \
	| Inter-frame comparison enabled \
	|
| ''VGL_LOG=''__''{l}''__ | {:} \
	| Redirect all messages from VirtualGL to a log file specified by \
		__''{l}''__ \
		{nl}{nl} \
		Setting this environment variable to the pathname of a log file on the \
		VirtualGL server will cause VirtualGL to redirect all of its messages \
		(including profiling and trace output) to the specified log file \
		rather than to stderr. \
	| Print all messages to stderr \
	|
| ''VGL_NPROCS=''__''{n}''__{nl}''VGL_NPROCS=0'' \
	| ''-np ''__''{n}''__{nl}''-np 0''{nl} \
	| __''{n}''__ specifies the number of CPUs to use for multi-threaded \
		compression, or ''0'' to automatically determine the optimal number of \
		CPUs to use. \
		{nl}{nl} \
		The VGL Image Transport can divide the task of compressing each frame \
		among multiple server CPUs.  This might speed up the overall throughput \
		if the compression stage of the pipeline is the primary bottleneck.  The \
		default behavior (equivalent to setting ''VGL_NPROCS=0'') is to use all \
		but one of the available CPUs, up to a maximum of 3 total: \
		{nl}{nl} \
	  On a large multiprocessor system, the speedup is almost linear up to 3 \
		processors, but the algorithm scales very little past that point.  \
		VirtualGL will not allow more than 4 processors total to be used for \
		compression, nor will it allow you to set this parameter to a value \
		greater than the number of processors in the system. \
		{nl}{nl} \
		__This option is available only in the VGL Image Transport__ \
		{nl}{nl} \
		__Multi-threaded compression is affected by the ''VGL_TILESIZE'' \
			option__ \
	|	1P system: 1{nl} \
		2P system: 1{nl} \
		3P system: 2{nl} \
		4P & larger: 3{nl} \
	|
| ''VGL_PORT=''__''{p}''__ | ''-p ''__''{p}''__ \
	| __''{p}''__ specifies the TCP port that the server should use when \
		connecting to ''vglclient''.  The connection port for the VGL Image \
		Transport is normally determined by reading an X property that \
		''vglclient'' stores on the client's X display, so don't override this \
		unless you know what you're doing. \
		{nl}{nl} \
		__This option is available only in the VGL Image Transport__ \
	|	Read from property stored by ''vglclient'' \
	|
| ''VGL_PROFILE=0''{nl}''VGL_PROFILE=1'' | ''-pr''{nl}''+pr'' \
	| This option enables or disables profiling output.  If enabled, VirtualGL \
		will continuously benchmark itself and periodically print out the \
		throughput of various stages in its image pipelines. \
		{nl}{nl} \
		See {ref prefix="Chapter ": Perf_Measurement} for more details. \
	|	Profiling disabled \
	|
| ''VGL_PROGRESSIVE=0''{nl}''VGL_PROGRESSIVE=1'' | ''-prog''{nl}''+prog'' \
	| When Sun Ray default compression is being used, this option causes \
		the Sun Ray Image Transport to send a lossless (RGB) frame during periods \
		of inactivity. \
	| Progressive mode disabled \
	|
| {anchor: VGL_QUAL}''VGL_QUAL=''{nl}''<1-100>'' | ''-q <1-100>'' \
	| __Fine-tune the amount of JPEG compression__ \
		{nl}{nl} \
		In digital images, "frequency" refers to how quickly the color changes \
		between light and dark as you move either horizontally or vertically \
		in the image.  Images with very sharp, bright features on a dark \
		background, for instance, consist of both low- and high-frequency \
		components, whereas images with smooth transitions between each pixel \
		contain only low-frequency components.  JPEG compression works by \
		breaking down the image into its constituent frequencies and then \
		throwing out the highest of these frequencies.  The JPEG image "quality" \
		determines which frequencies are thrown out.  A JPEG quality of 1 throws \
		out all but the lowest frequencies and thus produces a very \
		impressionistic, but generally not very useful, compressed image.  A JPEG \
		quality of 100 retains all frequencies in the original image (but, due to \
		roundoff errors, is still not completely lossless.) \
		{nl}{nl} \
		Because the human eye usually can't detect the highest frequencies in the \
		image, and often because the image lacks those high-frequency elements to \
		begin with, a sufficiently high JPEG quality setting can produce a \
		"perceptually lossless" image.  A "perceptually lossless" image contains \
		a small amount of mathematical error vs. the original image, but this \
		error is so small that the human visual system cannot distinguish it \
		(under normal circumstances.)  The threshold quality level at which JPEG \
		compression becomes perceptually lossless is different for each image, \
		but experiments with various visual difference benchmarks (such as \
		[[http://www.mpi-inf.mpg.de/resources/hdr/vdp/][HDR-VDP]]) suggest that \
		a JPEG quality of 95 is sufficient to guarantee perceptual \
		losslessness in the types of applications (volume visualization apps, \
		in particular) where image quality is critical.  As with any benchmarks, \
		Your Mileage May Vary.  If quality is of paramount concern, consider \
		setting the JPEG quality to 100, using RGB encoding, or enabling the \
		''VGL_PROGRESSIVE'' option. \
 		{nl}{nl} \
		__** This option has no effect in "Raw" Mode. **__ \
	|	95 \
	|
| ''VGL_READBACK=0''{nl}''VGL_READBACK=1'' | {:} \
	| __Enable/disable readback__ \
		{nl}{nl} \
		On rare occasions, it might be desirable to have VirtualGL redirect \
		OpenGL rendering from an application into a Pbuffer but not automatically \
		read back and send the rendered pixels.  Some applications have their own \
		 mechanisms for reading back the buffer, so disabling VirtualGL's \
		readback mechanism prevents duplication of effort. \
		{nl}{nl} \
		This feature was developed initially to support running \
		[[http://www.paraview.org/][ParaView]] in parallel using MPI.  ParaView \
		MPI normally uses MPI processes 1 through N as rendering servers, each \
		drawing a portion of the geometry into a separate window on a \
		separate X display.  ParaView reads back these server windows and \
		composites the pixels into the main application window, which is \
		controlled by MPI process 0.  By creating a script which passes a \
		different value of ''VGL_DISPLAY'' and ''VGL_READBACK'' to each MPI \
		process, it is possible to make all of the ParaView server processes \
		render to off-screen buffers on different graphics cards while \
		preventing VirtualGL from displaying any pixels except those generated by \
		process 0. \
	|	Readback enabled \
	|
| {anchor: VGL_SPOIL}''VGL_SPOIL=0''{nl}''VGL_SPOIL=1'' | ''-sp''{nl}or{nl}''+sp'' \
	| __Enable/disable frame spoiling__ \
		{nl}{nl} \
		By default, VirtualGL will drop frames so as not to slow down the \
		rendering rate of the server's graphics engine.  This should produce the \
		best results with interactive applications, but it may be desirable to \
		turn off frame spoiling when running benchmarks or other non-interactive \
		applications.  Turning off frame spoiling will force one frame to be read \
		back and sent on each end-of-frame event, so that the frame rate reported \
		by OpenGL benchmarks will accurately reflect the frame rate seen by the \
		user.  Disabling frame spoiling also prevents non-interactive \
		applications from wasting graphics resources by rendering frames that \
		will never be seen.  With frame spoiling turned off, the 3D rendering \
		pipeline behaves as if it is fill-rate limited to about 30 or 40 \
		Megapixels/second, the maximum throughput of the VirtualGL system on \
		current CPU's. \
	|	Spoiling enabled \
	|
| ''VGL_SSL=0''{nl}''VGL_SSL=1'' | ''-s''{nl}or{nl}''+s'' \
	| __Tunnel the VirtualGL compressed image stream inside a secure socket \
			layer__ \
		{nl}{nl} \
		__** This option has no effect in "Raw" Mode. **__ \
	|	SSL disabled \
	|
| {anchor: VGL_STEREO}''VGL_STEREO''=__''{s}''__ | | | |
| {anchor: VGL_SUBSAMP}''VGL_SUBSAMP=''{nl}''<1x|2x|4x|gray>'' | ''-samp <1x|2x|4x|gray>'' \
	|	__Manually specify the level of chrominance subsampling (1x, 2x, 4x, or \
		gray) in the JPEG compressor__ \
		{nl}{nl} \
		When an image is compressed as JPEG, each pixel in the image is first \
		converted from RGB (Red/Green/Blue) to YUV.  An RGB pixel has three \
		values that specify the amounts of red, green, and blue that make up the \
		pixel's color.  A YUV pixel has three values that specify the overall \
		brightness of the pixel (Y, or "luminance") and the overall color of the \
		pixel (U and V, or "chrominance".) \
		{nl}{nl} \
		Since the human eye is less sensitive to changes in color than it is to \
		changes in brightness, the JPEG standard allows one to throw away the \
		chrominance components for some of the pixels.  This technique, called \
		"chrominance subsampling", significantly reduces the size of the \
		compressed image without causing much noticeable loss in image quality. \
		By default, VirtualGL uses no chrominance subsampling (AKA "1x \
		subsampling") when it compresses images for delivery to the client. \
		"2x subsampling" discards the chrominance components for every other \
		pixel along the image's X direction (this is also known as "4:2:2 \
		subsampling.")  Similarly, "4x subsampling" discards the chrominance \
		components for every other pixel along both the X and Y directions of \
		the image (this is also known as "4:2:0 subsampling.") Grayscale throws \
		out all chrominance components, leaving only luminance. \
		{nl}{nl} \
		All else being equal, 2x subsampling generally produces images that are \
		about 20-25% smaller than images with no subsampling.  Thus, VirtualGL \
		will generally consume about 20-25% less network bandwidth if 2x \
		subsampling is enabled.  Similarly, 4x subsampling will generally reduce \
		the network usage by about 35-40%. \
		{nl}{nl} \
		Subsampling artifacts are rarely observed with volume data, \
		since it usually only contains 256 colors to begin with.  But narrow, \
		aliased lines and other sharp features on a black background will tend to \
		produce artifacts when subsampling is enabled. \
		{nl}{nl} \
		The Axis Indicator from a Popular Visualization App displayed with 1x, \
		2x, and 4x subsampling (respectively):{nl} \
		{img: 444.gif}{img: 422.gif}{img: 411.gif} \
		{nl}{nl} \
		__** This option has no effect in "Raw" Mode. **__ \
	|	1x \
	|
| ''VGL_SYNC=0''{nl}''VGL_SYNC=1'' | ''-sync''{nl}or{nl}''+sync'' \
	| __Enable/disable strict 2D/3D synchronization (necessary to pass GLX \
			conformance tests)__ \
		{nl}{nl} \
		Normally, VirtualGL's operation is asynchronous from the point of view of \
		the application.  The application swaps the buffers or calls \
		''glFinish()'' or ''glFlush()'' or ''glXWaitGL()'', and VirtualGL reads \
		back the framebuffer and sends the pixels to the client's display ... \
		eventually.  This will work fine for the vast majority of applications, \
		but it is not strictly conformant.  Technically speaking, when an \
		application calls ''glXWaitGL()'' or ''glFinish()'', it is well within \
		its rights to expect the OpenGL-rendered pixels to be immediately \
		available in the X window.  Fortunately, very few applications actually \
		do expect this, but on rare occasions, an application may try to use \
		''XGetImage()'' or other X11 functions to obtain a bitmap of the pixels \
		that were rendered by OpenGL.  Enabling ''VGL_SYNC'' is a somewhat \
		extreme measure that may be needed to get such applications to work \
		properly.  It was developed primarily as a way to pass the GLX \
		conformance suite (''conformx'', specifically.)  When ''VGL_SYNC'' is \
		enabled, every call to ''glFinish()'' or ''glXWaitGL()'' will cause the \
		contents of the server's framebuffer to be read back and __synchronously__ \
		drawn into the client's window __without compression or frame spoiling__. \
		The call to ''glFinish()'' or ''glXWaitGL()'' will not return until \
		VirtualGL has verified that the pixels have been delivered into the \
		client's window.  As such, enabling this mode can have potentially dire \
		effects on performance. \
	| Synchronization disabled \
	|
| ''VGL_TILESIZE'' | {:} \
	| __A number between 8 and 1024 (inclusive)__ \
		{nl}{nl} \
		Normally, in Direct Mode, VirtualGL will divide an OpenGL window into \
		tiles of 256x256 pixels, compare each tile vs. the previous frame, and \
		only compress & send the tiles which have changed.  It will also divide \
		up the task of compressing these tiles among the available CPUs in a \
		round robin fashion, if multi-threaded compression is enabled.  There are \
		several tradeoffs that must be considered when choosing a tile size: \
		{nl}{nl} \
		Smaller tile sizes: \
		{list: \
			{item: Better parallel scalability} \
			{item: Worse compression efficiency} \
			{item: Better inter-frame optimization} \
			{item: Worse network efficiency}} \
		Larger tile sizes: \
		{list: \
			{item: Worse parallel scalability} \
			{item: Better compression efficiency} \
			{item: Worse inter-frame optimization} \
			{item: Better network efficiency}} \
		{nl} \
		Smaller tiles can more easily be divided up among multiple CPUs, but they \
		compress less efficiently (and less quickly) on an individual basis.  \
		Using larger tiles can reduce traffic to the client by allowing the \
		server to send only one frame update instead of many.  But on the flip \
		side, using larger tiles decreases the chance that a tile will be \
		unchanged from the previous frame.  Thus, the server may only send one or \
		two packets per frame, but the cumulative size of those packets may be \
		much larger than if a smaller tile size was used. \
		{nl}{nl} \
		256x256 was chosen as the default because, in experiments, it provided \
		the best balance between scalability and efficiency on the platforms that \
		VirtualGL supports. \
		{nl}{nl} \
		__** This option has no effect in "Raw" Mode. **__ \
	|	256 \
	|
| ''VGL_TRACE=0''{nl}''VGL_TRACE=1'' | ''-tr''{nl}or{nl}''+tr'' \
	| __Enable/disable tracing__ \
		{nl}{nl} \
		When tracing is enabled, VirtualGL will log all calls to the GLX and X11 \
		functions it is intercepting, as well as the arguments, return values, \
		and execution times for those functions.  This is useful when diagnosing \
		interaction problems between VirtualGL and a particular OpenGL \
		application. \
	| Tracing disabled \
	|
| ''VGL_VERBOSE=0''{nl}''VGL_VERBOSE=1'' | ''-v''{nl}or{nl}''+v'' \
	| __Enable/disable verbosity__ \
		{nl}{nl} \
		When in verbose mode, VirtualGL will reveal some of the decisions it \
		makes behind the scenes, such as which code path it is using to compress \
		JPEG images, which type of X11 drawing it is using, etc.  This can be \
		helpful when diagnosing performance problems. \
	|	Verbosity disabled \
	|
| ''VGL_X11LIB'' | {:} \
	| __the location of an alternate X11 library__ \
		{nl}{nl} \
		Normally, VirtualGL loads the first X11 dynamic library that it finds in \
		the dynamic linker path (usually ''/usr/lib/libX11.so.?'', \
		''/usr/lib/64/libX11.so.?'', ''/usr/X11R6/lib/libX11.so.?'', or \
		''/usr/X11R6/lib64/libX11.so.?''.)  You can use this setting to \
		explicitly specify another X11 dynamic library to load. \
		{nl}{nl} \
		Normally, you shouldn't need to muck with this unless something doesn't \
		work. \
	| {:} |
| ''VGL_XVENDOR'' | {:} \
	| __Return a fake X11 vendor string when the application calls \
		''XServerVendor()''__ \
		{nl}{nl} \
		Some applications expect ''XServerVendor()'' to return a particular \
		value, which the application (sometimes erroneously) uses to figure out \
		whether it's running locally or remotely.  This setting allows you to \
		fool such applications into thinking they're running on a "local" X \
		server rather than a remote connection. \
	| {:} |

** Client Settings

*** Environment Variables
#OPT: noList! plain!

|| Environment Variable Name ||	Description || Default Value ||
| ''VGL_PROFILE=0''{nl}''VGL_PROFILE=1'' \
	| __Enable/disable profiling output__ \
		{nl}{nl} \
		If enabled, this will cause the VirtualGL client to continuously \
		benchmark itself and periodically print out the throughput of \
		decompressing and drawing pixels into the application window. \
		{nl}{nl} \
		See {ref prefix="Chapter ": Perf_Measurement} for more details. \
	|	Profiling disabled \
	|
| ''VGL_VERBOSE=0''{nl}''VGL_VERBOSE=1'' \
	| __Enable/disable verbosity__ \
		{nl}{nl} \
		When in verbose mode, VirtualGL will reveal some of the decisions it \
		makes behind the scenes, such as which code path it is using to \
		decompress JPEG images, which type of X11 drawing it is using, etc. \
		This can be helpful when diagnosing performance problems. \
	|	Verbosity disabled \
	|

*** ''vglclient'' Command-Line Arguments
#OPT: noList! plain!

|| ''vglclient'' Argument || Description || Default ||
| ''-port <port''{nl}''number>'' \
	|	Causes the client to listen for unencrypted connections on the specified \
		TCP port \
	|	4242 \
	|
| ''-sslport <port''{nl}''number>'' \
	| Causes the client to listen for SSL connections on the specified TCP \
		port \
	|	4243 \
	|
| ''-sslonly'' \
	|	Causes the client to reject all unencrypted connections \
	|	Accept both SSL and unencrypted connections \
	|
| ''-nossl'' \
	| Causes the client to reject all SSL connections \
	|	Accept both SSL and unencrypted connections \
	|
| ''-l <log file>'' \
	| Redirect all output from the client to the specified file \
	|	Output goes to stderr \
	|
| ''-x'' \
	|	Use X11 functions to draw pixels into the application window \
	|	Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise \
	|
| ''-gl'' \
	| Use OpenGL functions to draw pixels into the application window \
	| Use OpenGL on Solaris/Sparc or if stereo is enabled; use X11 otherwise \
	|

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="language" content="en">
<meta name="date" content="2013-05-18T01:06:07">
<meta name="generator" content="deplate.rb 0.8.5">
<title>User&rsquo;s Guide for VirtualGL 2.3.3</title>
<link rel="start" href="index.html" title="Frontpage">
<link rel="chapter" href="index.html#hd001" title="1 Legal Information">
<link rel="chapter" href="index.html#hd002" title="2 Conventions Used in This Document">
<link rel="chapter" href="index.html#hd003" title="3 Overview">
<link rel="chapter" href="index.html#hd004" title="4 System Requirements">
<link rel="chapter" href="index.html#hd005" title="5 Obtaining and Installing VirtualGL">
<link rel="chapter" href="index.html#hd006" title="6 Configuring a Linux or Unix Machine as a VirtualGL Server">
<link rel="chapter" href="index.html#hd007" title="7 Configuring a Windows Machine as a VGL Transport Client">
<link rel="chapter" href="index.html#hd008" title="8 Using VirtualGL with the VGL Transport">
<link rel="chapter" href="index.html#hd009" title="9 Using VirtualGL with X Proxies Such as VNC">
<link rel="chapter" href="index.html#hd0010" title="10 Support for the X Video Extension">
<link rel="chapter" href="index.html#hd0011" title="11 Using VirtualGL in a Sun Ray Environment">
<link rel="chapter" href="index.html#hd0012" title="12 Transport Plugins">
<link rel="chapter" href="index.html#hd0013" title="13 Using VirtualGL with setuid/setgid Executables">
<link rel="chapter" href="index.html#hd0014" title="14 Using VirtualGL with Chromium">
<link rel="chapter" href="index.html#hd0015" title="15 Using VirtualGL with VirtualBox">
<link rel="chapter" href="index.html#hd0016" title="16 Other Application Recipes">
<link rel="chapter" href="index.html#hd0017" title="17 Advanced OpenGL Features">
<link rel="chapter" href="index.html#hd0018" title="18 Performance Measurement">
<link rel="chapter" href="index.html#hd0019" title="19 The VirtualGL Configuration Dialog">
<link rel="chapter" href="index.html#hd0020" title="20 Advanced Configuration">
<link rel="stylesheet" type="text/css" href="virtualgl.css" title="virtualgl">
</head>
<body >
<a name="#pagetop"></a>
<div class="title">
<p class="title">User&rsquo;s Guide for VirtualGL 2.3.3</p>
</div>
<a name="file000"></a>
<p><em>Intended audience:</em> System Administrators, Graphics Programmers, 
Researchers, and others with knowledge of Linux or Unix operating 
systems, OpenGL and GLX, and X windows.</p>

<div id="Table_of_Contents">
<div id="Table_of_ContentsBlock" class="toc">
<h1 class="toc">Table of Contents</h1>
<ul class="toc">
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd001">1 Legal Information</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd002">2 Conventions Used in This Document</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd003">3 Overview</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd004">4 System Requirements</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd004001">4.1 Linux/x86 and Other x86 Un*x 
                Operating Systems</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd004002">4.2 Mac/x86</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd004003">4.3 Windows</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd004004">4.4 Additional Requirements for 
                Stereographic Rendering</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd004005">4.5 Additional Requirements for 
                Transparent Overlays</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd005">5 Obtaining and Installing VirtualGL</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005001">5.1 Installing VirtualGL on Linux</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005002">5.2 Installing the VirtualGL Client on 
                OS X</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005003">5.3 Installing the VirtualGL Client on 
                Windows (Exceed)</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005004">5.4 Installing the VirtualGL Client on 
                Windows (Cygwin/X)</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005005">5.5 Installing VirtualGL from Source</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd005006">5.6 Uninstalling VirtualGL</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd006">6 Configuring a Linux or Unix Machine as a 
        VirtualGL Server</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd006001">6.1 Granting Access to the 3D X 
                Server</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd006002">6.2 Using VirtualGL with Multiple 
                Graphics Cards</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd006003">6.3 SSH Server Configuration</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd006004">6.4 Un-Configuring the Server</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd007">7 Configuring a Windows Machine as a VGL 
        Transport Client</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd007001">7.1 Configuring and Optimizing Exceed</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd007002">7.2 Optimizing Cygwin/X</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd008">8 Using VirtualGL with the VGL Transport</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008001">8.1 VGL Transport with X11 Forwarding</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008002">8.2 VGL Transport with a Direct X11 
                Connection</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008003">8.3 VGL Transport with X11 Forwarding 
                and SSH Tunneling</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008004">8.4 VGL Transport over Gigabit 
                Networks</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008005">8.5 VGL Transport with XDMCP</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd008006">8.6 The VirtualGL Client Application: 
                Nuts and Bolts</a>
                <ul class="toc">
                    <li class="Itemize-5 toc">
                        <a class="toc" href="#hd008006001">8.6.1 The VirtualGL Client and 
                        Firewalls</a>
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd009">9 Using VirtualGL with X Proxies Such as 
        VNC</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd009001">9.1 Using VirtualGL with an X Proxy on 
                the Same Server</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd009002">9.2 Using VirtualGL with an X Proxy on a 
                Different Machine</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0010">10 Support for the X Video Extension</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0010001">10.1 The VGL Transport with YUV 
                Encoding</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0010002">10.2 The XV Transport</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0011">11 Using VirtualGL in a Sun Ray 
        Environment</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0012">12 Transport Plugins</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0013">13 Using VirtualGL with setuid/setgid 
        Executables</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0014">14 Using VirtualGL with Chromium</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0014001">14.1 Configuration 1: Sort-First 
                Rendering (Image-Space Decomposition)</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0014002">14.2 Configuration 2: Sort-First 
                Rendering (Image-Space Decomposition) with Readback</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0014003">14.3 Configuration 3: Sort-Last 
                Rendering (Object-Space Decomposition)</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0014004">14.4 A Note About Performance</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0015">15 Using VirtualGL with VirtualBox</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0016">16 Other Application Recipes</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0017">17 Advanced OpenGL Features</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0017001">17.1 Stereographic Rendering</a>
                <ul class="toc">
                    <li class="Itemize-5 toc">
                        <a class="toc" href="#hd0017001001">17.1.1 Quad-Buffered Stereo</a>
                    </li>
                    <li class="Itemize-5 toc">
                        <a class="toc" href="#hd0017001002">17.1.2 Anaglyphic Stereo</a>
                    </li>
                    <li class="Itemize-5 toc">
                        <a class="toc" href="#hd0017001003">17.1.3 Passive Stereo</a>
                    </li>
                    <li class="Itemize-5 toc">
                        <a class="toc" href="#hd0017001004">17.1.4 Selecting a Stereo Mode</a>
                    </li>
                </ul>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0017002">17.2 Transparent Overlays</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0017003">17.3 Indexed (PseudoColor) Rendering</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0017004">17.4 Troubleshooting</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0018">18 Performance Measurement</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0018001">18.1 VirtualGL&rsquo;s Built-In 
                Profiling System</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0018002">18.2 Frame Spoiling</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0018003">18.3 VirtualGL Diagnostic Tools</a>
            </li>
        </ul>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0019">19 The VirtualGL Configuration Dialog</a>
    </li>
    <li class="Itemize-1 toc">
        <a class="toc" href="#hd0020">20 Advanced Configuration</a>
        <ul class="toc">
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0020001">20.1 Server Settings</a>
            </li>
            <li class="Itemize-3 toc">
                <a class="toc" href="#hd0020002">20.2 Client Settings</a>
            </li>
        </ul>
    </li>
</ul>
</div></div>
<p><br /></p>

<hr class="break" />


<h1 id="hd001"><a name="file001"></a>1&nbsp;Legal Information</h1>

<p><img src="somerights20.png" alt="somerights20" class="inline" id="imgid_0" name="imgid_0"/></p>

<p>This document and all associated illustrations are licensed under the 
<span class="remote"><a class="remote" href="http://creativecommons.org/licenses/by/2.5/">Creative 
Commons Attribution 2.5 License</a></span><a name="idx001"></a>.  Any 
works that contain material derived from this document must cite The 
VirtualGL Project as the source of the material and list the current URL 
for the VirtualGL web site.</p>

<p>The official VirtualGL binaries contain libjpeg-turbo, which is based in 
part on the work of the Independent JPEG Group.</p>

<p>The VirtualGL server components include software developed by the 
<span class="remote"><a class="remote" href="http://www.fltk.org/">FLTK 
Project</a></span><a name="idx002"></a> and distributed under the terms 
of the <a href="LICENSE-FLTK.txt">FLTK License</a><a name="idx003"></a>.</p>

<p>The package for the VirtualGL Client for Exceed includes 
<span class="remote"><a class="remote" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a></span><a name="idx004"></a>, 
which is released under <a href="LICENSE-PuTTY.txt">this 
license</a><a name="idx005"></a>.</p>

<p>VirtualGL includes portions of 
<span class="remote"><a class="remote" href="http://www.x.org">X.org</a></span><a name="idx006"></a>, 
which is released under <a href="LICENSE-xauth.txt">this 
license</a><a name="idx007"></a>.</p>

<p>VirtualGL is licensed under the <a href="LICENSE.txt">wxWindows Library 
License, v3.1</a><a name="idx008"></a>, a derivative of the 
<a href="LGPL.txt">GNU Lesser General Public License (LGPL), 
v2.1</a><a name="idx009"></a>.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd002"><a name="file002"></a>2&nbsp;Conventions Used in This Document</h1>

<p>This document assumes that VirtualGL will be installed in the default 
directory (<code>/opt/VirtualGL</code> on Un*x and Mac systems and 
<code>c:\Program&nbsp;Files\VirtualGL-</code><em><code>{version}</code></em><code>-</code><em><code>{build}</code></em> 
on Windows systems, where <em><code>{version}</code></em> and 
<em><code>{build}</code></em> are the version and build number of 
VirtualGL, respectively.)  If your installation of VirtualGL resides in 
a different directory, then adjust the instructions accordingly.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd003"><a name="file003"></a>3&nbsp;Overview</h1>

<p><a name="Overview"></a></p>

<p>VirtualGL is an open source package that gives any Unix or Linux remote 
display software the ability to run OpenGL applications with full 3D 
hardware acceleration.  Some remote display software lacks the ability 
to run OpenGL applications at all.  Other remote display software forces 
OpenGL applications to use a slow software-only OpenGL renderer, to the 
detriment of performance as well as compatibility.  The traditional 
method of displaying OpenGL applications to a remote X server (indirect 
rendering) supports 3D hardware acceleration, but this approach causes 
all of the OpenGL commands and 3D data to be sent over the network to be 
rendered on the client machine.  This is not a tenable proposition 
unless the data is relatively small and static, unless the network is 
very fast, and unless the OpenGL application is specifically tuned for a 
remote X-Windows environment.</p>

<p>With VirtualGL, the OpenGL commands and 3D data are instead redirected 
to a 3D graphics accelerator on the application server, and only the 
rendered 3D images are sent to the client machine.  VirtualGL thus 
&ldquo;virtualizes&rdquo; 3D graphics hardware, allowing it to be 
co-located in the &ldquo;cold room&rdquo; with compute and storage 
resources.  VirtualGL also allows 3D graphics hardware to be shared 
among multiple users, and it provides &ldquo;workstation-like&rdquo; 
levels of performance on even the most modest of networks.  This makes 
it possible for large, noisy, hot 3D workstations to be replaced with 
laptops or even thinner clients.  More importantly, however, VirtualGL 
eliminates the workstation and the network as barriers to data size.  
Users can now visualize huge amounts of data in real time without 
needing to copy any of the data over the network or sit in front of the 
machine that is rendering the data.</p>

<p>Normally, a Unix OpenGL application would send all of its drawing 
commands and data, both 2D and 3D, to an X-Windows server, which may be 
located across the network from the application server.  VirtualGL, 
however, employs a technique called &ldquo;split rendering&rdquo; to 
force the 3D commands from the application to go to a 3D graphics card 
in the application server.  VGL accomplishes this by pre-loading a 
dynamic shared object (DSO) into the OpenGL application at run time.  
This DSO intercepts a handful of GLX, OpenGL, and X11 commands necessary 
to perform split rendering.  Whenever a window is created by the 
application, VirtualGL creates a corresponding 3D pixel buffer 
(&ldquo;Pbuffer&rdquo;) on a 3D graphics card in the application server.  
Whenever the application requests that an OpenGL rendering context be 
created for the window, VirtualGL intercepts the request and creates the 
context on the corresponding Pbuffer instead.  Whenever the  application 
swaps or flushes the drawing buffer to indicate that it has finished 
rendering a frame, VirtualGL reads back the Pbuffer and sends the 
rendered 3D image to the client.</p>

<p>The beauty of this approach is its non-intrusiveness.  VirtualGL 
monitors a few X11 commands and events to determine when windows have 
been resized, etc., but it does not interfere in any way with the 
delivery of 2D X11 commands to the X server.  For the most part, VGL 
does not interfere with the delivery of OpenGL commands to the graphics 
card, either (there are some exceptions, such as its handling of color 
index rendering.)  VGL merely forces the OpenGL commands to be delivered 
to a server-side graphics card rather than a client-side graphics card.  
Once the OpenGL rendering context has been established in a server-side 
Pbuffer, everything (including esoteric OpenGL extensions, 
fragment/vertex programs, etc.) should &ldquo;just work.&rdquo;  If an 
application runs locally on a 3D server/workstation, then that same 
application should run remotely from that same machine using VirtualGL.</p>

<p>VirtualGL has two built-in &ldquo;image transports&rdquo; that can be 
used to send rendered 3D images to the client machine:</p>

<p><a name="VGL_Transport"></a></p>

<dl class="Description">
    <dt class="Description-1 Description">1. VGL Transport</dt>
    <dd class="Description-1 Description">
        The VGL Transport is most often used whenever the 2D X server (the X 
        server used to draw the application&rsquo;s GUI and transmit keyboard 
        and mouse events back to the application server) is located across the 
        network from the application server, for instance if the 2D X server is 
        running on the user&rsquo;s desktop machine.  VirtualGL uses its own 
        protocol on a dedicated TCP socket to send the rendered 3D images to the 
        client machine, and the VirtualGL Client application decodes the images 
        and composites them into the appropriate X window.  The VGL Transport 
        can either deliver uncompressed images (RGB encoded), or it can compress 
        images in real time using a high-speed JPEG codec.  It also supports the 
        delivery of stereo image pairs, which can be reconstructed into a stereo 
        image by the VirtualGL Client.
    </dd>
</dl>

<a name="fig003001"></a>
<div class="figure">
<p class="caption">Figure 3.1: The VGL Transport with a Remote 2D X Server</p>
<img src="vgltransport.png" alt="vgltransport" class="figure" id="imgid_9" name="imgid_9"/>
</div>

<p><a name="X11_Transport"></a></p>

<dl class="Description">
    <dt class="Description-1 Description">2. X11 Transport</dt>
    <dd class="Description-1 Description">
        The X11 Transport simply draws the rendered 3D images into the 
        appropriate X window using XPutImage() and similar X-Windows commands.  
        This is most useful in conjunction with an &ldquo;X Proxy&rdquo;, which 
        can be one of any number of Unix remote display applications, such as 
        VNC.  These X proxies are essentially &ldquo;virtual&rdquo; X servers.  
        They appear to the application as a normal X server, but they perform 
        X11 rendering to a virtual framebuffer in main memory rather than to a 
        real framebuffer on a graphics card.  This allows the X proxy to send 
        only images to the client machine rather than chatty X-Windows rendering 
        commands.  When using the X11 Transport, VirtualGL does not perform any 
        image compression or encoding itself.  It instead relies upon an X proxy 
        to encode and deliver the images to the client(s).  Since the use of an 
        X proxy eliminates the need to send X-Windows commands over the network, 
        this is the best means of using VirtualGL over high-latency or 
        low-bandwidth networks.
    </dd>
</dl>

<a name="fig003002"></a>
<div class="figure">
<p class="caption">Figure 3.2: The X11 Transport with an X Proxy</p>
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_10" name="imgid_10"/>
</div>

<p>VirtualGL also provides an API that can be used to develop custom image 
transport plugins.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd004"><a name="file004"></a>4&nbsp;System Requirements</h1>


<h2 id="hd004001">4.1&nbsp;Linux/x86 and Other x86 Un*x Operating Systems</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server (x86)</th>
    <th class="head standard">Server (x86-64)</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium 4, 1.7 GHz or faster (or equivalent) <ul class="Itemize"><li class="Itemize-0">
    For optimal performance, the processor should support SSE2 extensions.
</li>
<li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">Pentium 4/Xeon with EM64T, or&hellip;<br /> AMD Opteron or Athlon64, 1.8 GHz or faster <ul class="Itemize"><li class="Itemize-0">
    Dual processors or dual cores recommended
</li></ul></td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard" colspan="2">Any decent 3D graphics card that supports Pbuffers <ul class="Itemize"><li class="Itemize-0">
    If the manufacturer of your 3D adapter provides proprietary drivers, 
    then it is recommended that you install these.  Many of the drivers that 
    ship with Linux, for instance, do not provide full 3D acceleration or 
    Pbuffer support.
</li></ul></td>
    <td class="standard">Any graphics card with decent 2D performance <ul class="Itemize"><li class="Itemize-0">
    If using a 3D graphics card, install the vendor drivers for that 3D 
    graphics card.
</li></ul></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard" colspan="3">X server configured to export True Color (24-bit or 32-bit) visuals</td>
  </tr>
</table>
</div>




<h2 id="hd004002">4.2&nbsp;Mac/x86</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Any Intel-based Mac</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">OS X 10.4 (&ldquo;Tiger&rdquo;) or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <em>VGL Transport Only</em>: Mac X11 application (in the &ldquo;Optional 
    Installs&rdquo; package on the OS X install discs)
</li></ul></td>
  </tr>
</table>
</div>




<h2 id="hd004003">4.3&nbsp;Windows</h2>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Recommended CPU</td>
    <td class="standard">Pentium III or Pentium 4, 1.0 GHz or faster (or equivalent)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Graphics</td>
    <td class="standard">Any graphics card with decent 2D performance</td>
  </tr>
  <tr class="standard">
    <td class="high standard">O/S</td>
    <td class="standard">Windows 2000 or later</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Other Software</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    <em>VGL Transport Only</em>: 
    <span class="remote"><a class="remote" href="http://x.cygwin.com">Cygwin/X</a></span><a name="idx0010"></a> 
    or 
    <span class="remote"><a class="remote" href="http://connectivity.opentext.com">OpenText</a></span><a name="idx0011"></a> 
    Exceed v8 or newer
</li>
<li class="Itemize-0">
    Client display must have a 24-bit or 32-bit color depth (True Color.)
</li></ul></td>
  </tr>
</table>
</div>




<h2 id="hd004004">4.4&nbsp;Additional Requirements for Stereographic Rendering</h2>

<p><a name="Stereo_Requirements"></a></p>

<div class="important"><p class="important">
The client requirements do not apply to anaglyphic stereo.  See Chapter <a href="#Advanced_OpenGL" class="ref">17</a> for more details.
</p></div>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Server</th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux/Unix</td>
    <td class="standard" colspan="2">3D graphics card that supports stereo (examples: nVidia Quadro, ATI FirePro.)  The 2D X server should be configured to export stereo visuals.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
    <td class="standard">N/A</td>
    <td class="standard">3D graphics card that supports stereo (example: nVidia Quadro.) The 2D X server should be configured to export stereo visuals.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard">N/A</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports stereo (examples: nVidia Quadro, ATI 
    FirePro.)  Stereo support should be enabled in the 3D driver 
    configuration.
</li>
<li class="Itemize-0">
    2D X server that supports and is configured to export stereo visuals 
    (such as 
    <span class="remote"><a class="remote" href="http://connectivity.opentext.com">OpenText</a></span><a name="idx0012"></a> 
    Exceed 3D v8 or newer)
</li></ul></td>
  </tr>
</table>
</div>




<h2 id="hd004005">4.5&nbsp;Additional Requirements for Transparent Overlays</h2>

<p><a name="Overlay_Requirements"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard"></th>
    <th class="head standard">Client</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="high standard">Linux/Unix</td>
    <td class="standard" rowspan="2">3D graphics card that supports transparent overlays (examples: nVidia Quadro, ATI FirePro.)  The 2D X server should be configured to export overlay visuals.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Mac/x86</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Windows</td>
    <td class="standard"><ul class="Itemize"><li class="Itemize-0">
    3D graphics card that supports transparent overlays (examples: nVidia 
    Quadro, ATI FirePro.)  Overlay support should be enabled in the 3D 
    driver configuration.
</li>
<li class="Itemize-0">
    2D X server that supports and is configured to export transparent 
    overlay visuals (such as 
    <span class="remote"><a class="remote" href="http://connectivity.opentext.com">OpenText</a></span><a name="idx0013"></a> 
    Exceed 3D v8 or newer)
</li></ul></td>
  </tr>
</table>
</div>


<p><br /></p>

<hr class="break" />



<h1 id="hd005"><a name="file005"></a>5&nbsp;Obtaining and Installing VirtualGL</h1>

<div class="important"><p class="important">
VirtualGL must be installed on any machine that will act as a VirtualGL server or as a client for the <a href="#VGL_Transport">VGL Transport</a><a name="idx0014"></a>. It is not necessary to install VirtualGL on the client machine if using VNC or another type of X proxy.
</p></div>


<h2 id="hd005001">5.1&nbsp;Installing VirtualGL on Linux</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Download the appropriate VirtualGL binary package for your system from 
        the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/">Files 
        area</a></span><a name="idx0015"></a> of the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl">VirtualGL 
        SourceForge project page</a></span><a name="idx0016"></a>. Packages are 
        provided for Linux distributions in the 
        <span class="remote"><a class="remote" href="http://www.redhat.com/">Red 
        Hat</a></span><a name="idx0017"></a>, 
        <span class="remote"><a class="remote" href="http://www.novell.com/linux/">SuSE</a></span><a name="idx0018"></a>, 
        or 
        <span class="remote"><a class="remote" href="http://www.debian.org/">Debian</a></span><a name="idx0019"></a> 
        families that contain GLIBC 2.3.2 or later (including 
        <span class="remote"><a class="remote" href="http://fedoraproject.org/">Fedora</a></span><a name="idx0020"></a>, 
        <span class="remote"><a class="remote" href="http://www.centos.org/">CentOS</a></span><a name="idx0021"></a> 
        3 or later, 
        <span class="remote"><a class="remote" href="http://www.oracle.com/us/technologies/linux/">Oracle 
        Linux</a></span><a name="idx0022"></a>, and 
        <span class="remote"><a class="remote" href="http://www.ubuntu.com/">Ubuntu 
        Linux</a></span><a name="idx0023"></a> v6.0 or later.) <br />
        <div class="important"><p class="important">
        If you wish to run both 32-bit and 64-bit OpenGL applications using VirtualGL on 64-bit Linux systems, you will need to install both the i386 and x86_64 VirtualGL RPMs or both the &ldquo;virtualgl&rdquo; and &ldquo;virtualgl32&rdquo; amd64 DEBs.  (The virtualgl32 DEB is a supplementary package that contains only the 32-bit server components.)
        </p></div>
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Log in as root, cd to the directory where you downloaded the binary 
        package, and issue the following commands:
        <dl class="Description">
            <dt class="Description-3 Description">RPM-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
rpm&nbsp;-i&nbsp;VirtualGL*.rpm
</pre>

            </dd>
            <dt class="Description-3 Description">Debian-based systems</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
dpkg&nbsp;-r&nbsp;virtualgl
dpkg&nbsp;-i&nbsp;virtualgl*.deb
</pre>

            </dd>
        </dl>
    </li>
</ol>



<h2 id="hd005002">5.2&nbsp;Installing the VirtualGL Client on OS X</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Download the VirtualGL Mac disk image 
        (<code>VirtualGL-</code><em><code>{version}</code></em><code>.dmg</code>) 
        from the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/">Files 
        area</a></span><a name="idx0024"></a> of the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl">VirtualGL 
        SourceForge project page</a></span><a name="idx0025"></a>.
    </li>
    <li class="Ordered-1 Ordered">
        Open the disk image, then open 
        <code>VirtualGL-</code><em><code>{version}</code></em><code>.pkg</code> 
        inside the disk image.  Follow the instructions to install the Mac 
        client.
    </li>
</ol>



<h2 id="hd005003">5.3&nbsp;Installing the VirtualGL Client on Windows (Exceed)</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Download the VirtualGL Client for Exceed installer package 
        (<code>VirtualGL[64]-</code><em><code>{version}</code></em><code>-exceed.exe</code>) 
        from the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/">Files 
        area</a></span><a name="idx0026"></a> of the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl">VirtualGL 
        SourceForge project page</a></span><a name="idx0027"></a>.
    </li>
    <li class="Ordered-1 Ordered">
        Run the installer.  The installation of the VirtualGL Client should be 
        self-explanatory.  The only configuration option is the directory into 
        which you want the files to be installed.
    </li>
</ol>
<div class="important"><p class="important">
NOTE: The VirtualGL Client for Exceed installer does not remove any previous versions of the VirtualGL Client that may be installed on your machine.  If you wish, you can remove these older versions manually by using the &ldquo;Add or Remove Programs&rdquo; applet in the Control Panel (or the &ldquo;Programs and Features&rdquo; applet if you are running Windows Vista.)
</p></div>



<h2 id="hd005004">5.4&nbsp;Installing the VirtualGL Client on Windows (Cygwin/X)</h2>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Make sure that the following Cygwin packages are installed:<br /><br /> 
        libGL<br /> libGLU<br /> libstdc++<br /> libX11<br /> libXext<br /> 
        openssh<br /> xorg-xserver<br /> xauth<br />
    </li>
    <li class="Ordered-1 Ordered">
        Download the VirtualGL Cygwin package 
        (<code>VirtualGL-</code><em><code>{version}</code></em><code>-cygwin.tar.bz2</code>) 
        from the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/">Files 
        area</a></span><a name="idx0028"></a> of the 
        <span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl">VirtualGL 
        SourceForge project page</a></span><a name="idx0029"></a>.
    </li>
    <li class="Ordered-1 Ordered">
        Run the Cygwin Setup application (the same application you used to 
        install Cygwin.)
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Choose a Download Source&rdquo; page, select 
        &ldquo;Install from Local Directory&rdquo;.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Root Install Directory&rdquo; page, use the same 
        options that you used when installing Cygwin.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Local Package Directory&rdquo; page, enter the 
        directory containing the VirtualGL Cygwin package.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Packages&rdquo; page, change &ldquo;View&rdquo; to 
        &ldquo;Partial&rdquo; and verify that the VirtualGL package with the 
        correct version is selected for install.  Click &ldquo;Next&gt;&rdquo; 
        to install.
    </li>
</ol>



<h2 id="hd005005">5.5&nbsp;Installing VirtualGL from Source</h2>

<p>If you are using a platform for which there is not a pre-built VirtualGL 
binary package available, then download the VirtualGL source tarball 
(<code>VirtualGL-</code><em><code>{version}</code></em><code>.tar.gz</code>) 
from the 
<span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl/files/VirtualGL/">Files 
area</a></span><a name="idx0030"></a> of the 
<span class="remote"><a class="remote" href="http://sourceforge.net/projects/virtualgl">VirtualGL 
SourceForge project page</a></span><a name="idx0031"></a>, uncompress 
it, <code>cd&nbsp;VirtualGL-</code><em><code>{version}</code></em>, and 
read the contents of <code>BUILDING.txt</code> for further instructions 
on how to build and install VirtualGL from source.</p>



<h2 id="hd005006">5.6&nbsp;Uninstalling VirtualGL</h2>


<h3 id="hd005006001">Linux</h3>

<p>As root, issue one of the following commands:</p>

<dl class="Description">
    <dt class="Description-1 Description">RPM-based systems</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
rpm&nbsp;-e&nbsp;VirtualGL
</pre>

    </dd>
    <dt class="Description-1 Description">Debian-based systems</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
dpkg&nbsp;-r&nbsp;virtualgl
</pre>

    </dd>
</dl>



<h3 id="hd005006002">OS X</h3>

<p>Use the &ldquo;Uninstall VirtualGL&rdquo; application provided in the 
VirtualGL disk image, or issue the following command from the Terminal:</p>

<pre class="verbatim">
sudo&nbsp;/opt/VirtualGL/bin/uninstall
</pre>



<h3 id="hd005006003">Windows (Exceed)</h3>

<p>Use the &ldquo;Programs and Features&rdquo; applet in the Control Panel 
(or the &ldquo;Add or Remove Programs&rdquo; applet if you are running 
Windows XP), or select &ldquo;Uninstall VirtualGL Client&rdquo; in the 
&ldquo;VirtualGL Client&rdquo; Start Menu group.</p>



<h3 id="hd005006004">Windows (Cygwin/X)</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Run the Cygwin Setup application (the same application you used to 
        install Cygwin.)
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Choose a Download Source&rdquo; page, select 
        &ldquo;Install from Local Directory&rdquo;.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Root Install Directory&rdquo; page, use the same 
        options that you used when installing Cygwin.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Local Package Directory&rdquo; page, enter the 
        directory containing the VirtualGL Cygwin package.
    </li>
    <li class="Ordered-1 Ordered">
        On the &ldquo;Select Packages&rdquo; page, change &ldquo;View&rdquo; to 
        &ldquo;Full&rdquo;, find the &ldquo;VirtualGL&rdquo; package in the 
        list, and change its status from &ldquo;Keep&rdquo; to 
        &ldquo;Uninstall&rdquo;.  Click &ldquo;Next&gt;&rdquo; to uninstall.
    </li>
</ol>

<p><br /></p>

<hr class="break" />



<h1 id="hd006"><a name="file006"></a>6&nbsp;Configuring a Linux or Unix Machine as a VirtualGL Server</h1>

<p><a name="Unix_Config"></a></p>


<h2 id="hd006001">6.1&nbsp;Granting Access to the 3D X Server</h2>

<p>VirtualGL requires access to the application server&rsquo;s 3D graphics 
card so that it can create off-screen pixel buffers (Pbuffers) and 
redirect the 3D rendering from applications into these Pbuffers.  
Unfortunately, accessing a 3D graphics card on Linux and Unix systems 
requires going through an X server.  On such systems, the only way to 
share the application server&rsquo;s 3D graphics card among multiple 
users is to grant those users access to the 3D X server (the X server 
attached to the application server&rsquo;s 3D graphics card. Refer to 
the figures in Chapter <a href="#Overview" class="ref">3</a>.)</p>

<p>It is important to understand the security risks associated with this.  
Once a user has access to the 3D X server, there is nothing that would 
prevent the user from logging keystrokes or reading back images from 
that X server. Using <code>xauth</code>, one can obtain 
&ldquo;untrusted&rdquo; X authentication keys that prevent such 
exploits, but unfortunately, those untrusted keys also disallow access 
to the 3D hardware.  Thus, it is necessary to grant full trusted access 
to the 3D X server for any users that will need to run VirtualGL.  
Unless you fully trust the users to whom you are granting this access, 
then you should avoid logging in locally to the 3D X server 
(particularly as root) unless absolutely necessary.</p>

<p>This section will explain how to configure a VirtualGL server such that 
selected users can run VirtualGL, even if the server is sitting at the 
login prompt.</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Shut down the display manager:
        <dl class="Description">
            <dt class="Description-3 Description">Ubuntu Linux servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/gdm&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">Ubuntu Linux servers running LightDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/lightdm&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">SuSE Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/xdm&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">Red Hat/Fedora Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
init&nbsp;3
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 10 servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 11/OpenSolaris servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;disable&nbsp;gdm
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris servers running dtlogin</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">FreeBSD servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/usr/local/etc/rc.d/gdm&nbsp;stop
</pre>

            </dd>
            <dt class="Description-3 Description">FreeBSD servers running KDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/usr/local/kde4/etc/rc.d/kdm4&nbsp;stop
</pre>

            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">
        Log in as root from the text console (or remotely using SSH.)
    </li>
    <li class="Ordered-1 Ordered">
        Run
<pre class="verbatim">
/opt/VirtualGL/bin/vglserver_config
</pre>

    </li>
    <li class="Ordered-1 Ordered">
        Select option 1 
        (<code>Configure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>.)
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Restrict&nbsp;3D&nbsp;X&nbsp;server&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Only users in the <code>vglusers</code> group can use VirtualGL (the 
                configuration script will create the <code>vglusers</code> group if it 
                doesn&rsquo;t already exist.)  This is the most secure option, since it 
                prevents any users outside of the <code>vglusers</code> group from 
                accessing (and thus exploiting) the 3D X server.
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                VirtualGL can be used by any user that successfully logs into the 
                VirtualGL server.  The 3D X server can also be accessed (and potentially 
                exploited) by any user who is logged into the VirtualGL server.  If you 
                choose this option, it is recommended that you also disable the XTEST 
                extension (see below.)
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Restrict&nbsp;framebuffer&nbsp;device&nbsp;access&nbsp;to&nbsp;vglusers&nbsp;group&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Only users in the <code>vglusers</code> group can run OpenGL 
                applications on the VirtualGL server (the configuration script will 
                create the <code>vglusers</code> group if it doesn&rsquo;t already 
                exist.)  This limits the possibility that an unauthorized user could 
                snoop the 3D framebuffer device(s) and thus see (or alter) the output of 
                a 3D application that is being used with VirtualGL.
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                Any authenticated user can run OpenGL applications on the VirtualGL 
                server.  If it is necessary for users outside of the 
                <code>vglusers</code> group to log in locally to this server and run 
                OpenGL applications, then this option must be selected.
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">

<pre class="verbatim">
Disable&nbsp;XTEST&nbsp;extension&nbsp;(recommended)?
[Y/n]
</pre>

        <dl class="Description">
            <dt class="Description-3 Description">Yes</dt>
            <dd class="Description-3 Description">
                Disabling XTEST will not prevent a user from logging keystrokes or 
                reading images from the 3D X server, but if a user has access to the 3D 
                X server, disabling XTEST will prevent them from inserting keystrokes or 
                mouse events and thus hijacking local X sessions on that X server.
                <div class="important"><p class="important">
                Certain Linux distributions do not have the X server command-line entries in their GDM configuration files.  On these distributions, it will be necessary to run <code>gdmsetup</code> and manually add an argument of <code>-tst</code> to the X server command line to disable XTEST for the first time.  After this, <code>vglserver_config</code> should be able to disable and enable XTEST properly.  This is known to be necessary for openSUSE 10 and Red Hat Enterprise Linux 5.
                </p></div>
            </dd>
            <dt class="Description-3 Description">No</dt>
            <dd class="Description-3 Description">
                <code>x11vnc</code> and <code>x0vncserver</code> both require XTEST, so 
                if you need to attach a VNC server to the 3D X server, then it is 
                necessary to answer &ldquo;No&rdquo; (and thus leave XTEST enabled.)
            </dd>
        </dl>
    </li>
    <li class="Ordered-1 Ordered">
        If you chose to restrict X server or framebuffer device access to the 
        <code>vglusers</code> group, then edit <code>/etc/group</code> and add 
        <code>root</code> to the <code>vglusers</code> group.  If you choose, 
        you can also add additional users to the group at this time.  Note that 
        any user you add to <code>vglusers</code>	must log out and back in again 
        before their new group permissions will take effect.
    </li>
    <li class="Ordered-1 Ordered">
        Restart the display manager:
        <dl class="Description">
            <dt class="Description-3 Description">Ubuntu Linux servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/gdm&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">Ubuntu Linux servers running LightDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/lightdm&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">SuSE Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/xdm&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">Red Hat/Fedora Linux servers</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
init&nbsp;5
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 10 servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm2-login
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris 11/OpenSolaris servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
svcadm&nbsp;enable&nbsp;gdm
</pre>

            </dd>
            <dt class="Description-3 Description">Solaris servers running dtlogin</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/etc/init.d/dtlogin&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">FreeBSD servers running GDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/usr/local/etc/rc.d/gdm&nbsp;start
</pre>

            </dd>
            <dt class="Description-3 Description">FreeBSD servers running KDM</dt>
            <dd class="Description-3 Description">
<pre class="verbatim">
/usr/local/kde4/etc/rc.d/kdm4&nbsp;start
</pre>

            </dd>
        </dl>
    </li>
</ol>


<h3 id="hd006001001">Sanity Check</h3>

<p>To verify that the application server is ready to run VirtualGL, log out 
of the server, log back into the server using SSH, and execute the 
following commands in the SSH session:</p>

<dl class="Description">
    <dt class="Description-1 Description">If you restricted 3D X server access to <code>vglusers</code></dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c
</pre>

        <div class="important"><p class="important">
        NOTE: <code>xauth</code> and <code>xdpyinfo</code> are in <code>/usr/openwin/bin</code> on Solaris systems.
        </p></div>
    </dd>
    <dt class="Description-1 Description">If you did not restrict 3D X server access</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
xdpyinfo&nbsp;-display&nbsp;:0
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:0&nbsp;-c
</pre>

    </dd>
</dl>

<p>Both commands should output a list of visuals and should complete with 
no errors.  If you chose to disable the XTEST extension, then check the 
output of <code>xdpyinfo</code> to verify that <code>XTEST</code> does 
not show up in the list of extensions.</p>

<p>You should also examine the output of <code>glxinfo</code> to ensure 
that at least one of the visuals is 24-bit or 32-bit TrueColor and has 
Pbuffer support (the latter is indicated by a &ldquo;P&rdquo; in the 
last column.)  Example:</p>

<pre class="verbatim">
&nbsp;&nbsp;&nbsp;&nbsp;visual&nbsp;&nbsp;x&nbsp;&nbsp;bf&nbsp;lv&nbsp;rg&nbsp;d&nbsp;st&nbsp;colorbuffer&nbsp;ax&nbsp;dp&nbsp;st&nbsp;accumbuffer&nbsp;&nbsp;ms&nbsp;&nbsp;cav&nbsp;&nbsp;drw
&nbsp;&nbsp;id&nbsp;dep&nbsp;cl&nbsp;sp&nbsp;sz&nbsp;l&nbsp;&nbsp;ci&nbsp;b&nbsp;ro&nbsp;&nbsp;r&nbsp;&nbsp;g&nbsp;&nbsp;b&nbsp;&nbsp;a&nbsp;bf&nbsp;th&nbsp;cl&nbsp;&nbsp;r&nbsp;&nbsp;g&nbsp;&nbsp;b&nbsp;&nbsp;a&nbsp;ns&nbsp;b&nbsp;eat&nbsp;&nbsp;typ
---------------------------------------------------------------------------
0x151&nbsp;&nbsp;0&nbsp;tc&nbsp;&nbsp;0&nbsp;32&nbsp;&nbsp;0&nbsp;r&nbsp;&nbsp;y&nbsp;&nbsp;.&nbsp;&nbsp;8&nbsp;&nbsp;8&nbsp;&nbsp;8&nbsp;&nbsp;0&nbsp;&nbsp;4&nbsp;24&nbsp;&nbsp;8&nbsp;16&nbsp;16&nbsp;16&nbsp;16&nbsp;&nbsp;0&nbsp;0&nbsp;None&nbsp;PXW
</pre>

<p>If none of the visuals has Pbuffer support, then this is most likely 
because there is no 3D acceleration, which is most likely because the 
correct 3D drivers are not installed (or are misconfigured.)  Lack of 3D 
acceleration is also typically indicated by the word &ldquo;Mesa&rdquo; 
in the client GLX vendor string and/or the OpenGL vendor string, and the 
words &ldquo;Software Rasterizer&rdquo; in the OpenGL renderer string.</p>



<h2 id="hd006002">6.2&nbsp;Using VirtualGL with Multiple Graphics Cards</h2>

<p>VirtualGL can redirect the OpenGL commands from a 3D application to any 
3D graphics card in the server machine.  In order for this to work, 
however, all of the 3D graphics cards must be attached to different 
screens on the same X server.  They can then be individually addressed 
by setting <code>VGL_DISPLAY</code> to (or invoking 
<code>vglrun&nbsp;-d</code> with) <code>:0.0</code>, <code>:0.1</code>, 
<code>:0.2</code>, etc.</p>



<h2 id="hd006003">6.3&nbsp;SSH Server Configuration</h2>

<p>The application server&rsquo;s SSH daemon should have the 
<code>X11Forwarding</code> option enabled and the <code>UseLogin</code> 
option disabled.  This is configured in <code>sshd_config</code>, which 
is usually located under <code>/etc/ssh</code>.</p>



<h2 id="hd006004">6.4&nbsp;Un-Configuring the Server</h2>

<p>You can use the <code>vglserver_config</code> script to restore the 
security settings that were in place before VirtualGL was installed.  
Option 2 
(<code>Unconfigure&nbsp;server&nbsp;for&nbsp;use&nbsp;with&nbsp;VirtualGL&nbsp;in&nbsp;GLX&nbsp;mode</code>) 
will remove any shared access to the 3D X server and thus prevent 
VirtualGL from accessing the 3D hardware in that manner.  Additionally, 
this option will re-enable the XTEST extension on the 3D X server and 
will restore the framebuffer device permissions to their default (by 
default, only root or the user that is currently logged into the 
application server locally can access the framebuffer devices.)</p>

<div class="important"><p class="important">
NOTE: Unconfiguring the server does not remove the <code>vglusers</code> group.
</p></div>

<p>After selecting Option 2, you must restart the display manager before 
the changes will take effect.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd007"><a name="file007"></a>7&nbsp;Configuring a Windows Machine as a VGL Transport Client</h1>


<h2 id="hd007001">7.1&nbsp;Configuring and Optimizing Exceed</h2>

<p>If using the VirtualGL Client for Exceed, then add the Exceed path 
(example: 
<code>C:\Program&nbsp;Files\Hummingbird\Connectivity\14.00\Exceed</code>) 
to the system <code>PATH</code> environment if it isn&rsquo;t already 
there.</p>


<h3 id="hd007001001">Disabling Pixel Format Conversion (Exceed 2006 and earlier)</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        In the &ldquo;X Server Protocol&rdquo; applet, select the 
        &ldquo;Protocol&rdquo; tab and make sure that &ldquo;Use 32 bits per 
        pixel for true color&rdquo; is not checked. <br /><br /> 
        <img src="exceed1.png" alt="exceed1" class="inline" id="imgid_1" name="imgid_1"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>



<h3 id="hd007001002">Disabling Backing Store (Exceed 2008 and earlier)</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;Other Server Settings&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Performance&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Select the &ldquo;Performance&rdquo; tab and make sure that 
        &ldquo;Default Backing Store&rdquo; is set to &ldquo;None.&rdquo; 
        <br /><br /> 
        <img src="exceed3.png" alt="exceed3" class="inline" id="imgid_2" name="imgid_2"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>



<h3 id="hd007001003">Enabling MIT-SHM</h3>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension in 
OpenText Exceed to accelerate image drawing on Windows.  This can 
significantly improve the overall performance of the VirtualGL pipeline 
when running over a local-area network.</p>

<p>The bad news is that this extension is not consistently implemented 
across all versions of Exceed.  In particular, Exceed 8, Exceed 9, and 
Exceed 2008 require patches to make it work properly.  If you are using 
one of these versions of Exceed, you will need to obtain the following 
patches from the OpenText support site:</p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Product</th>
    <th class="head standard">Patches Required</th>
    <th class="head standard">How to Obtain</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Exceed 8.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v8.0.0.28 (or higher)</td>
    <td class="standard">Download all patches from the <span class="remote"><a class="remote" href="http://support.hummingbird.com/customer/cspatches/patches.asp">OpenText support site</a></span><a name="idx0032"></a>. <br /> (<em>OpenText WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Exceed 9.0</td>
    <td class="standard"><code>hclshm.dll</code> v9.0.0.1 (or higher)<br /> <code>xlib.dll</code> v9.0.0.3 (or higher)<br /> <code>exceed.exe</code> v9.0.0.9 (or higher)</td>
    <td class="standard"><code>exceed.exe</code> can be patched by running Hummingbird Update.<br /> <br /> All other patches must be downloaded from the <span class="remote"><a class="remote" href="http://support.hummingbird.com/customer/cspatches/patches.asp">OpenText support site</a></span><a name="idx0033"></a>. <br /> (<em>OpenText WebSupport account required</em>)</td>
  </tr>
  <tr class="standard">
    <td class="standard">Exceed 2008</td>
    <td class="standard"><code>xlib.dll</code> v13.0.1.235 (or higher)<br /> (or install the latest <span class="remote"><a class="remote" href="http://support.hummingbird.com/customer/cspatches/patches.asp">Connectivity 2008 Service Pack</a></span><a name="idx0034"></a>.)</td>
    <td class="standard">Download all patches from the <span class="remote"><a class="remote" href="http://support.hummingbird.com/customer/cspatches/patches.asp">OpenText support site</a></span><a name="idx0035"></a>. <br /> (<em>OpenText WebSupport account required</em>)</td>
  </tr>
</table>
</div>


<p>No patches should be necessary for Exceed 10, 2006, 2007, or 14.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Load Exceed XConfig (right-click on the Exceed taskbar icon, then select 
        <em>Tools&ndash;&gt;Configuration</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        Open the &ldquo;X Server Protocol&rdquo; applet in XConfig.
        <div class="important"><p class="important">
        If you are using the &ldquo;Classic View&rdquo; mode of XConfig, open the &ldquo;Protocol&rdquo; applet instead.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Select the &ldquo;Extensions&rdquo; tab and make sure that 
        &ldquo;MIT-SHM&rdquo; is checked. <br /><br /> 
        <img src="exceed2.png" alt="exceed2" class="inline" id="imgid_3" name="imgid_3"/>
    </li>
    <li class="Ordered-1 Ordered">
        Click &ldquo;Validate and Apply Changes.&rdquo;  If XConfig asks whether 
        you want to perform a server reset, click &ldquo;Yes.&rdquo;
    </li>
</ol>



<h2 id="hd007002">7.2&nbsp;Optimizing Cygwin/X</h2>

<p>VirtualGL has the ability to take advantage of the MIT-SHM extension in 
Cygwin/X to accelerate image drawing on Windows.  This can significantly 
improve the overall performance of the VirtualGL pipeline when running 
over a local-area network.</p>

<p>To enable MIT-SHM in Cygwin/X:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Open a Cygwin Bash shell
    </li>
    <li class="Ordered-1 Ordered">
        Run <code>cygserver-config</code>
    </li>
    <li class="Ordered-1 Ordered">
        Answer &ldquo;yes&rdquo; when asked &ldquo;Do you want to install 
        cygserver as service?&rdquo;
    </li>
    <li class="Ordered-1 Ordered">
        Run <code>net&nbsp;start&nbsp;cygserver</code>
    </li>
    <li class="Ordered-1 Ordered">
        Add <code>server</code> to the <code>CYGWIN</code> system environment 
        variable (create this environment variable if it doesn&rsquo;t already 
        exist)
    </li>
    <li class="Ordered-1 Ordered">
        Start or re-start Cygwin/X
    </li>
    <li class="Ordered-1 Ordered">
        Run <code>xdpyinfo</code> and verify that <code>MIT-SHM</code> appears 
        in the list of  X extensions
    </li>
</ol>

<p><br /></p>

<hr class="break" />



<h1 id="hd008"><a name="file008"></a>8&nbsp;Using VirtualGL with the VGL Transport</h1>

<p><a name="VGL_Transport_Usage"></a></p>


<h3 id="hd008000001">Advantages of the VGL Transport</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        Seamless windows; every application window appears as a separate window 
        on the user&rsquo;s desktop
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Supports stereographic rendering (see requirements in Sections 
        <a href="#Stereo_Requirements" class="ref">4.4</a> and 
        <a href="#Overlay_Requirements" class="ref">4.5</a>)
    </li>
    <li class="Itemize-1 Itemize asterisk">
        Consumes fewer server resources, since the 2D (X11) rendering occurs on 
        the client machine
    </li>
</ul>



<h3 id="hd008000002">Disadvantages of the VGL Transport</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        The VGL Transport is designed to be used with remote X servers, and thus 
        it relies on the chatty remote X11 protocol to send the 2D elements of 
        the application&rsquo;s GUI to the user&rsquo;s desktop.  As a result, 
        the VGL Transport is not recommended for use on high-latency or 
        low-bandwidth networks
    </li>
    <li class="Itemize-1 Itemize asterisk">
        No collaboration features
    </li>
    <li class="Itemize-1 Itemize asterisk">
        The client is not stateless.  As with any remote X11 app, if the network 
        connection drops, then the application will exit
    </li>
</ul>



<h2 id="hd008001">8.1&nbsp;VGL Transport with X11 Forwarding</h2>

<p><a name="X11_Forwarding"></a></p>

<p>This mode is recommended for use on secure local-area networks.  The X11 
traffic is encrypted, but the VGL Transport is left unencrypted to 
maximize performance.</p>


<h3 id="hd008001001">Procedure for Linux/Unix/Mac/Cygwin Clients</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the X server if it isn&rsquo;t started already.<br /> <em>Mac 
        clients:</em> start the Mac X11 application.<br /> <em>Cygwin 
        clients:</em> start Cygwin/X.
    </li>
    <li class="Ordered-1 Ordered">
        Open a new terminal window.<br /> <em>Mac clients:</em> in the X11 
        application, start a new xterm [Command-N] if one isn&rsquo;t already 
        started.<br /> <em>Cygwin clients:</em> start a new xterm if one 
        isn&rsquo;t already started (right-click on the Cygwin/X taskbar icon, 
        then select <em>Applications&ndash;&gt;xterm</em>.)
    </li>
    <li class="Ordered-1 Ordered">
        In the same terminal/xterm window, open a Secure Shell (SSH) session 
        into the VirtualGL server:
<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on the 
        VirtualGL server and <em><code>{server}</code></em> with the hostname or 
        IP address of that server.
    </li>
    <li class="Ordered-1 Ordered">
        In the SSH session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">20</a> for 
        more information on <code>vglrun</code> command-line options.
    </li>
</ol>



<h3 id="hd008001002">Procedure for Windows Clients Running Exceed</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start Exceed if it isn&rsquo;t already started.  Hover the mouse pointer 
        over the Exceed taskbar icon and make a note of the display number on 
        which Exceed is listening (<em>Example:</em> &ldquo;Exceed 0.0 
        Multiwindow Mode&rdquo;.)
    </li>
    <li class="Ordered-1 Ordered">
        Open a new Command Prompt.
    </li>
    <li class="Ordered-1 Ordered">
        In the same Command Prompt window, set the <code>DISPLAY</code> 
        environment variable to match the display on which Exceed is listening.  
        Example:
<pre class="verbatim">
set&nbsp;DISPLAY=:0.0
</pre>

        <div class="important"><p class="important">
        If you only ever plan to use one Exceed session at a time, then you can set the <code>DISPLAY</code> environment variable in your user environment, which is configured through the Windows Control Panel.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        Open a Secure Shell (SSH) session into the VirtualGL server:
<pre class="verbatim">
cd&nbsp;/d&nbsp;&quot;c:\program&nbsp;files\virtualgl-{version}-{build}&quot;
vglconnect&nbsp;{user}@{server}
</pre>

        Replace <em><code>{user}</code></em> with your user account name on the 
        VirtualGL server and <em><code>{server}</code></em> with the hostname or 
        IP address of that server.
    </li>
    <li class="Ordered-1 Ordered">
        In the SSH session, start a 3D application using VirtualGL:
<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;[vglrun&nbsp;options]&nbsp;{application_executable_or_script}&nbsp;{arguments}
</pre>

        Consult Chapter <a href="#Advanced_Configuration" class="ref">20</a> for 
        more information on <code>vglrun</code> command-line options.
    </li>
</ol>



<h2 id="hd008002">8.2&nbsp;VGL Transport with a Direct X11 Connection</h2>

<p><a name="Direct_X11_Connection"></a></p>

<p>As with the previous mode, this mode performs optimally on local-area 
networks.  However, it is less secure, since both the X11 traffic and 
the VGL Transport are unencrypted.  This mode is primarily useful in 
grid environments, in which you may not know ahead of time which server 
will execute a VirtualGL job.  It is assumed that the &ldquo;submit 
host&rdquo; (the machine into which you connect with SSH) and the 
&ldquo;execute hosts&rdquo; (the machines that will run VirtualGL jobs) 
share the same home directories and reside in the same domain.</p>

<div class="important"><p class="important">
Some newer Linux and Unix distributions ship with default settings that do not allow TCP connections into the X server.  Such systems cannot be used as clients with this procedure unless they are reconfigured to allow X11 TCP connections.
</p></div>


<h3 id="hd008002001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for 
<a href="#X11_Forwarding">X11 forwarding</a><a name="idx0036"></a>, 
except that you should pass a <code>-x</code> argument to 
<code>vglconnect</code> when connecting to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-x&nbsp;{user}@{server}
</pre>



<h2 id="hd008003">8.3&nbsp;VGL Transport with X11 Forwarding and SSH Tunneling</h2>

<p><a name="SSH_Tunneling"></a></p>

<p>Both the VGL Transport and the X11 traffic are tunneled through SSH when 
using this mode, and thus it provides a completely secure solution.  It 
is also useful when either the VirtualGL server or the client machine 
are behind restrictive firewalls and only SSH connections are allowed 
through.  Using SSH tunneling on wide-area networks should not affect 
performance significantly.  However, using SSH tunneling on a local-area 
network can reduce VirtualGL&rsquo;s performance by anywhere from 20-40%.</p>


<h3 id="hd008003001">Procedure</h3>

<p>The procedure for this mode is identical to the procedure for 
<a href="#X11_Forwarding">X11 forwarding</a><a name="idx0037"></a>, 
except that you should pass a <code>-s</code> argument to 
<code>vglconnect</code> when connecting to the server:</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglconnect&nbsp;-s&nbsp;{user}@{server}
</pre>

<p><code>vglconnect</code> will make two SSH connections into the server, 
the first to find an open port on the server and the second to create 
the SSH tunnel for the VGL Transport and open the secure shell.  If you 
are not using an SSH agent to create password-less logins, then this 
mode will require you to enter your password twice.</p>

<p><code>vglconnect&nbsp;-s</code> can be used to create multi-layered SSH 
tunnels.  For instance, if the VirtualGL server is not directly 
accessible from the Internet, you can use 
<code>vglconnect&nbsp;-s</code> to connect to a gateway server, then use 
<code>vglconnect&nbsp;-s</code> again on the gateway server to connect 
to the VirtualGL server.  Both the X11 traffic and the VGL Transport 
will be forwarded from the VirtualGL server through the gateway and to 
the client.</p>

<div class="figure">
<img src="sshtunnel.png" alt="sshtunnel" class="figure" id="imgid_11" name="imgid_11"/>
</div>



<h2 id="hd008004">8.4&nbsp;VGL Transport over Gigabit Networks</h2>

<p>When using the VGL Transport over Gigabit Ethernet or faster networks, 
it may be desirable to disable image compression.  This can be 
accomplished by passing an argument of <code>-c&nbsp;rgb</code> to 
<code>vglrun</code> or setting the <code>VGL_COMPRESS</code> environment 
variable to <code>rgb</code> on the VirtualGL server.  Disabling image 
compression will reduce VirtualGL&rsquo;s server and client CPU usage by 
50% or more, but the tradeoff is that it will also increase 
VirtualGL&rsquo;s network usage by a factor of 10 or more.  Thus, 
disabling image compression is not recommended unless you are using 
switched Gigabit Ethernet (or faster) infrastructure and have plenty of 
bandwidth to spare.</p>



<h2 id="hd008005">8.5&nbsp;VGL Transport with XDMCP</h2>

<div class="important"><p class="important">
XDMCP is very insecure and is not recommended as a means of running VirtualGL, in general.  This section is provided mainly for completeness and should not be construed as an endorsement of XDMCP.  In general, using an X proxy is a much better approach for getting a remote desktop session on the 3D application server.
</p></div>

<p>Using the VGL Transport with XDMCP is conceptually similar to using the 
VGL Transport with a <a href="#Direct_X11_Connection">direct X11 
connection</a><a name="idx0038"></a>.  The major difference is that, 
rather than remotely displaying individual X windows to the 2D X server, 
XDMCP remotely displays a complete desktop session from the application 
server. Any applications that are started within this desktop session 
will run on the application server, not the client.  Thus, 
<code>vglconnect</code> cannot be used in this case.  Instead, it is 
necessary to start <code>vglclient</code> manually on the client machine.</p>


<h3 id="hd008005001">Procedure</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Configure the server machine to accept XDMCP connections.  This may 
        require opening specific ports in its firewall.
    </li>
    <li class="Ordered-1 Ordered">
        Configure the client machine to make XDMCP connections.  This may 
        require enabling X11 TCP connections and opening specific ports in its 
        firewall.
    </li>
    <li class="Ordered-1 Ordered">
        Once you have established an XDMCP connection from the client to the 
        server, open a terminal inside the XDMCP session and type:
<pre class="verbatim">
xhost&nbsp;+LOCAL:
</pre>

        <div class="important"><p class="important">
        This grants access to the 2D X server for any user that is currently logged into the client machine.  This is not very secure, but neither is using XDMCP.  If you are concerned, then see below for a discussion of how to use <code>xauth</code> to provide 2D X server access in a slightly more secure manner.
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        If you are using a Mac or Windows client, or if you are using a nested X 
        server (such as Xephyr or XNest) on a Linux/Unix client to make the 
        XDMCP connection, then the next step is easy.  Simply open a new 
        terminal/command prompt on the client machine, set the 
        <code>DISPLAY</code> environment variable to the display name of the X 
        server that is running the XDMCP session (usually <code>:0</code> or 
        <code>:1</code>), and type:
<pre class="verbatim">
vglclient&nbsp;-detach
</pre>

        You can now close the terminal/command prompt, if you wish.
    </li>
    <li class="Ordered-1 Ordered">
        If you are running a full-screen XDMCP session on a Linux/Unix client 
        (for instance, using GDM Chooser), then starting <code>vglclient</code> 
        is a bit trickier.  You will need to use SSH to connect back into the 
        client machine from inside the XDMCP session.  Then, in the client SSH 
        session, set the <code>DISPLAY</code> environment variable to the 
        display name of the X server that is running the XDMCP session (usually 
        <code>:0</code> or <code>:1</code>), and type:
<pre class="verbatim">
vglclient&nbsp;-detach
</pre>

        You can now close the SSH session, if you wish.
    </li>
</ol>



<h3 id="hd008005002">Security</h3>

<p>Typing <code>xhost&nbsp;+LOCAL:</code> in step 3 above opens the 2D X 
server to all current users of the client machine.  This shouldn&rsquo;t 
pose any significant risk if the client is a Windows or a Mac machine.  
However, Linux/Unix clients might have multiple simultaneous users, so 
in these cases, it may be desirable to use a more secure method of 
granting access to the 2D X server.</p>

<p>Instead of typing <code>xhost&nbsp;+LOCAL:</code>, you can type the 
following:</p>

<pre class="verbatim">
xauth&nbsp;nextract&nbsp;-&nbsp;$DISPLAY&nbsp;|&nbsp;sed&nbsp;&quot;s/.*[&nbsp;]//g&quot;&nbsp;|&nbsp;xargs&nbsp;ssh&nbsp;{client}&nbsp;xauth&nbsp;add&nbsp;{display}&nbsp;.
</pre>

<p>where <em><code>{client}</code></em> is the hostname or IP address of 
the client machine and <em><code>{display}</code></em> is the display 
name of the 2D X server, from the point of view of the client machine 
(usually <code>:0</code> or <code>:1</code>).</p>

<p>This extracts the XAuth key for the 2D X server, then remotely adds it 
to the XAuth keyring on the client machine.</p>



<h2 id="hd008006">8.6&nbsp;The VirtualGL Client Application: Nuts and Bolts</h2>

<p>The VirtualGL Client application (<code>vglclient</code>) receives 
encoded and/or compressed images on a dedicated TCP socket, decodes 
and/or decompresses the images, and draws the images into the 
appropriate X window.  The <code>vglconnect</code> script wraps both 
<code>vglclient</code> and SSH to greatly simplify the process of 
creating VGL Transport connections.</p>

<p><code>vglconnect</code> invokes <code>vglclient</code> with an argument 
of <code>-detach</code>, which causes <code>vglclient</code> to 
completely detach from the console and run as a background daemon.  It 
will remain running silently in the background, accepting VGL Transport 
connections for the X server on which it was started, until that X 
server is reset or until the <code>vglclient</code> process is 
explicitly killed.  Logging out of the X server will reset the X server 
and thus kill all <code>vglclient</code> instances that are attached to 
it.  You can also explicitly kill all instances of 
<code>vglclient</code> running under your user account by invoking</p>

<pre class="verbatim">
vglclient&nbsp;-kill
</pre>

<p>(<code>vglclient</code> for Linux/Unix/Mac/Cygwin installs in 
<code>/opt/VirtualGL/bin</code> by default, and <code>vglclient</code> 
for Exceed is in 
<code>c:\program&nbsp;files\virtualgl-</code><em><code>{version}</code></em><code>-</code><em><code>{build}</code></em>.)</p>

<p><code>vglconnect</code> instructs <code>vglclient</code> to redirect all 
of its console output to a log file named 
<em><code>{home}</code></em><code>/.vgl/vglconnect-</code><em><code>{hostname}</code></em><code>-</code><em><code>{display}</code></em><code>.log</code>, 
where <em><code>{home}</code></em> is the path of the current 
user&rsquo;s home directory (<code>%USERPROFILE%</code> if using the 
VirtualGL Client for Exceed), <em><code>{hostname}</code></em> is the 
name of the computer running <code>vglconnect</code>, and 
<em><code>{display}</code></em> is the name of the current X display 
(read from the <code>DISPLAY</code> environment or passed to 
<code>vglconnect</code> using the <code>-display</code> argument.)  In 
the event that something goes wrong, this log file is the first place to 
check.</p>

<p>When <code>vglclient</code> successfully starts on a given X display, it 
stores its listener port number in a root window property on the X 
display.  If other <code>vglclient</code> instances attempt to start on 
the same X display, they read the X window property, determine that 
another <code>vglclient</code> instance is already running, and exit to 
allow the first instance to retain control. <code>vglclient</code> will 
clean up the X property under most circumstances, even if it is 
explicitly killed.  However, under rare circumstances (if sent a SIGKILL 
signal on Unix, for instance), a <code>vglclient</code> instance may 
exit uncleanly and leave the X property set.  In these cases, it may be 
necessary to add an argument of <code>-force</code> to 
<code>vglconnect</code> the next time you use it. This tells 
<code>vglconnect</code> to start a new <code>vglclient</code> instance, 
regardless of whether <code>vglclient</code> thinks that there is 
already an instance running on this X display.  Alternately, you can 
simply reset your X server to clear the orphaned X window property.</p>


<h3 id="hd008006001">8.6.1&nbsp;The VirtualGL Client and Firewalls</h3>

<p>To retain compatibility with previous versions of VirtualGL, the first 
<code>vglclient</code> instance on a given machine will attempt to 
listen on port 4242 for unencrypted connections and 4243 for SSL 
connections (if VirtualGL was built with OpenSSL support.)  If it fails 
to obtain one of those ports, because another application or another 
<code>vglclient</code> instance is already using them, then 
<code>vglclient</code> will try to obtain a free port in the range of 
4200-4299. Failing that, it will request a free port from the operating 
system.</p>

<p>In a nutshell: if you only ever plan to run one X server at a time on 
your client machine, which means that you&rsquo;ll only ever need one 
instance of <code>vglclient</code> at a time, then it is sufficient to 
open inbound port 4242 (and 4243 if you plan to use SSL) in your client 
machine&rsquo;s firewall.  If you plan to run multiple X servers on your 
client machine, which means that you will need to run multiple 
<code>vglclient</code> instances, then you may wish to open ports 
4200-4299.  Similarly, if you are running <code>vglclient</code> on a 
multi-user X proxy server that has a firewall, then you may wish to open 
ports 4200-4299 in the server&rsquo;s firewall.  Opening ports 4200-4299 
will accommodate up to 100 separate <code>vglclient</code> instances (50 
if OpenSSL support is enabled.)  More instances than that cannot be 
accommodated on a firewalled machine, unless the firewall is able to 
create rules based on application executables instead of listening ports.</p>

<p>Note that it is not necessary to open any inbound ports in the firewall 
to use the VGL Transport with <a href="#SSH_Tunneling">SSH 
Tunneling</a><a name="idx0039"></a>.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd009"><a name="file009"></a>9&nbsp;Using VirtualGL with X Proxies Such as VNC</h1>

<p><a name="X11_Proxy_Usage"></a></p>

<p>The VGL Transport is a good solution for using VirtualGL over a fast 
network.  However, the VGL Transport is not generally suitable for 
high-latency or low-bandwidth networks, due to its reliance on the X11 
protocol to send the non-3D elements of the 3D application&rsquo;s GUI.  
The VGL Transport also requires an X server to be running on the client 
machine, which makes it generally more difficult to deploy and use, 
particularly on Windows clients. VirtualGL can be used with an &ldquo;X 
proxy&rdquo; to overcome these limitations.  An X proxy acts as a 
virtual X server, receiving X11 commands from the application (and from 
VirtualGL), rendering the X11 commands into images, compressing the 
resulting images, and sending the compressed images over the network to 
a client or clients.  X proxies perform well on all types of networks, 
including high-latency and low-bandwidth networks.  They often provide 
rudimentary collaboration capabilities, allowing multiple clients to 
simultaneously view the same X session and pass around control of the 
keyboard and mouse.  X proxies are also stateless, meaning that the 
client can disconnect and reconnect at will from any machine on the 
network, and the 3D application will remain running on the server.</p>

<p>Since VirtualGL is sending rendered 3D images to the X proxy at a very 
fast rate, the proxy must be able to compress the images very quickly in 
order to keep up.  Unfortunately, however, most X proxies can&rsquo;t.  
They simply aren&rsquo;t designed to compress, with any degree of 
performance, the large and complex images generated by 3D applications.  
Therefore, the VirtualGL Project provides an optimized X proxy called 
&ldquo;TurboVNC&rdquo;, a variant of 
<span class="remote"><a class="remote" href="http://www.tightvnc.com">TightVNC</a></span><a name="idx0040"></a> 
that is designed specifically to achieve high levels of performance with 
3D applications running in VirtualGL.  More information about TurboVNC, 
including instructions for using it with VirtualGL, can be found in the 
TurboVNC User&rsquo;s Guide.</p>

<p><span class="remote"><a class="remote" href="http://www.tigervnc.com">TigerVNC</a></span><a name="idx0041"></a> 
is a next-generation VNC project based on the RealVNC and Xorg code 
bases.  TigerVNC spun off from the TightVNC project in early 2009, and 
it uses the same high-speed JPEG codec as VirtualGL and TurboVNC 
(<span class="remote"><a class="remote" href="http://libjpeg-turbo.virtualgl.org">libjpeg-turbo</a></span><a name="idx0042"></a>.)  
Unlike TurboVNC, TigerVNC is not specifically designed for 3D 
applications. However, TigerVNC can, if properly configured, produce 
performance that is sufficient for using VirtualGL.  TigerVNC is 
available in Fedora 11 or later.</p>

<p>Other solutions, such as RealVNC and NX, also work well with VirtualGL. 
Generally, none of these other solutions will provide anywhere near the 
performance of TurboVNC, but some of them have capabilities that 
TurboVNC lacks (NX, for instance, can do seamless windows.)</p>


<h2 id="hd009001">9.1&nbsp;Using VirtualGL with an X Proxy on the Same Server</h2>

<p><a name="X11_Proxy_Usage_Local"></a></p>

<p>The most common (and optimal) way to use VirtualGL with an X proxy is to 
set up both on the same server.  This allows VirtualGL to send its 
rendered 3D images to the X proxy through shared memory rather than 
sending them over a network.</p>

<div class="figure">
<img src="x11transport.png" alt="x11transport" class="figure" id="imgid_12" name="imgid_12"/>
</div>

<p>With this configuration, you can usually invoke</p>

<pre class="verbatim">
/opt/VirtualGL/bin/vglrun&nbsp;{application_executable_or_script}
</pre>

<p>from within an X proxy session, and it will &ldquo;just work.&rdquo;  
VirtualGL reads the value of the <code>DISPLAY</code> environment 
variable to determine whether to enable the X11 Transport by default.  
If <code>DISPLAY</code> begins with a colon 
(&ldquo;<code>:</code>&rdquo;) or with &ldquo;<code>unix:</code>&rdquo;, 
then VirtualGL will assume that the X server connection is local and 
will enable the X11 Transport as the default.  In some cases, however, 
the <code>DISPLAY</code> environment variable within the X proxy may not 
begin with a colon or &ldquo;<code>unix:</code>&rdquo;.  In these cases, 
it is necessary to manually enable the X11 Transport by setting the 
<code>VGL_COMPRESS</code> environment variable to <code>proxy</code> or 
by passing an argument of <code>-c&nbsp;proxy</code> to 
<code>vglrun</code>.</p>



<h2 id="hd009002">9.2&nbsp;Using VirtualGL with an X Proxy on a Different Machine</h2>

<p><a name="X11_Proxy_Usage_Remote"></a></p>

<div class="figure">
<img src="vgltransportservernetwork.png" alt="vgltransportservernetwork" class="figure" id="imgid_13" name="imgid_13"/>
</div>

<p>If the X proxy and VirtualGL are running on different servers, then it 
is desirable to use the VGL Transport to send images from the VirtualGL 
server to the X proxy.  It is also desirable to disable image 
compression in the VGL Transport.  Otherwise, the images would have to 
be compressed by the VirtualGL server, decompressed by the VirtualGL 
Client, then recompressed by the X proxy, which is a waste of CPU 
resources.  However, sending images uncompressed over a network requires 
a fast network (generally, Gigabit Ethernet or faster), so there needs 
to be a fast link between the VirtualGL server and the X proxy server 
for this procedure to perform well.</p>

<p>The procedure for using the VGL Transport to display 3D applications 
from a VirtualGL server to a remote X proxy is the same as the 
<a href="#X11_Forwarding">procedure</a><a name="idx0043"></a> for using 
the VGL Transport to display 3D applications from a VirtualGL server to 
a remote 2D X server, with the following exceptions:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        The &ldquo;client&rdquo; in this case is really the X proxy server.
    </li>
    <li class="Ordered-1 Ordered">
        The &ldquo;X server&rdquo; is really the X proxy.
    </li>
    <li class="Ordered-1 Ordered">
        Once connected to the VirtualGL server with SSH, it is recommended that 
        you disable image compression in the VGL Transport by either setting the 
        <code>VGL_COMPRESS</code> environment variable to <code>rgb</code> or 
        passing an argument of <code>-c&nbsp;rgb</code> to <code>vglrun</code> 
        when launching VirtualGL.  Otherwise, VirtualGL will detect that the 
        connection to the X server is remote, and it will automatically try to 
        enable JPEG compression.
    </li>
</ol>

<p><br /></p>

<hr class="break" />



<h1 id="hd0010"><a name="file010"></a>10&nbsp;Support for the X Video Extension</h1>

<p><a name="X_Video_Support"></a></p>

<p>The X Video extension allows applications to pre-encode or pre-compress 
images and send them through the X server to the graphics card, which 
presumably has on-board video decoding capabilities.  This approach 
greatly reduces the amount of CPU resources used by the X server, which 
can be beneficial if the X server is running on a different machine than 
the application.</p>

<p>In the case of VirtualGL, what this means is that the VirtualGL client 
machine no longer has to decode or decompress images from the 3D 
application server. It can simply pass the images along to the graphics 
card for decoding.</p>

<p>VirtualGL supports the X Video extension in two ways:</p>


<h2 id="hd0010001">10.1&nbsp;The VGL Transport with YUV Encoding</h2>

<p>Setting the <code>VGL_COMPRESS</code> environment variable to 
<code>yuv</code> or passing an argument of <code>-c&nbsp;yuv</code> to 
<code>vglrun</code> enables the VGL Transport with YUV encoding.  When 
this mode is enabled, VirtualGL encodes images as YUV420P (a form of YUV 
encoding that uses 4X chrominance subsampling and separates Y, U, and V 
pixel components into separate image planes) instead of RGB or JPEG.  
The YUV420P images are sent to the VirtualGL Client, which draws them 
using the X Video extension.</p>

<p>On a per-frame basis, YUV encoding uses about half the server CPU time 
as JPEG compression and only slightly more server CPU time than RGB 
encoding.  On a per-frame basis, YUV encoding uses about 1/3 the client 
CPU time as JPEG compression and about half the client CPU time as RGB 
encoding.  YUV encoding also uses about half the network bandwidth (per 
frame) as RGB.</p>

<p>However, since YUV encoding uses 4X chrominance subsampling, the 
resulting images may contain some visible artifacts.  In particular, 
narrow, aliased lines and other sharp features may appear 
&ldquo;soft&rdquo;.</p>



<h2 id="hd0010002">10.2&nbsp;The XV Transport</h2>

<p>Setting the <code>VGL_COMPRESS</code> environment variable to 
<code>xv</code> or passing an argument of <code>-c&nbsp;xv</code> to 
<code>vglrun</code> enables the XV Transport.  The XV Transport is a 
special version of the X11 Transport that encodes images as YUV420P and 
draws them directly to the 2D X server using the X Video extension.  
This is mainly useful in conjunction with X proxies, such as the Sun Ray 
Server Software, that support the X Video extension.  The idea is that, 
if the X proxy is going to have to transcode the image to YUV anyhow, 
VirtualGL may be faster at doing this, since it has a SIMD-accelerated 
YUV encoder.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0011"><a name="file011"></a>11&nbsp;Using VirtualGL in a Sun Ray Environment</h1>

<p><a name="Sun_Ray_Usage"></a></p>

<p>The Sun Ray technology from Oracle consists of a software component (the 
Sun Ray Server Software, or SRSS) and an ultra-thin hardware client (the 
Sun Ray Desktop Unit, or DTU.)  The SRSS receives connection requests 
from multiple DTU&rsquo;s and creates a separate instance of the Sun Ray 
X Server (an X proxy) for each user.  These X proxy sessions can be 
seamlessly suspended/resumed or migrated from one DTU to another by the 
use of smartcards (every Sun Ray DTU has a built-in smartcard reader.)</p>

<p>As with most X proxies, each instance of the Sun Ray X Server creates a 
virtual desktop with which the user can interact to launch applications.  
The Sun Ray X Server is responsible for compressing the images from the 
virtual desktop and sending the compressed images across the network to 
the user&rsquo;s DTU using the proprietary ALP protocol.  The images are 
converted to YUV with up to 16X chrominance subsampling and can be 
further compressed using Differential Pulse Code Modulation (DPCM) or 
wavelets.</p>

<p>If VirtualGL is installed and run on a Sun Ray Server, then the 3D 
images from VirtualGL can be displayed to a Sun Ray X Server instance 
using the X11 Transport, as with any other X proxy.  However, most Sun 
Ray Servers are deployed as 2D application servers, and thus they may 
have dozens of users connecting to them at any given time.  3D 
applications are very demanding of system resources, so running these 
applications on a Sun Ray Server that is shared by many 2D application 
users is not a recommended approach.</p>

<p>To get around this problem, VirtualGL 2.0.x and 2.1.x used a proprietary 
plugin provided by Sun, which sent images directly from the 3D 
application server to the Sun Ray DTU, thus bypassing the Sun Ray Server 
altogether.</p>

<a name="fig0011001"></a>
<div class="figure">
<p class="caption">Figure 11.1: The Sun Ray Transport (Provided by a Proprietary Plugin to VirtualGL 2.0.x and 2.1.x)</p>
<img src="sunray.png" alt="sunray" class="figure" id="imgid_14" name="imgid_14"/>
</div>

<p>When the Sun Visualization System product was discontinued in early 
2009, the proprietary VirtualGL Sun Ray plugin was discontinued along 
with it.  Although sending pre-compressed images directly to the DTU was 
advantageous in that it eliminated almost all of the CPU and network 
load from the Sun Ray Server, it was not without its problems.  Handling 
window clipping and throttling the bandwidth to avoid dropped UDP 
packets were among these.  With the release of SRSS 4.1, Sun implemented 
the X Video extension in the Sun Ray X Server, which allows applications 
to pre-encode YUV images and send these through the Sun Ray X Server to 
the DTU without any transcoding.</p>

<p>VirtualGL 2.2 supports this mechanism through the use of the XV 
Transport and the VGL Transport with YUV encoding (see Chapter 
<a href="#X_Video_Support" class="ref">10</a>.)  If VirtualGL detects 
that the 2D X server is a Sun Ray X Server instance, then it will 
automatically enable the XV Transport if the X server connection is 
local or the VGL Transport with YUV encoding if the X server is remote.  
The remote case is illustrated in the figure below.</p>

<a name="fig0011002"></a>
<div class="figure">
<p class="caption">Figure 11.2: The VGL Transport with YUV Encoding in a Sun Ray Environment</p>
<img src="sunrayvgltransport.png" alt="sunrayvgltransport" class="figure" id="imgid_15" name="imgid_15"/>
</div>

<p>There are trade-offs with using X Video vs. using the Sun Ray Transport. 
Whereas the X Video mechanism still uses very little CPU time on the Sun 
Ray Server, it requires a great deal of network bandwidth.  The Sun Ray 
X Video implementation only supports up to 4X chrominance subsampling, 
which means that a 2:1 compression ratio is the best that one can 
achieve.  This means that each pixel sent through the Sun Ray server 
will require approximately 24 bits to represent it on the network (12 
bits coming in from the 3D server, and another 12 going out to the Sun 
Ray DTU.)  To sustain a 1280x1024 image stream at 8 frames/second 
(generally the maximum sustainable performance for that size image on 
Sun Ray 2 hardware) would require 250 Megabits/second of bandwidth. In 
general, the Sun Ray Server would need to be provisioned with multiple 
Gigabit Ethernet adapters in this case.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0012"><a name="file012"></a>12&nbsp;Transport Plugins</h1>

<p>VirtualGL 2.2 includes an API that allows you to write your own image 
transports.  Thus, you can use VirtualGL for doing split rendering and 
pixel readback but then use your own library for delivering the pixels 
to the client.</p>

<p>When the <code>VGL_TRANSPORT</code> environment variable (or the 
<code>-trans</code> option to <code>vglrun</code>) is set to 
<em><code>{t}</code></em>, then VirtualGL will look for a DSO (dynamic 
shared object) with the name 
<code>libtransvgl_</code><em><code>{t}</code></em><code>.so</code> in 
the dynamic linker path and will attempt to access a set of API 
functions from this library.  The functions that the plugin library must 
export are defined in <code>/opt/VirtualGL/include/rrtransport.h</code>, 
and an example of their usage can be found in 
<code>rr/testplugin.cpp</code> and <code>rr/testplugin2.cpp</code> in 
the VirtualGL source distribution.  The former wraps the VGL Transport 
as an image transport plugin, and the latter does the same for the X11 
Transport.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0013"><a name="file013"></a>13&nbsp;Using VirtualGL with setuid/setgid Executables</h1>

<p><code>vglrun</code> can be used to launch either binary executables or 
shell scripts, but there are a few things to keep in mind when using 
<code>vglrun</code> to launch a shell script.  When you 
<code>vglrun</code> a shell script, the VirtualGL faker library will be 
preloaded into every executable that the script launches.  Normally this 
is innocuous, but if the script calls any executables that have the 
setuid and/or setgid permission bits set, then the dynamic linker will 
refuse to preload the VirtualGL faker library into those executables.  
One of the following warnings will be printed out for each setuid/setgid 
executable that the script tries to launch:</p>

<dl class="Description">
    <dt class="Description-1 Description">Linux</dt>
    <dd class="Description-1 Description">
    </dd>
</dl>

<pre class="verbatim">
ERROR:&nbsp;ld.so:&nbsp;object&nbsp;'librrfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.
</pre>

<pre class="verbatim">
ERROR:&nbsp;ld.so:&nbsp;object&nbsp;'libdlfaker.so'&nbsp;from&nbsp;LD_PRELOAD&nbsp;cannot&nbsp;be&nbsp;preloaded:&nbsp;ignored.
</pre>

<dl class="Description">
    <dt class="Description-1 Description">Solaris</dt>
    <dd class="Description-1 Description">
    </dd>
</dl>

<pre class="verbatim">
ld.so.1:&nbsp;warning:&nbsp;librrfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories
</pre>

<pre class="verbatim">
ld.so.1:&nbsp;warning:&nbsp;libdlfaker.so:&nbsp;open&nbsp;failed:&nbsp;No&nbsp;such&nbsp;file&nbsp;in&nbsp;secure&nbsp;directories
</pre>

<p>On Solaris and versions of Linux with GLIBC 2.3 and later, these are 
just warnings, and the setuid/setgid executables will continue to run 
(without VirtualGL preloaded into them.)  However, if you want to get 
rid of the warnings, an easy way to do so is to simply edit the 
application script and make it store the value of the 
<code>LD_PRELOAD</code> environment variables until right before the 
application executable is launched.  For instance, consider the 
following application script:</p>

<p>Initial contents of <code>application.sh</code>:</p>

<pre class="verbatim">
#!/bin/sh
some_setuid_executable
some_3D_application_executable
</pre>

<p>You could modify the script as follows:</p>

<dl class="Description">
    <dt class="Description-1 Description">Solaris</dt>
    <dd class="Description-1 Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_32_SAVE=$LD_PRELOAD_32
LD_PRELOAD_64_SAVE=$LD_PRELOAD_64
LD_PRELOAD_32=
LD_PRELOAD_64=
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_setuid_executable

LD_PRELOAD_32=$LD_PRELOAD_32_SAVE
LD_PRELOAD_64=$LD_PRELOAD_64_SAVE
export&nbsp;LD_PRELOAD_32&nbsp;LD_PRELOAD_64

some_3D_application_executable
</pre>

<dl class="Description">
    <dt class="Description-1 Description">Linux</dt>
    <dd class="Description-1 Description">
        Modified <code>application.sh</code>:
    </dd>
</dl>

<pre class="verbatim">
#!/bin/sh
LD_PRELOAD_SAVE=$LD_PRELOAD
LD_PRELOAD=
export&nbsp;LD_PRELOAD

some_setuid_executable

LD_PRELOAD=$LD_PRELOAD_SAVE
export&nbsp;LD_PRELOAD

some_3D_application_executable
</pre>

<p>This procedure may be necessary to work around certain other problems 
that exist in the launch scripts of specific applications.  See 
<a href="#Application_Recipes">Application 
Recipes</a><a name="idx0044"></a> for more details.</p>

<p>If the 3D application that you are intending to run in VirtualGL is 
itself a setuid/setgid executable, then further steps are required.  
Otherwise, the 3D application will launch without VirtualGL preloaded 
into it.  Forcing VirtualGL to be preloaded into setuid/setgid 
executables has security ramifications, so please be aware of these 
before you do it.  By applying one of the following workarounds, you are 
essentially telling the operating system that you trust the security and 
stability of the VirtualGL code as much as you trust the security and 
stability of the operating system.  While we&rsquo;re flattered, 
we&rsquo;re not sure that we&rsquo;re necessarily deserving of that 
accolade, so if you are in a security-critical environment, apply the 
appropriate level of paranoia here.</p>

<p><a name="setuid_linux"></a> To force VirtualGL to be preloaded into 
setuid/setgid executables on Linux, make <code>librrfaker.so</code> and 
<code>libdlfaker.so</code> setuid executables.  To do this, run the 
following commands as root:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib/librrfaker.so
chmod&nbsp;u+s&nbsp;/usr/lib/libdlfaker.so
</pre>

<p>On 64-bit Linux systems, also run:</p>

<pre class="verbatim">
chmod&nbsp;u+s&nbsp;/usr/lib64/librrfaker.so
chmod&nbsp;u+s&nbsp;/usr/lib64/libdlfaker.so
</pre>

<p>On Solaris, you can force VirtualGL to be preloaded into setuid/setgid 
executables by adding the VirtualGL library directories to the Solaris 
&ldquo;secure path.&rdquo;  Solaris keeps a tight lid on what goes into 
<code>/usr/lib</code> and <code>/lib</code>, and by default, it will 
only allow libraries in those paths to be preloaded into an executable 
that is setuid and/or setgid.  Generally, 3rd party packages are 
forbidden from installing anything into <code>/usr/lib</code> or 
<code>/lib</code>, but you can use the <code>crle</code> utility to add 
other directories to the operating system&rsquo;s list of secure paths.  
In the case of VirtualGL, you would execute the following commands (as 
root):</p>

<pre class="verbatim">
crle&nbsp;-u&nbsp;-s&nbsp;/opt/VirtualGL/lib
crle&nbsp;-64&nbsp;-u&nbsp;-s&nbsp;/opt/VirtualGL/lib/64
</pre>

<p><code>vglrun</code> on Solaris has two additional options that are 
relevant to launching scripts:</p>

<pre class="verbatim">
vglrun&nbsp;-32&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 32-bit executables called by a script, 
whereas</p>

<pre class="verbatim">
vglrun&nbsp;-64&nbsp;{script}
</pre>

<p>will preload VirtualGL only into 64-bit executables.  So if, for 
instance, the setuid executable that the script is invoking is 32-bit 
and the application executable is 64-bit, then you could use 
<code>vglrun&nbsp;-64</code> to launch the application script.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0014"><a name="file014"></a>14&nbsp;Using VirtualGL with Chromium</h1>

<p><a name="Chromium"></a></p>

<p>Chromium is a powerful framework for performing various types of 
parallel OpenGL rendering.  It is usually used on clusters of commodity 
Linux PC&rsquo;s to divide up the task of rendering scenes with large 
geometries or large pixel counts (such as when driving a display wall.)  
Chromium is most often used in one of three configurations:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered" value="1">
        Sort-First Rendering (Image-Space Decomposition)
    </li>
    <li class="Ordered-1 Ordered" value="2">
        Sort-First Rendering (Image-Space Decomposition) with Readback
    </li>
    <li class="Ordered-1 Ordered" value="3">
        Sort-Last Rendering (Object-Space Decomposition)
    </li>
</ol>


<h2 id="hd0014001">14.1&nbsp;Configuration 1: Sort-First Rendering (Image-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-displaywall.png" alt="chromium-displaywall" class="figure" id="imgid_16" name="imgid_16"/>
</div>

<p>Sort-First Rendering (Image-Space Decomposition) is used to overcome the 
fill rate limitations of individual graphics cards.  When configured to 
use sort-first rendering, Chromium divides up the scene based on which 
polygons will be visible in a particular section of the final image.  It 
then instructs each node of the cluster to render only the polygons that 
are necessary to generate the image section (&ldquo;tile&rdquo;) for 
that node.  This is primarily used to drive high-resolution displays 
that would be impractical to drive from a single graphics card due to 
limitations in the card&rsquo;s framebuffer memory, processing power, or 
both.  Configuration 1 could be used, for instance, to drive a CAVE, 
video wall, or even an extremely high-resolution monitor.  In this 
configuration, each Chromium node generally uses all of its screen real 
estate to render a section of the multi-screen image.</p>

<p>VirtualGL is generally not very useful with Configuration 1.  You could 
theoretically install a separate copy of VirtualGL on each display node 
and use it to redirect the output of each <code>crserver</code> instance 
to a separate VirtualGL Client instance running on a multi-screen 2D X 
server elsewhere on the network. However, synchronizing the frames on 
the remote end would require extensive modifications to VirtualGL and 
perhaps to Chromium as well.  Such is left as an exercise for the reader.</p>



<h2 id="hd0014002">14.2&nbsp;Configuration 2: Sort-First Rendering (Image-Space Decomposition) with Readback</h2>

<div class="figure">
<img src="chromium-sortfirst.png" alt="chromium-sortfirst" class="figure" id="imgid_17" name="imgid_17"/>
</div>

<p>Configuration 2 uses the same sort-first principle as Configuration 1, 
except that each tile is only a fraction of a single screen, and the 
tiles are recombined into a single window on Node 0.  This configuration 
is perhaps the least often used of the three, but it is useful in cases 
where the scene contains a large amount of textures (such as in volume 
rendering) and thus rendering the whole scene on a single node would be 
prohibitively slow due to fill rate limitations.</p>

<p>In this configuration, the application is allowed to choose a visual, 
create an X window, and manage the window as it would normally do.  
However, all other OpenGL and GLX activity is intercepted by the 
Chromium App Faker (CrAppFaker) so that the 3D rendering can be split up 
among the rendering nodes.  Once each node has rendered its section of 
the final image, the image tiles are passed back to a Chromium Server 
(CrServer) process running on Node 0.  This CrServer process attaches to 
the previously-created application window and draws the pixels into the 
window using <code>glDrawPixels()</code>.</p>

<p>The general strategy for making this work with VirtualGL is to first 
make it work without VirtualGL and then insert VirtualGL only into the 
processes that run on Node 0.  VirtualGL must be inserted into the 
CrAppFaker process to prevent CrAppFaker from sending 
<code>glXChooseVisual()</code> calls to the 2D X server (which would 
fail if this X server did not support GLX.)  VirtualGL must be inserted 
into the CrServer process on Node 0 to prevent it from sending 
<code>glDrawPixels()</code> calls to the 2D X server (which would 
similarly fail if the 2D X server didn&rsquo;t support GLX and which 
would create a performance issue if the 2D X server was remote.)  
Instead, VirtualGL forces CrServer to draw into a Pbuffer, and VGL then 
takes charge of transmitting the pixels from the Pbuffer to the 2D X 
server in the most efficient way possible.</p>

<p>As with any normal OpenGL application, CrServer can be launched using 
<code>vglrun</code>.  However, because CrAppFaker also interposes OpenGL 
and GLX functions, it must be handled differently in order to avoid 
interference with VirtualGL.  Chromium provides an environment variable, 
<code>CR_SYSTEM_GL_PATH</code>, which allows one to specify an alternate 
path to be searched for <code>libGL.so</code>. On Linux and Unix 
systems, VirtualGL installs a symbolic link named <code>libGL.so</code>, 
which points to the VirtualGL faker library 
(<code>librrfaker.so</code>). This symbolic link is located in its own 
isolated directory, so that directory can be passed to Chromium in the 
<code>CR_SYSTEM_GL_PATH</code> environment variable, and this will cause 
Chromium to load VirtualGL rather than the &ldquo;real&rdquo; OpenGL 
library.  Refer to the following table:</p>

<p><a name="CR_SYSTEM_GL_PATH_Table"></a></p>

<div class="table">
<table class="standard" align="center">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">32-bit Applications</th>
    <th class="head standard">64-bit Applications</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard"><code>/opt/VirtualGL/fakelib</code></td>
    <td class="standard"><code>/opt/VirtualGL/fakelib64</code></td>
  </tr>
</table>
<div class="tableNote" style="text-align=center;"><code>CR_SYSTEM_GL_PATH</code> setting required to use VirtualGL with Chromium</div>
</div>


<p>To run CrAppFaker, it is necessary to set this environment variable to 
the appropriate value so that Chromium will load the interposed versions 
of OpenGL and GLX functions from VirtualGL.  It is also necessary to set 
<code>VGL_GLLIB</code> to the location of the &ldquo;real&rdquo; OpenGL 
library (example: <code>/usr/lib/libGL.so.1</code>). CrAppFaker creates 
its own fake version of <code>libGL.so</code>, which is really just a 
copy of Chromium&rsquo;s <code>libcrfaker.so</code>.  Thus, if left to 
its own devices, VirtualGL will unwittingly try to load 
<code>libcrfaker.so</code> instead of the &ldquo;real&rdquo; OpenGL 
library.  Chromium&rsquo;s <code>libcrfaker.so</code> will, in turn, try 
to load VirtualGL, and an endless loop will occur.</p>

<p>Therefore, we must use the <code>CR_SYSTEM_GL_PATH</code> environment 
variable to tell Chromium to pass OpenGL commands into VirtualGL, then 
we must use the <code>VGL_GLLIB</code> environment variable to tell 
VirtualGL <em>not</em> to pass OpenGL commands into Chromium.  For 
example:</p>

<pre class="verbatim">
export&nbsp;CR_SYSTEM_GL_PATH=/opt/VirtualGL/fakelib
export&nbsp;VGL_GLLIB=/usr/lib/libGL.so.1
crappfaker
</pre>

<p>CrAppFaker will copy the application into a temporary directory and then 
copy <code>libcrfaker.so</code> to that same directory, renaming it as 
<code>libGL.so</code>.  So, when the application is started, it loads 
<code>libcrfaker.so</code> instead of <code>libGL.so</code>. 
<code>libcrfaker.so</code> will then load VirtualGL instead of the 
&ldquo;real&rdquo; OpenGL library, because we&rsquo;ve overridden 
<code>CR_SYSTEM_GL_PATH</code> to point to VirtualGL&rsquo;s fake 
<code>libGL.so</code>.  VirtualGL will then use the library specified in 
<code>VGL_GLLIB</code> to make any &ldquo;real&rdquo; OpenGL calls that 
it needs to make.</p>

<div class="important"><p class="important">
NOTE: <code>crappfaker</code> should not be invoked with <code>vglrun</code>.
</p></div>

<p>So, putting this all together, here is an example of how you might start 
a sort-first rendering job using Chromium and VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-first rendering with readback
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crserver</code> on each of the rendering nodes
        <div class="important"><p class="important">
        NOTE: <code>crserver</code> should be run on display :0 (or whichever display is attached to the 3D hardware.)
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, set the <code>CR_SYSTEM_GL_PATH</code> environment variable 
        to the appropriate value based on whether <code>crappfaker</code> was 
        compiled as a 32-bit or a 64-bit app (see table above)
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, set <code>VGL_GLLIB</code> to the location of the 
        &ldquo;real&rdquo; OpenGL library (example: 
        <code>/usr/lib/libGL.so.1</code> or <code>/usr/lib64/libGL.so.1</code>).
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, launch <code>crappfaker</code> (do not use 
        <code>vglrun</code> here)
    </li>
</ol>

<p>Again, it&rsquo;s always a good idea to make sure this works without 
VirtualGL before adding VirtualGL into the mix.</p>

<p><a name="Force_Pbuffer"></a></p>


<h3 id="hd0014002001">Using VirtualGL to Force Pbuffer Rendering</h3>

<p>In the procedure above, VirtualGL can also be used on the rendering 
nodes to redirect the rendering commands from <code>crserver</code> into 
a Pbuffer instead of a window.  If you wish to do this, then perform the 
following procedure in place of step 2 above:</p>

<p>On each of the rendering nodes,</p>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        set the <code>VGL_READBACK</code> environment variable to <code>0</code>
    </li>
    <li class="Itemize-1 Itemize asterisk">
        <code>vglrun&nbsp;crserver</code>
        <div class="important"><p class="important">
        NOTE: You must configure each of the rendering nodes as a VirtualGL server (that is, run <code>'vglserver_config</code>&rsquo; as instructed in Chapter <a href="#Unix_Config" class="ref">6</a>) in order for this to work when the rendering nodes are sitting at the login prompt.
        </p></div>
    </li>
</ul>



<h2 id="hd0014003">14.3&nbsp;Configuration 3: Sort-Last Rendering (Object-Space Decomposition)</h2>

<div class="figure">
<img src="chromium-sortlast.png" alt="chromium-sortlast" class="figure" id="imgid_18" name="imgid_18"/>
</div>

<p>Sort-Last Rendering is used when the scene contains a huge number of 
polygons and the rendering bottleneck is processing all of that geometry 
on a single graphics card.  In this case, each node runs a separate copy 
of the application, and for best results, the application needs to be 
aware that it is running in a parallel environment so that it can give 
Chromium hints as to how to distribute the various objects to be 
rendered.  Each node generates an image of a particular portion of the 
object space, and these images must be composited in such a way that the 
front-to-back ordering of pixels is maintained.  This is generally done 
by collecting Z buffer data from each node to determine whether a 
particular pixel on a particular node is visible in the final image.  
The rendered images from each node are often composited using a 
&ldquo;binary swap&rdquo;, whereby the nodes combine their images in a 
cascading tree so that the overall compositing time is proportional to 
log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-last rendering
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
        <div class="important"><p class="important">
        NOTE: <code>crappfaker</code> should be run on display :0 (or whichever display is attached to the 3D hardware.)
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>


<h3 id="hd0014003001">CRUT</h3>

<p>The Chromium Utility Toolkit provides a convenient way for graphics 
applications to specifically take advantage of Chromium&rsquo;s 
sort-last rendering capabilities.  Such applications can use CRUT to 
explicitly specify how their object space should be decomposed.  CRUT 
applications require an additional piece of software, 
<code>crutserver</code>, to be running on Node 0.  Therefore, the 
following procedure should be used to make these applications work with 
VirtualGL:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Start the mothership on Node 0 with an appropriate configuration for 
        performing sort-last rendering
    </li>
    <li class="Ordered-1 Ordered">
        Start <code>crappfaker</code> on each of the rendering nodes
        <div class="important"><p class="important">
        NOTE: <code>crappfaker</code> should be run on display :0 (or whichever display is attached to the 3D hardware.)
        </p></div>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crutserver&nbsp;&amp;</code>
    </li>
    <li class="Ordered-1 Ordered">
        On Node 0, <code>vglrun&nbsp;crserver</code>
    </li>
</ol>



<h2 id="hd0014004">14.4&nbsp;A Note About Performance</h2>

<p>Chromium&rsquo;s use of X11 is generally not very optimal.  It assumes a 
very fast connection between the 2D X server and the Chromium Server.  
In certain modes, Chromium polls the 2D X server on every frame to 
determine whether windows have been resized, etc.  Thus, we have 
observed that, even on a fast network, Chromium tends to perform much 
better with VirtualGL running in an X proxy as opposed to using the VGL 
Transport.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0015"><a name="file015"></a>15&nbsp;Using VirtualGL with VirtualBox</h1>

<p>VirtualBox is an enterprise-class, open source virtualization solution 
provided by Oracle.  With the release of VirtualBox 2.1.0, experimental 
support was added for hardware-accelerated OpenGL in Windows and Linux 
guests running on Windows, MacIntel, Linux, and Solaris/x86 hosts. 3D 
acceleration in VirtualBox is accomplished by installing a special 
driver in the guest that uses a subset of Chromium to transmit OpenGL 
calls through a local connection to the VirtualBox process running on 
the host.  When used in conjunction with VirtualGL on a Linux or 
Solaris/x86 host, this solution provides a means of displaying Windows 
3D applications remotely.</p>

<p>To use VirtualGL with VirtualBox, perform the following procedures:</p>


<h3 id="hd0015000001">Configuring the System</h3>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Launch VirtualBox and use the VirtualBox GUI to create and test your 
        virtual machine.
    </li>
    <li class="Ordered-1 Ordered">
        Follow the procedures outlined in the VirtualBox User&rsquo;s Manual to 
        enable 3D acceleration on the virtual machine.  Verify that 3D 
        acceleration works <em>without</em> VirtualGL before adding VirtualGL to 
        the mix.
    </li>
    <li class="Ordered-1 Ordered">
        Follow the procedure described in Chapter 
        <a href="#setuid_linux" class="ref">13</a> to make 
        <code>librrfaker.so</code> and <code>libdlfaker.so</code> setuid 
        executables (Linux) or to add the VirtualGL library directory to the 
        list of secure paths (Solaris).
    </li>
</ol>



<h3 id="hd0015000002">Launching VirtualBox</h3>

<p>This should work on most Linux systems.  It is known to work with 
VirtualBox 4.1.8 and prior and VirtualBox 4.2 and later.</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        <code>vglrun&nbsp;VirtualBox&nbsp;-startvm&nbsp;</code><em><code>{VM&nbsp;name&nbsp;or&nbsp;UUID}</code></em>
    </li>
</ol>
<div class="important"><p class="important">
With VirtualBox 4.1.10 and later 4.1.x versions, it is necessary to rename <code>/usr/lib/virtualbox/VBoxTestOGL</code> and symlink <code>/bin/true</code> to <code>/usr/lib/virtualbox/VBoxTestOGL</code> in order to use those versions of VirtualBox with VirtualGL.
</p></div>



<h3 id="hd0015000003">NOTES</h3>

<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        You might want to temporarily enable profiling (add an argument of 
        <code>+pr</code> to <code>vglrun</code> above) or set the 
        <code>VGL_LOGO</code> environment variable to <code>1</code> in order to 
        verify that VirtualGL is loaded and working.
    </li>
    <li class="Itemize-1 Itemize asterisk">
        It is necessary to start the virtual machine directly as described 
        above. Simply executing <code>vglrun&nbsp;VirtualBox</code> and using 
        the GUI to launch the VM does not work.  VirtualBox forks a separate 
        process for each VM, and the value of the <code>LD_PRELOAD</code> 
        environment variable from <code>vglrun</code> does not get propagated to 
        the VM process unless you start it directly.
    </li>
    <li class="Itemize-1 Itemize asterisk">
        VirtualBox sends mainly uncompressed image updates to the X display, so 
        the 2D elements of the virtual machine display will not perform well 
        over a remote X11 connection unless a 
        <a href="#Direct_X11_Connection">direct X11 
        connection</a><a name="idx0045"></a> (<code>vglconnect&nbsp;-x</code>) 
        is used with gigabit Ethernet (or faster.)  For 100 Megabit and slower 
        networks, using a high-performance X proxy (such as TurboVNC) is 
        recommended when remotely displaying VirtualBox using VirtualGL.
    </li>
</ul>

<p><br /></p>

<hr class="break" />



<h1 id="hd0016"><a name="file016"></a>16&nbsp;Other Application Recipes</h1>

<p><a name="Application_Recipes"></a></p>

<div class="table">
<table class="standard">
  <thead class="standard">
  <tr class="head ">
    <th class="head standard">Application</th>
    <th class="head standard">Platform</th>
    <th class="head standard">Recipe</th>
    <th class="head standard">Notes</th>
  </tr>
  </thead>
  <tr class="standard">
    <td class="standard">Abaqus v6</td>
    <td class="standard">Linux</td>
    <td class="standard">It is necessary to add <br /><br /> <code>import&nbsp;os</code><br /> <code>os.environ['ABAQUS_EMULATE_OVERLAYS']&nbsp;=&nbsp;&quot;1&quot;</code> <br /><br /> to <code>/{abaqus_install_dir}/{abaqus_version}/site/abaqus_v6.env</code> to make Abaqus v6 work properly with VirtualGL if the 2D X server does not support transparent overlays.  If this is not done, then the application may fail to launch, fail to display the 3D pixels, or the 3D pixels may become corrupted whenever other windows obscure them.</td>
    <td class="standard">VirtualGL does not redirect the rendering of transparent overlays, since those cannot be rendered in a Pbuffer.  Thus, in order to use transparent overlays, the 2D X server must be able to render them, which is rarely the case for X proxies (see Section <a href="#overlays" class="ref">17.2</a> for more details.)  Setting <code>ABAQUS_EMULATE_OVERLAYS</code> to <code>1</code> causes the application to emulate overlay rendering instead of using actual transparent overlays.  This workaround is known to be necessary when running Abaqus 6.9 and 6.10 in VNC.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Abaqus v6</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;-nodl&nbsp;{abaqus_path}/abaqus</code></td>
    <td class="standard">User reports indicate that Abaqus 6.9 will not work properly if <code>libdlfaker.so</code> from VirtualGL is preloaded into it.  This may be true for other versions of Abaqus as well.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Abaqus v6</td>
    <td class="standard">Linux</td>
    <td class="standard">Set the <code>VGL_DEFAULTFBCONFIG</code> environment variable to <code>GLX_STENCIL_SIZE,8</code> prior to launching the application with <code>vglrun</code></td>
    <td class="standard">Abaqus 6.10 requires a visual with a stencil buffer, but it does not call <code>glXChooseVisual()</code> to specify its desire for such a visual.  Thus, VirtualGL has no idea of the application&rsquo;s preference, and it is necessary to use <code>VGL_DEFAULTFBCONFIG</code> to give VirtualGL a hint as to what the application wants.  Otherwise, VirtualGL will create a Pbuffer without a stencil buffer, and this will cause incorrect rendering when using certain functions within Abaqus (such as View Cut.)  See Section <a href="#VGL_DEFAULTFBCONFIG" class="ref">20.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Animator 4</td>
    <td class="standard">Linux</td>
    <td class="standard">Comment out the line that reads <br /><br /> <code>unsetenv&nbsp;LD_PRELOAD</code> <br /><br /> in the <code>a4</code> script, then launch Animator 4 using <br /><br /> <code>vglrun&nbsp;-ge&nbsp;a4</code> <br /><br /></td>
    <td class="standard">When the <code>a4</code> script unsets <code>LD_PRELOAD</code>, this prevents VirtualGL from being loaded into the application.  Animator 4 additionally checks the value of <code>LD_PRELOAD</code> and attempts to unset it from inside the application.  Using <code>vglrun&nbsp;-ge</code> to launch the application fools Animator 4 into thinking that <code>LD_PRELOAD</code> is unset.</td>
  </tr>
  <tr class="standard">
    <td class="standard">ANSA v12.1.0</td>
    <td class="standard">Linux</td>
    <td class="standard">Add <br /><br /> <code>LD_PRELOAD_SAVE=$LD_PRELOAD</code><br /> <code>export&nbsp;LD_PRELOAD=</code> <br /><br /> to the top of the <code>ansa.sh</code> script, then add <br /><br /> <code>export&nbsp;LD_PRELOAD=$LD_PRELOAD_SAVE</code> <br /><br /> just prior to the <code>${ANSA_EXEC_DIR}bin/ansa_linux${ext2}</code> line.</td>
    <td class="standard">The ANSA startup script directly invokes <code>/lib/libc.so.6</code> to query the glibc version.  Since the VirtualGL faker depends on libc, preloading VirtualGL when directly invoking <code>libc.so.6</code> creates an infinite loop. Thus, it is necessary to disable the preloading of VirtualGL in the application script and then re-enable it prior to launching the actual application.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Ansoft HFSS, Roxar RMS</td>
    <td class="standard">Linux</td>
    <td class="standard">Set the <code>VGL_SPOILLAST</code> environment variable to <code>0</code> prior to launching the application with <code>vglrun</code></td>
    <td class="standard">These applications use double buffering and draw geometry to the back buffer, but node highlighting and rubber banding are drawn directly to the front buffer. In order for these front buffer operations to be displayed properly, it is necessary to use the &ldquo;spoil first&rdquo; frame spoiling algorithm whenever the application calls <code>glFlush()</code>.  See Section <a href="#VGL_SPOILLAST" class="ref">20.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">AutoForm v4.0x</td>
    <td class="standard">All</td>
    <td class="standard"><code>vglrun&nbsp;+sync&nbsp;xaf_</code><em><code>{version}</code></em></td>
    <td class="standard">AutoForm relies on mixed X11/OpenGL rendering, and thus certain features (particularly the &ldquo;Dynamic Section&rdquo; dialog and &ldquo;Export Image&rdquo; feature) do not work properly unless <code>VGL_SYNC</code> is enabled.  Since <code>VGL_SYNC</code> automatically enables the X11 transport and disables frame spoiling, it is highly recommended that you use an X proxy when <code>VGL_SYNC</code> is enabled. See Section <a href="#VGL_SYNC" class="ref">20.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Cedega v6.0.x</td>
    <td class="standard">Linux</td>
    <td class="standard">Add <br /><br /> <code>export&nbsp;LD_PRELOAD=librrfaker.so</code> <br /><br /> to the top of <code>~/.cedega/.winex_ver/winex-{version}/bin/winex3</code>, then run Cedega as you would normally (without <code>vglrun</code>.)  Since <code>vglrun</code> is not being used, it is necessary to use environment variables or the VirtualGL Configuration dialog to modify VirtualGL&rsquo;s configuration.</td>
    <td class="standard">The actual binary (WineX) that uses OpenGL is buried beneath several layers of Python and shell scripts.  The <code>LD_PRELOAD</code> variable does not get propagated down from the initial shell that invoked <code>vglrun</code>.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Heretic II</td>
    <td class="standard">Linux</td>
    <td class="standard"><code>vglrun&nbsp;heretic2&nbsp;+set&nbsp;vid_ref&nbsp;glx</code></td>
    <td class="standard"></td>
  </tr>
  <tr class="standard">
    <td class="standard">MAGMA5</td>
    <td class="standard">Linux</td>
    <td class="standard">Set the <code>VGL_DEFAULTFBCONFIG</code> environment variable to <code>GLX_STENCIL_SIZE,8</code> prior to launching the application with <code>vglrun</code></td>
    <td class="standard">MAGMA5 requires a visual with a stencil buffer, but it does not call <code>glXChooseVisual()</code> to specify its desire for such a visual.  Thus, VirtualGL has no idea of the application&rsquo;s preference, and it is necessary to use <code>VGL_DEFAULTFBCONFIG</code> to give VirtualGL a hint as to what the application wants.  Otherwise, VirtualGL will create a Pbuffer without a stencil buffer, and this will cause incorrect rendering when using certain functions within MAGMA5.  See Section <a href="#VGL_DEFAULTFBCONFIG" class="ref">20.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Mathematica 7</td>
    <td class="standard">Linux</td>
    <td class="standard">Set the <code>VGL_ALLOWINDIRECT</code> environment variable to <code>1</code> prior to launching the application with <code>vglrun</code></td>
    <td class="standard">Mathematica 7 will not draw the axis numbers on 3D charts correctly unless it is allowed to create an indirect OpenGL context.  See Section <a href="#VGL_ALLOWINDIRECT" class="ref">20.1</a> for more details.</td>
  </tr>
  <tr class="standard">
    <td class="standard">Tecplot 360 2011 and earlier</td>
    <td class="standard">Linux</td>
    <td class="standard">Set the <code>VGL_GLFLUSHTRIGGER</code> environment variable to <code>0</code> prior to launching the application with <code>vglrun</code></td>
    <td class="standard">When running in TurboVNC (using VirtualGL), flashing artifacts will be produced when the user zooms/pans/rotates the scene in Tecplot 360, unless VirtualGL is instructed not to use <code>glFlush()</code> as an end-of-frame trigger.  This has been fixed in Tecplot 2012 and later. See Section <a href="#VGL_GLFLUSHTRIGGER" class="ref">20.1</a> for more details.</td>
  </tr>
</table>
</div>


<p><br /></p>

<hr class="break" />



<h1 id="hd0017"><a name="file017"></a>17&nbsp;Advanced OpenGL Features</h1>

<p><a name="Advanced_OpenGL"></a></p>


<h2 id="hd0017001">17.1&nbsp;Stereographic Rendering</h2>

<p>Stereographic rendering is a feature of OpenGL that creates separate 
rendering buffers for the left and right eyes and allows the application 
to render a different image into each buffer.  How the stereo images are 
subsequently displayed depends on the particulars of the 3D hardware and 
the user&rsquo;s environment.  VirtualGL can support stereographic 
applications in one of two ways: (1) by sending the stereo image pairs 
to the client to be displayed in stereo by the client&rsquo;s 3D 
graphics card, or (2) by combining each stereo image pair into a single 
image that can be viewed with traditional anaglyphic 3D glasses or a 
passive stereo system, such as a 3D TV.</p>


<h3 id="hd0017001001">17.1.1&nbsp;Quad-Buffered Stereo</h3>

<p>The name &ldquo;quad-buffered&rdquo; stereo derives from the fact that 
OpenGL uses four buffers (left front, right front, left back, and right 
back) to support stereographic rendering with double buffering.  3D 
graphics cards with quad-buffered stereo capabilities generally provide 
some sort of synchronization signal that can be used to control various 
types of active stereo 3D glasses.  Some also support &ldquo;passive 
stereo&rdquo;, which requires displaying the left and right eye buffers 
to different monitor outputs. VirtualGL supports true quad-buffered 
stereo by rendering the stereo images on the server and sending the 
image pairs across the network to be displayed on the client.</p>

<p>In most cases, VirtualGL does not require a 3D graphics card to be 
present in the client machine.  However, a 3D graphics card is required 
to display stereo image pairs, so such a card must be present in any 
client machine that will use VirtualGL&rsquo;s quad-buffered stereo 
feature.  Since the 3D graphics card is only being used to draw images, 
it need not necessarily be a high-end card. Generally, the least 
expensive 3D graphics card that has stereo capabilities will work fine 
in a VirtualGL client machine.  The VirtualGL server must also have a 3D 
graphics card that supports stereo, since this is the only way that 
VirtualGL can obtain a stereo Pbuffer.</p>

<p>When an application tries to render something in stereo, VirtualGL will 
default to using quad-buffered stereo rendering if the 2D X server 
supports OpenGL and has stereo visuals available (Exceed 3D is required 
for Windows clients.) Otherwise, VirtualGL will fall back to using 
anaglyphic stereo (see below.) It is usually necessary to explicitly 
enable stereo in the graphics driver configuration for both the client 
and server machines.  The 
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0046"></a> 
section below lists a way to verify that both the 3D X server and the 2D 
X server have stereo visuals available.</p>

<p>In quad-buffered mode, VirtualGL reads back both the left and right eye 
buffers on the server and sends the contents as a pair of compressed 
images to the VirtualGL Client.  The VirtualGL Client then decompresses 
both images and draws them as a single stereo frame to the client 
machine&rsquo;s X display using <code>glDrawPixels()</code>.  It should 
thus be no surprise that enabling quad-buffered stereo in VirtualGL 
decreases performance by 50% or more and uses twice the network 
bandwidth to maintain the same frame rate as mono.</p>

<p>Quad-buffered stereo requires the VGL Transport.  If any other image 
transport is used, then VGL will fall back to anaglyphic stereo mode.</p>



<h3 id="hd0017001002">17.1.2&nbsp;Anaglyphic Stereo</h3>

<p>Anaglyphic stereo is the type of stereographic display used by old 3D 
movies. It typically relies on a set of 3D glasses consisting of red 
transparency film over the left eye and cyan transparency film over the 
right eye, although green/magenta and blue/yellow schemes can be used as 
well.  To generate a 3D anaglyph, one color channel from the left eye 
buffer is combined with the other two color channels from the right eye 
buffer, thus allowing a single monographic image to contain stereo data.  
For instance, in the case of red/cyan, the red channel is taken from the 
left eye buffer, and the green and blue channels are taken from the 
right eye buffer.  From the point of view of VirtualGL, an anaglyphic 
image is the same as a monographic image, so anaglyphic stereo images 
can be sent using any image transport to any type of client, regardless 
of the client&rsquo;s capabilities.</p>

<p>VirtualGL uses anaglyphic stereo if it detects that an application has 
rendered something in stereo but quad-buffered stereo is not available, 
either because the client doesn&rsquo;t support it or because a 
transport other than the VGL Transport is being used.  Anaglyphic stereo 
provides a cheap and easy way to view stereographic applications in X 
proxies and on clients that do not support quad-buffered stereo.  
Additionally, anaglyphic stereo performs much faster than quad-buffered 
stereo, since it does not require sending twice the data to the client.</p>

<p>As with quad-buffered stereo, anaglyphic stereo requires that the 
VirtualGL server have stereo rendering capabilities.  However, 
anaglyphic stereo does not require any 3D rendering capabilities (stereo 
or otherwise) on the client machine.</p>



<h3 id="hd0017001003">17.1.3&nbsp;Passive Stereo</h3>

<p>As with anaglyphic stereo, passive stereo combines a stereographic image 
pair into a single image (a &ldquo;stereogram&rdquo;), and thus it can 
be used with any image transport.  However, unlike anaglyphic stereo, 
passive stereo must be used with specific display hardware, such as a 3D 
TV or monitor, that decodes the left and right eye images from the 
stereogram and sends them separately to a pair of 3D glasses (typically, 
this is accomplished by way of polarization.)</p>

<p>VirtualGL supports three methods of encoding stereograms:</p>

<dl class="Description">
    <dt class="Description-1 Description">Interleaved</dt>
    <dd class="Description-1 Description">
        The even rows of the stereogram are taken from the left eye image, and 
        the odd rows are taken from the right eye image.
    </dd>
    <dt class="Description-1 Description">Top/Bottom</dt>
    <dd class="Description-1 Description">
        The top half of the stereogram is taken from the left eye image, and the 
        bottom half is taken from the right eye image.  Both halves are 
        subsampled 2X vertically.
    </dd>
    <dt class="Description-1 Description">Side-by-Side</dt>
    <dd class="Description-1 Description">
        The left half of the stereogram is taken from the left eye image, and 
        the right half is taken from the right eye image.  Both halves are 
        subsampled 2X horizontally.
    </dd>
</dl>

<p>Most 3D TV&rsquo;s/monitors can be configured to decode at least one of 
these types of stereograms.  In order for this to work, however, the 3D 
drawing area must be full-screen.</p>



<h3 id="hd0017001004">17.1.4&nbsp;Selecting a Stereo Mode</h3>

<p>A particular stereo mode can be selected by setting the 
<code>VGL_STEREO</code> environment variable or by using the 
<code>-st</code> argument to <code>vglrun</code>.  See Section 
<a href="#VGL_STEREO" class="ref">20.1</a> for more details.</p>



<h2 id="hd0017002">17.2&nbsp;Transparent Overlays</h2>

<p><a name="overlays"></a></p>

<p>In the case of transparent overlays, VirtualGL completely bypasses its 
own GLX faker and uses indirect OpenGL rendering to draw to the 
transparent overlay using the 2D X server.  The underlay is still 
rendered on the 3D X server, read back, and sent to the 2D X server, as 
always.  Using indirect rendering to render the overlay is unfortunately 
necessary, because there is no reliable way to draw to an overlay using 
2D (X11) functions, there are severe performance issues (on some cards) 
with using <code>glDrawPixels()</code> to draw to the overlay, and there 
is no reasonable way to composite the overlay and underlay in a Pbuffer 
on the VirtualGL server.</p>

<p>The use of overlays is becoming more and more infrequent, and when they 
are used, it is generally only for drawing small, simple, static shapes 
and text. We have found that it is often faster to ship the overlay 
geometry over to the 2D X server rather than to render it as an image 
and send the image.  Thus, even if it were possible to implement 
overlays without using indirect rendering, it is likely that indirect 
rendering of overlays would still be the fastest approach for most 
applications.</p>

<p>As with quad-buffered stereo, overlays must be explicitly enabled in the 
graphics driver and X server configurations.  In the case of overlays, 
however, they need only be supported and enabled on the client machine 
and in the 2D X server.  Some graphics drivers are known to disallow 
using both quad-buffered stereo and overlays at the same time.</p>

<p>Indexed color (8-bit) overlays have been tested and are known to work 
with VirtualGL.  True color (24-bit) overlays work, in theory, but have 
not been tested.  Use <code>glxinfo</code> (see 
<a href="#Troubleshooting">Troubleshooting</a><a name="idx0047"></a> 
below) to verify whether your client&rsquo;s X display supports overlays 
and whether they are enabled.  In Exceed 3D, make sure that the 
&ldquo;Overlay Support&rdquo; option is checked in the &ldquo;Exceed 3D 
and GLX&rdquo; applet:</p>

<p><img src="exceed6.png" alt="exceed6" class="inline" id="imgid_4" name="imgid_4"/></p>



<h2 id="hd0017003">17.3&nbsp;Indexed (PseudoColor) Rendering</h2>

<p>In a PseudoColor visual, each pixel is represented by an index that 
refers to a location in a color table.  The color table stores the 
actual color values (256 of them in the case of 8-bit PseudoColor) that 
correspond to each index. An application merely tells the X server which 
color index to use when drawing, and the X server takes care of mapping 
that index to an actual color from the color table.  OpenGL allows for 
rendering to Pseudocolor visuals, and it does so by being intentionally 
ignorant of the relationship between indices and actual colors.  As far 
as OpenGL is concerned, each color index value is just a meaningless 
number, and it is only when the final image is drawn by the X server 
that these numbers take on meaning.  As a result, many pieces of 
OpenGL&rsquo;s core functionality either have undefined behavior or do 
not work at all with PseudoColor rendering.  PseudoColor rendering used 
to be a common technique for visualizing scientific data, because such 
data often only contained 8 bits per sample to begin with.  Applications 
could manipulate the color table to allow the user to dynamically 
control the relationship between sample values and colors.  As more and 
more graphics cards drop support for PseudoColor rendering, however, the 
applications that use it are becoming a vanishing breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor visual is 
available on the 2D X server or X proxy.  A PseudoColor visual need not 
be present on the application server.  On the application server, 
VirtualGL uses the red channel of a standard RGB Pbuffer to store the 
color index.  Upon receiving an end of frame trigger, VirtualGL reads 
back the red channel of the Pbuffer and uses <code>XPutImage()</code> to 
draw the color indices into the appropriate X window.  To put this 
another way, PseudoColor rendering in VirtualGL always uses the X11 
Transport.  However, since there is only 1 byte per pixel in a 
PseudoColor &ldquo;image&rdquo;, the images can still be sent to the 
client reasonably quickly even though they are uncompressed.</p>

<p>VirtualGL&rsquo;s PseudoColor rendering mode works with X proxies, 
provided that the X proxy provides a PseudoColor visual.  Note, however, 
that some X proxies, such as VNC, cannot provide both PseudoColor and 
TrueColor visuals at the same time.</p>



<h2 id="hd0017004">17.4&nbsp;Troubleshooting</h2>

<p><a name="Troubleshooting"></a></p>

<p>VirtualGL includes a modified version of <code>glxinfo</code> that can 
be used to determine whether or not the client and server have stereo, 
overlay, or Pseudocolor visuals enabled.</p>

<p>Run the following command sequence on the VirtualGL server to determine 
whether the 3D X server has a suitable visual for stereographic 
rendering:</p>

<pre class="verbatim">
xauth&nbsp;merge&nbsp;/etc/opt/VirtualGL/vgl_xauth_key
/opt/VirtualGL/bin/glxinfo&nbsp;-display&nbsp;:{n}&nbsp;-c&nbsp;-v
</pre>

<p>(where <code>{n}</code> is the display number of the 3D X server.)  One 
or more of the visuals should say &ldquo;stereo=1&rdquo; and should list 
&ldquo;Pbuffer&rdquo; as one of the &ldquo;Drawable Types.&rdquo;</p>

<p>Run the following command sequence on the VirtualGL server to determine 
whether the 2D X server has a suitable visual for stereographic 
rendering, transparent overlays, or Pseudocolor.</p>

<pre class="verbatim">
/opt/VirtualGL/bin/glxinfo&nbsp;-v
</pre>

<p>In order to use stereo, one or more of the visuals should say 
&ldquo;stereo=1&rdquo;. In order to use transparent overlays, one or 
more of the visuals should say &ldquo;level=1&rdquo;, should list a 
&ldquo;Transparent Index&rdquo; (non-transparent visuals will say 
&ldquo;Opaque&rdquo; instead), and should have a class of 
&ldquo;PseudoColor.&rdquo;  In order to use PseudoColor (indexed) 
rendering, one of the visuals should have a class of 
&ldquo;PseudoColor.&rdquo;</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0018"><a name="file018"></a>18&nbsp;Performance Measurement</h1>

<p><a name="Perf_Measurement"></a></p>


<h2 id="hd0018001">18.1&nbsp;VirtualGL&rsquo;s Built-In Profiling System</h2>

<p>The easiest way to uncover bottlenecks in VirtualGL&rsquo;s image 
pipeline is to set the <code>VGL_PROFILE</code> environment variable to 
<code>1</code> on both server and client (passing an argument of 
<code>+pr</code> to <code>vglrun</code> on the server has the same 
effect.)  This will cause VirtualGL to measure and report the throughput 
of the various stages in the pipeline.  For example, here are some 
measurements from a dual Pentium 4 server communicating with a Pentium 
III client on a 100 Megabit LAN:</p>

<dl class="Description">
    <dt class="Description-1 Description">Server</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
Readback&nbsp;&nbsp;&nbsp;-&nbsp;43.27&nbsp;Mpixels/sec&nbsp;-&nbsp;34.60&nbsp;fps
Compress&nbsp;0&nbsp;-&nbsp;33.56&nbsp;Mpixels/sec&nbsp;-&nbsp;26.84&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.02&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.41&nbsp;fps&nbsp;-&nbsp;10.19&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
    <dt class="Description-1 Description">Client</dt>
    <dd class="Description-1 Description">
<pre class="verbatim">
Decompress&nbsp;-&nbsp;10.35&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;8.28&nbsp;fps
Blit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;35.75&nbsp;Mpixels/sec&nbsp;-&nbsp;28.59&nbsp;fps
Total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;8.00&nbsp;Mpixels/sec&nbsp;-&nbsp;&nbsp;6.40&nbsp;fps&nbsp;-&nbsp;10.18&nbsp;Mbits/sec&nbsp;(18.9:1)
</pre>

    </dd>
</dl>

<p>The total throughput of the pipeline is 8.0 Megapixels/sec, or 6.4 
frames/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels in 
size (a little less than 1280 x 1024 pixels.)  The readback and compress 
stages, which occur in parallel on the server, are obviously not slowing 
things down, and we&rsquo;re only using 1/10 of our available network 
bandwidth.  Looking at the client, however, we discover that its slow 
decompression speed (10.35 Megapixels/second) is the primary bottleneck.  
Decompression and blitting on the client cannot be done in parallel, so 
the aggregate performance is the harmonic mean of the decompression and 
blitting rates:  <em>[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec</em>. In 
this case, we could improve the performance of the whole system by 
simply using a client with a faster CPU.</p>



<h2 id="hd0018002">18.2&nbsp;Frame Spoiling</h2>

<p><a name="Frame_Spoiling"></a></p>

<p>By default, VirtualGL will only send a frame to the client if the client 
is ready to receive it.  If a rendered frame arrives at the 
server&rsquo;s queue and there are frames waiting in the queue to be 
processed, then those unprocessed frames are dropped 
(&ldquo;spoiled&rdquo;) and the new frame is promoted to the head of the 
queue.  This prevents a backlog of frames on the server, which would 
cause a perceptible delay in the responsiveness of interactive 
applications.  However, when running non-interactive applications, 
particularly benchmarks, frame spoiling should always be disabled.   
With frame spoiling disabled, the server will render frames only as 
quickly as VirtualGL can send those frames to the client, which will 
conserve server resources as well as allow OpenGL benchmarks to 
accurately measure the frame rate of the VirtualGL system.  With frame 
spoiling enabled, OpenGL benchmarks will report meaningless data, since 
the rate at which the server can render frames is decoupled from the 
rate at which VirtualGL can send those frames to the client.</p>

<p>In a VNC environment, there is another layer of frame spoiling, since 
the server only sends updates to the client when the client requests 
them.  Thus, even if frame spoiling is disabled in VirtualGL, OpenGL 
benchmarks will still report inaccurate data if they are run in a VNC 
session.  TCBench, described below, provides a limited solution to this 
problem.</p>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code> environment 
variable to <code>0</code> on the VirtualGL server or pass an argument 
of <code>-sp</code> to <code>vglrun</code>.  See Section 
<a href="#VGL_SPOIL" class="ref">20.1</a> for more details.</p>



<h2 id="hd0018003">18.3&nbsp;VirtualGL Diagnostic Tools</h2>

<p>VirtualGL includes several tools that can be useful in diagnosing 
performance problems with the system.</p>


<h3 id="hd0018003001">NetTest</h3>

<p>NetTest is a network benchmark that uses the same network I/O classes as 
VirtualGL.  It can be used to test the latency and throughput of any 
TCP/IP connection, with or without SSL encryption.  <code>nettest</code> 
can be found in <code>/opt/VirtualGL/bin</code> on Linux/Unix/Mac/Cygwin 
VirtualGL installations or in 
<code>c:\program&nbsp;files\VirtualGL-</code><em><code>{version}</code></em><code>-</code><em><code>{build}</code></em> 
if using the VirtualGL Client for Exceed.</p>

<p>To use NetTest, first start up the NetTest server on one end of the 
connection:</p>

<pre class="verbatim">
nettest&nbsp;-server&nbsp;[-ssl]
</pre>

<p>(Use <code>-ssl</code> if you want to test the performance of SSL 
encryption over this particular connection.  VirtualGL must have been 
compiled with OpenSSL support for this option to be available.)</p>

<p>Next, start the client on the other end of the connection:</p>

<pre class="verbatim">
nettest&nbsp;-client&nbsp;{server}&nbsp;[-ssl]
</pre>

<p>Replace <em><code>{server}</code></em> with the hostname or IP address 
of the machine where the NetTest server is running.  (Use 
<code>-ssl</code> if the NetTest server is running in SSL mode.  
VirtualGL must have been compiled with OpenSSL support for this option 
to be available.)</p>

<p>The NetTest client will produce output similar to the following:</p>

<pre class="verbatim">
TCP&nbsp;transfer&nbsp;performance&nbsp;between&nbsp;localhost&nbsp;and&nbsp;{server}:

Transfer&nbsp;size&nbsp;&nbsp;1/2&nbsp;Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Throughput
(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(msec)&nbsp;&nbsp;&nbsp;&nbsp;(MBytes/sec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Mbits/sec)
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093402&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.010210&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.085651
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.021846&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.183259
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.087504&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.043594&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.365697
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.088105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.086595&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.726409
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.090090&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.169373&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.420804
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.093893&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325026&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.726514
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.102289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.596693&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.005424
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.118493&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.030190&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.641863
256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.146603&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.665318&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.969704
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.205092&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.380790&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.971514
1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.325896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.996542&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25.136815
2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.476611&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.097946&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34.376065
4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.639502&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.108265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;51.239840
8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.033596&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.558565&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63.405839
16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.706110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.158259&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76.825049
32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.089896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.113608&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84.839091
65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.909509&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.576174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;88.719379
131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.453894&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.913319&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;91.547558
262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22.616389&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.053931&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;92.727094
524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44.882406&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.140223&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.450962
1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89.440702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.180592&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.789603
2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;178.536997&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.202160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.970529
4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;356.754396&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.212195&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;94.054712
</pre>

<p>We can see that the throughput peaks at about 94 megabits/sec, which is 
pretty good for a 100 Megabit connection.  We can also see that, for 
small transfer sizes, the round-trip time is dominated by latency.  The 
&ldquo;latency&rdquo; is the same thing as the one-way (1/2 round-trip) 
transit time for a zero-byte packet, which is about 93 microseconds in 
this case.</p>



<h3 id="hd0018003002">CPUstat</h3>

<p>CPUstat is available only for Linux and is installed in the same place 
as NetTest (<code>/opt/VirtualGL/bin</code>.)  It measures the average, 
minimum, and peak CPU usage for all processors combined and for each 
processor individually.  On Windows, this same functionality is provided 
in the Windows Performance Monitor, which is part of the operating 
system.  On Solaris, the same data can be obtained through 
<code>vmstat</code>.</p>

<p>CPUstat measures the CPU usage over a given sample period (a few 
seconds) and continuously reports how much the CPU was utilized since 
the last sample period.  Output for a particular sample looks something 
like this:</p>

<pre class="verbatim">
ALL&nbsp;:&nbsp;&nbsp;51.0&nbsp;(Usr=&nbsp;47.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;3.5)&nbsp;/&nbsp;Min=&nbsp;47.4&nbsp;Max=&nbsp;52.8&nbsp;Avg=&nbsp;50.8
cpu0:&nbsp;&nbsp;20.5&nbsp;(Usr=&nbsp;19.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;1.0)&nbsp;/&nbsp;Min=&nbsp;19.4&nbsp;Max=&nbsp;88.6&nbsp;Avg=&nbsp;45.7
cpu1:&nbsp;&nbsp;81.5&nbsp;(Usr=&nbsp;75.5&nbsp;Nice=&nbsp;&nbsp;0.0&nbsp;Sys=&nbsp;&nbsp;6.0)&nbsp;/&nbsp;Min=&nbsp;16.6&nbsp;Max=&nbsp;83.5&nbsp;Avg=&nbsp;56.3
</pre>

<p>The first column indicates what percentage of time the CPU was active 
since the last sample period (this is then broken down into what 
percentage of time the CPU spent running user, nice, and system/kernel 
code.)  &ldquo;ALL&rdquo; indicates the average utilization across all 
CPUs since the last sample period.  &ldquo;Min&rdquo;, 
&ldquo;Max&rdquo;, and &ldquo;Avg&rdquo; indicate a running minimum, 
maximum, and average of all samples since CPUstat was started.</p>

<p>Generally, if an application&rsquo;s CPU usage is fairly steady, you can 
run CPUstat for a bit and wait for the Max. and Avg. for the 
&ldquo;ALL&rdquo; category to stabilize, then that will tell you what 
the application&rsquo;s peak and average % CPU utilization is.</p>



<h3 id="hd0018003003">TCBench</h3>

<p>TCBench was born out of the need to compare VirtualGL&rsquo;s 
performance to that of other thin client software, some of which had 
frame spoiling features that couldn&rsquo;t be disabled.  TCBench 
measures the frame rate of a thin client system as seen from the 
client&rsquo;s point of view.  It does this by attaching to one of the 
client windows and continuously reading back a small area at the center 
of the window.  While this may seem to be a somewhat non-rigorous test, 
experiments have shown that if care is taken to ensure that the 
application is updating the center of the window on every frame (such as 
in a spin animation), TCBench can produce quite accurate results.  It 
has been sanity checked with VirtualGL&rsquo;s internal profiling 
mechanism and with a variety of system-specific techniques, such as 
monitoring redraw events on the client&rsquo;s windowing system.</p>

<p>TCBench can be found in <code>/opt/VirtualGL/bin</code> on 
Linux/Unix/Mac/Cygwin VirtualGL installations or in 
<code>c:\program&nbsp;files\VirtualGL-</code><em><code>{version}</code></em><code>-</code><em><code>{build}</code></em> 
if using the VirtualGL Client for Exceed.  Run <code>tcbench</code> from 
the command line, and it will prompt you to click in the window you want 
to benchmark.   That window should already have an automated animation 
of some sort running before you launch TCBench.  Note that GLXSpheres 
(see below) is an ideal benchmark to use with TCBench, since GLXSpheres 
draws a new sphere to the center of its window on every frame.</p>

<p>TCBench can also be used to measure the frame rate of applications that 
are running on the local display, although for extremely fast 
applications (those that exceed 80 fps on the local display), you may 
need to increase the sampling rate of TCBench to get accurate results.  
The default sampling rate of 100 samples/sec should be fine for 
measuring the throughput of VirtualGL and other thin client systems.</p>

<pre class="verbatim">
tcbench&nbsp;-?
</pre>

<p>lists the relevant command-line switches, which can be used to adjust 
the benchmark time, the sampling rate, and the x and y offset of the 
sampling area within the window.</p>



<h3 id="hd0018003004">GLXSpheres</h3>

<p>GLXSpheres is a benchmark that produces very similar images to 
nVidia&rsquo;s (long discontinued) SphereMark benchmark.  Back in the 
early days of VirtualGL&rsquo;s existence, it was discovered (quite by 
accident) that SphereMark was a pretty good test of VirtualGL&rsquo;s 
end-to-end performance, because that benchmark generated images with 
about the same proportion of solid color and similar frequency 
components to the images generated by volume visualization applications.</p>

<p>Thus, the goal of GLXSpheres was to create an open source Unix version 
of SphereMark (the original SphereMark was for Windows only) completely 
from scratch.  GLXSpheres does not use any code from the original 
benchmark, but it does attempt to mimic the image output of the original 
as closely as possible.  GLXSpheres lacks some of the advanced rendering 
features of the original, such as the ability to use vertex arrays, but 
since GLXspheres was primarily designed as a benchmark for VirtualGL, 
display lists are more than fast enough for that purpose.</p>

<p>GLXSpheres has some additional modes that its predecessor lacked, modes 
which are designed specifically to test the performance of various 
VirtualGL features:</p>

<dl class="Description">
    <dt class="Description-1 Description">Stereographic rendering (<code>glxspheres&nbsp;-s</code>)</dt>
    <dd class="Description-1 Description">
    </dd>
    <dt class="Description-1 Description">Color index rendering (<code>glxspheres&nbsp;-c</code>)</dt>
    <dd class="Description-1 Description">
        In color index mode, GLXSpheres will draw the spheres using an 8-bit 
        color map and will change the color map periodically.
    </dd>
    <dt class="Description-1 Description">Overlay rendering (<code>glxspheres&nbsp;-o</code>)</dt>
    <dd class="Description-1 Description">
        This renders text, a moving crosshair cursor, and a block of pixels to 
        an 8-bit transparent overlay while animating the spheres on the 
        underlay.  The color map of the overlay is changed periodically.
    </dd>
    <dt class="Description-1 Description">Immediate mode rendering (<code>glxspheres&nbsp;-m</code>)</dt>
    <dd class="Description-1 Description">
        Want to really see the benefit of VirtualGL?  Run 
        <code>glxspheres&nbsp;-m</code> over a remote X connection, then run 
        <code>vglrun&nbsp;-sp&nbsp;glxspheres&nbsp;-m</code> over the same 
        connection and compare. Immediate mode does not use display lists, so 
        when immediate mode OpenGL is rendered indirectly (over a remote X 
        connection), this causes every OpenGL command to be sent as a separate 
        network request to the X server &hellip; on every frame.  Many 
        applications do not use display lists (because the geometry they are 
        rendering is dynamic, or for other reasons), so this models how such 
        applications might perform when displayed remotely without VirtualGL.
    </dd>
    <dt class="Description-1 Description">Interactive mode (<code>glxspheres&nbsp;-i</code>)</dt>
    <dd class="Description-1 Description">
        In interactive mode, GLXSpheres will wait to draw a frame until it 
        receives a mouse event.  Continuously dragging the mouse in the window 
        should produce a steady frame rate, and this frame rate is a reasonable 
        model of the frame rate that you can achieve when running interactive 
        applications in VirtualGL.  Comparing this interactive frame rate 
        (<code>vglrun&nbsp;glxspheres&nbsp;-i</code>) with the non-interactive 
        frame rate (<code>vglrun&nbsp;-sp&nbsp;glxspheres</code>) allows you to 
        quantify the effect of X latency on the performance of interactive 
        applications in a VirtualGL environment.
    </dd>
</dl>

<p>GLXSpheres is installed in <code>/opt/VirtualGL/bin</code> on Linux and 
Unix VirtualGL servers.  64-bit VirtualGL packages name this program 
<code>glxspheres64</code> so as to allow both a 64-bit and a 32-bit 
version of GLXSpheres to be installed on the same system.</p>

<p><br /></p>

<hr class="break" />



<h1 id="hd0019"><a name="file019"></a>19&nbsp;The VirtualGL Configuration Dialog</h1>

<p><a name="Config_Dialog"></a></p>

<p>Several of VirtualGL&rsquo;s configuration parameters can be changed on 
the fly once a 3D application has been started.  This is accomplished by 
using the VirtualGL Configuration dialog, which can be popped up by 
holding down the <code>CTRL</code> and <code>SHIFT</code> keys and 
pressing the <code>F9</code> key while any one of the 3D 
application&rsquo;s windows is active.  This displays the following 
dialog box:</p>

<p><img src="configdialog.gif" alt="configdialog" class="inline" id="imgid_5" name="imgid_5"/></p>

<p>You can use this dialog to adjust various image compression and display 
parameters in VirtualGL.  Changes are communicated immediately to 
VirtualGL.</p>

<dl class="Description">
    <dt class="Description-1 Description">Image Compression (Transport)</dt>
    <dd class="Description-1 Description">
        This is a drop-down gadget with the following options: <br /><br /> 
        <em>None (X11 Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=proxy</code>. This option can be activated at any 
        time, regardless of which transport was active when VirtualGL started. 
        <br /><br /> <em>JPEG (VGL Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=jpeg</code>.  This option is only available if the 
        VGL Transport was active when VirtualGL started. <br /><br /> <em>RGB 
        (VGL Transport)</em> : equivalent to setting 
        <code>VGL_COMPRESS=rgb</code>.  This option is only available if the VGL 
        Transport was active when VirtualGL started. <br /><br /> <em>YUV (XV 
        Transport)</em> : equivalent to setting <code>VGL_COMPRESS=xv</code>.  
        This option is only available if the 2D X server has the X Video 
        extension and the X Video implementation supports the YUV420P (AKA 
        &ldquo;I420&rdquo;) pixel format. <br /><br /> <em>YUV (VGL 
        Transport)</em> : equivalent to setting <code>VGL_COMPRESS=yuv</code>.  
        This option is only available if the 2D X server has the X Video 
        extension, the X Video implementation supports the YUV420P (AKA 
        &ldquo;I420&rdquo;) pixel format, and the VGL Transport was active when 
        VirtualGL started. <br /><br /> See Section 
        <a href="#VGL_COMPRESS" class="ref">20.1</a> for more information about 
        the <code>VGL_COMPRESS</code> configuration option.
        <div class="important"><p class="important">
        If an image transport plugin is loaded, then this gadget&rsquo;s name changes to &ldquo;Image Compression&rdquo;, and it has options &ldquo;0&rdquo; through &ldquo;10&rdquo;.
        </p></div>
    </dd>
    <dt class="Description-1 Description">Chrominance Subsampling</dt>
    <dd class="Description-1 Description">
        This drop-down gadget is active only when using JPEG compression or an 
        image transport plugin.  It has the following options: <br /><br /> 
        <em>Grayscale</em> : equivalent to setting <code>VGL_SUBSAMP=gray</code> 
        <br /><br /> <em>1X</em> : equivalent to setting 
        <code>VGL_SUBSAMP=1x</code> <br /><br /> <em>2X</em> : equivalent to 
        setting <code>VGL_SUBSAMP=2x</code> <br /><br /> <em>4X</em> : 
        equivalent to setting <code>VGL_SUBSAMP=4x</code> <br /><br /> See 
        Section <a href="#VGL_SUBSAMP" class="ref">20.1</a> for more information 
        about the <code>VGL_SUBSAMP</code> configuration option.
        <div class="important"><p class="important">
        If an image transport plugin is loaded, then this gadget has two additional options, &ldquo;8X&rdquo; and &ldquo;16X&rdquo;.
        </p></div>
    </dd>
    <dt class="Description-1 Description">JPEG Image Quality</dt>
    <dd class="Description-1 Description">
        This slider gadget is active only when using JPEG compression or an 
        image transport plugin.  It is the equivalent of setting 
        <code>VGL_QUAL</code>.  See Section 
        <a href="#VGL_QUAL" class="ref">20.1</a> for more information about the 
        <code>VGL_QUAL</code> configuration option.
        <div class="important"><p class="important">
        If an image transport plugin is loaded, then this gadget&rsquo;s name changes to &ldquo;Image Quality&rdquo;.
        </p></div>
    </dd>
    <dt class="Description-1 Description">Connection Profile</dt>
    <dd class="Description-1 Description">
        This drop-down gadget is active only if the VGL Transport was active 
        when VirtualGL started.  It has the following options: <br /><br /> 
        <em>Low Qual (Low-Bandwidth Network)</em> : Sets the image compression 
        type to JPEG (VGL Transport), sets the Chrominance Subsampling to 4X, 
        and sets the JPEG Image Quality to 30. <br /><br /> <em>Medium Qual</em> 
        : Sets the image compression type to JPEG	(VGL Transport), sets the 
        Chrominance Subsampling to 2X, and sets the JPEG Image Quality to 80. 
        <br /><br /> <em>High Qual (High-Bandwidth Network)</em> : Sets the 
        image compression type to JPEG (VGL Transport), sets the Chrominance 
        Subsampling to 1X, and sets the JPEG Image Quality to 95.
    </dd>
    <dt class="Description-1 Description">Gamma Correction Factor</dt>
    <dd class="Description-1 Description">
        This floating point input gadget is the equivalent of setting 
        <code>VGL_GAMMA</code>.  This enables VirtualGL&rsquo;s internal gamma 
        correction system with the specified gamma correction factor.  See 
        Section <a href="#VGL_GAMMA" class="ref">20.1</a> for more information 
        about the <code>VGL_GAMMA</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Frame Spoiling</dt>
    <dd class="Description-1 Description">
        This toggle button is the equivalent of setting <code>VGL_SPOIL</code>.  
        See Section <a href="#Frame_Spoiling" class="ref">18.2</a> and Section 
        <a href="#VGL_SPOIL" class="ref">20.1</a> for more information about the 
        <code>VGL_SPOIL</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Interframe Comparison</dt>
    <dd class="Description-1 Description">
        This toggle button is the equivalent of setting 
        <code>VGL_INTERFRAME</code>.  See Section 
        <a href="#VGL_INTERFRAME" class="ref">20.1</a> for more information 
        about the <code>VGL_INTERFRAME</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Stereographic Rendering Method</dt>
    <dd class="Description-1 Description">
        This drop-down gadget has the following options: <br /><br /> <em>Send 
        Left Eye Only</em> : equivalent to setting <code>VGL_STEREO=left</code>. 
        <br /><br /> <em>Send Right Eye Only</em> : equivalent to setting 
        <code>VGL_STEREO=right</code> <br /><br /> <em>Quad-Buffered (if 
        available)</em> : equivalent to setting <code>VGL_STEREO=quad</code> 
        <br /><br /> <em>Anaglyphic (Red/Cyan)</em> : equivalent to setting 
        <code>VGL_STEREO=rc</code> <br /><br /> <em>Anaglyphic 
        (Green/Magenta)</em> : equivalent to setting <code>VGL_STEREO=gm</code> 
        <br /><br /> <em>Anaglyphic (Blue/Yellow)</em> : equivalent to setting 
        <code>VGL_STEREO=by</code> <br /><br /> <em>Passive (Interleaved)</em> : 
        equivalent to setting <code>VGL_STEREO=i</code> <br /><br /> <em>Passive 
        (Top/Bottom)</em> : equivalent to setting <code>VGL_STEREO=tb</code> 
        <br /><br /> <em>Passive (Side-by-Side)</em> : equivalent to setting 
        <code>VGL_STEREO=ss</code> <br /><br /> See Section 
        <a href="#VGL_STEREO" class="ref">20.1</a> for more information about 
        the <code>VGL_STEREO</code> configuration option.
    </dd>
    <dt class="Description-1 Description">Limit Frames/second</dt>
    <dd class="Description-1 Description">
        This floating point input gadget is the equivalent of setting 
        <code>VGL_FPS</code>.  See Section 
        <a href="#VGL_FPS" class="ref">20.1</a> for more information about the 
        <code>VGL_FPS</code> configuration option.
    </dd>
</dl>

<p>You can set the <code>VGL_GUI</code> environment variable to change the 
key sequence used to pop up the VirtualGL Configuration dialog.  If the 
default of <code>CTRL-SHIFT-F9</code> is not suitable, then set 
<code>VGL_GUI</code> to any combination of <code>ctrl</code>, 
<code>shift</code>, <code>alt</code>, and one of 
<code>f1,&nbsp;f2,...,&nbsp;f12</code> (these are not case sensitive.)  
For example:</p>

<pre class="verbatim">
export&nbsp;VGL_GUI=CTRL-F9
</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code> is 
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code> to 
<code>none</code>.</p>

<div class="important"><p class="important">
VirtualGL monitors the application&rsquo;s X event loop to determine whenever a particular key sequence has been pressed.  If an application is not monitoring key press events in its X event loop, then the VirtualGL Configuration dialog might not pop up at all.  There is unfortunately no workaround for this, but it should be a rare occurrence.
</p></div>

<p><br /></p>

<hr class="break" />



<h1 id="hd0020"><a name="file020"></a>20&nbsp;Advanced Configuration</h1>

<p><a name="Advanced_Configuration"></a></p>


<h2 id="hd0020001">20.1&nbsp;Server Settings</h2>

<p>You can control the operation of the VirtualGL faker in four different 
ways. Each method of configuration takes precedence over the previous 
method:</p>

<ol class="Ordered numeric">
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable globally (for instance, in 
        <code>/etc/profile</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable on a per-user basis (for 
        instance, in <code>~/.bashrc</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Setting a configuration environment variable only for the current shell 
        session (for instance, <code>export&nbsp;VGL_XXX={whatever}</code>)
    </li>
    <li class="Ordered-1 Ordered">
        Passing a configuration option as an argument to <code>vglrun</code>.  
        This effectively overrides any previous environment variable setting 
        corresponding to that configuration option.
    </li>
</ol>

<p></p>

<div class="important"><p class="important">
If &ldquo;Custom (if supported)&rdquo; is listed as one of the available Image Transports, then this means that image transport plugins are free to handle or ignore this option as they see fit.
</p></div>

<p><a name="VGL_ALLOWINDIRECT"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_ALLOWINDIRECT&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Allow applications to request an indirect OpenGL context</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">0 (all OpenGL contexts use direct rendering, unless rendering to a <a href="#overlays">transparent overlay</a><a name="idx0048"></a>)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, when VirtualGL maps a Pbuffer to a window and establishes an 
        OpenGL rendering context with the Pbuffer, it forces direct rendering to 
        be used with this context.  Some 3D applications erroneously try to 
        create indirect OpenGL contexts because they detect that the X display 
        is remote and assume that the 3D rendering commands will be sent over 
        the network.  Thus, VirtualGL normally forces all contexts to be direct 
        in order to prevent severe readback performance degradation with such 
        apps (even on modern 3D adapters, and even when the connection to the 3D 
        X server is local, <code>glReadPixels()</code> can perform very slowly 
        if an indirect OpenGL context is used.) <br /><br /> However, some 
        applications intentionally try to create indirect contexts so that these 
        contexts can be shared, and those apps may not work properly when the 
        contexts are forced to be direct.  For such apps, setting 
        <code>VGL_ALLOWINDIRECT</code> to <code>1</code> will cause VirtualGL to 
        honor the application&rsquo;s request for an indirect OpenGL context.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_CLIENT&nbsp;=&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-cl&nbsp;</code><em><code>{c}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{c}</code></em> = the hostname or IP address of the VirtualGL client</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically set by <code>vglconnect</code> or <code>vglrun</code></td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When using the VGL Transport, <code>VGL_CLIENT</code> should be set to 
        the hostname or IP address of the machine on which 
        <code>vglclient</code> is running. Normally, <code>VGL_CLIENT</code> is 
        set automatically by the <code>vglconnect</code> or <code>vglrun</code> 
        script, so don&rsquo;t override it unless you know what you&rsquo;re 
        doing.
    </dd>
</dl>

<p><a name="VGL_COMPRESS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_COMPRESS&nbsp;=&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;xv&nbsp;|&nbsp;yuv</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-c&nbsp;</code><em><code>proxy&nbsp;|&nbsp;jpeg&nbsp;|&nbsp;rgb&nbsp;|&nbsp;xv&nbsp;|&nbsp;yuv</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Set image transport and image compression type</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">(See description)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
         <em>proxy</em> = Send images uncompressed using the X11 Transport.  
         This is useful when displaying to a local 2D X server or X proxy (see 
         Section <a href="#X11_Proxy_Usage_Local" class="ref">9.1</a>.) 
         <br /><br /> <em>jpeg</em> = Compress images using JPEG and send using 
         the VGL Transport.  This is useful when displaying to a remote 2D X 
         server (see Chapter <a href="#VGL_Transport_Usage" class="ref">8</a>.) 
         <br /><br /> <em>rgb</em> = Encode images as uncompressed RGB and send 
         using the VGL Transport. This is useful when displaying to a remote 2D 
         X server or X proxy across a very fast network (see Section 
         <a href="#X11_Proxy_Usage_Remote" class="ref">9.2</a>.) <br /><br /> 
         <em>xv</em> = Encode images as YUV420P (planar YUV with 4X chrominance 
         subsampling) and display them to the 2D X server using the XV 
         Transport. This transport is designed for use with X proxies, such as 
         the Sun Ray Server Software, that support the X Video extension (see 
         Chapter <a href="#X_Video_Support" class="ref">10</a>.) <br /><br /> 
         <em>yuv</em> = Encode images as YUV420P, send using the VGL Transport, 
         and display on the client machine using the X Video extension.  This 
         greatly reduces the CPU usage on both server and client and uses only 
         about half the network bandwidth as RGB, but the use of 4X chrominance 
         subsampling does produce some visible artifacts (see Chapter 
         <a href="#X_Video_Support" class="ref">10</a>.) <br /><br /> If this 
         option is not specified, then the default is set as follows: 
         <br /><br /> If the <code>DISPLAY</code> environment variable begins 
         with <code>:</code> or <code>unix:</code>, then VirtualGL assumes that 
         the X display connection is local.  If it detects that the 2D X server 
         is a Sun Ray X Server instance, then it will default to using 
         <em>xv</em> compression.  Otherwise, it will default to <em>proxy</em> 
         compression. <br /><br /> If VirtualGL detects that the 2D X server is 
         remote, then it will default to using <em>yuv</em> compression if that 
         X server is a Sun Ray X Server instance or <em>jpeg</em> compression 
         otherwise.
        <div class="important"><p class="important">
        If an image transport plugin is being used, then you can set <code>VGL_COMPRESS</code> to any numeric value &gt;= 0 (Default value = 0.)  The plugin can choose to respond to this value as it sees fit.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_DEFAULTFBCONFIG"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_DEFAULTFBCONFIG&nbsp;=&nbsp;</code><em><code>{attrib_list}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{attrib_list}</code></em> = GLX attributes of the default FB config that VirtualGL uses if a 3D application does not call <code>glXChooseVisual()</code> to specify the 3D rendering attributes it desires</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">None</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL monitors the <code>glXChooseVisual()</code> function 
        and uses the parameters passed to that function to determine which 
        rendering attributes the 3D application desires.  VGL uses those 
        attributes to obtain a GLX FB config, and that FB config is mapped 
        internally to the visual that is returned to the 3D application.  The FB 
        config is also used when creating the Pbuffers that back the 
        application&rsquo;s 3D windows. <br /><br /> In rare cases, however, an 
        application may choose to implement its own visual selection mechanism 
        rather than calling <code>glXChooseVisual()</code>.  Such applications 
        will iterate through the list of X visuals and examine the 3D attributes 
        of each using <code>glXGetConfig()</code>.  The problem is that, whereas 
        in a &ldquo;normal&rdquo; GLX environment there would be a 1:1 
        correspondence between X visuals and GLX FB configs, in 
        VirtualGL&rsquo;s split rendering environment, X visuals are on the 2D X 
        server and GLX FB configs are on the 3D X server. Thus, if an 
        application calls <code>glXGetConfig()</code> before calling 
        <code>glXChooseVisual()</code>, VirtualGL has not yet mapped the X 
        visual in question to an FB config, and furthermore, VirtualGL has no 
        idea what type of visual the application is looking for.  In such cases, 
        VGL has to map the visual to a default FB config.  Since this default FB 
        config is very basic, if the application is hunting for a visual with a 
        particular parameter (such as an alpha channel or a stencil buffer), 
        then it may fail to find one. <br /><br /> This configuration option 
        allows the user to specify the 3D rendering attributes of 
        VirtualGL&rsquo;s default FB config, which may be necessary to make 
        certain applications work, if those applications do not use 
        <code>glXChooseVisual()</code> to obtain a visual.  The attribute list 
        is specified in the same way that you would specify arguments to 
        <code>glXChooseFBConfig()</code>. Example: 
        <code>VGL_DEFAULTFBCONFIG&nbsp;=&nbsp;GLX_ALPHA_SIZE,8,GLX_STENCIL_SIZE,8</code>.  
        See <a href="#Application_Recipes">Application 
        Recipes</a><a name="idx0049"></a> for a list of applications that are 
        known to require the use of this configuration option.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_DISPLAY&nbsp;=&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-d&nbsp;</code><em><code>{d}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{d}</code></em> = the X display to use for 3D rendering</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">:0</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If the VirtualGL server has multiple 3D graphics cards and you want the 
        OpenGL commands from the 3D application to be redirected to the second 
        or subsequent graphics cards in the system, then you can set 
        <code>VGL_DISPLAY</code> to (or invoke <code>vglrun&nbsp;-d</code> with) 
        <code>:0.1</code>, <code>:0.2</code>, etc.
    </dd>
</dl>

<p><a name="VGL_FORCEALPHA"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_FORCEALPHA&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Force the Pbuffers used for 3D rendering to have an 8-bit alpha channel</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>VGL_FORCEALPHA=1</code> if PBO readback mode is used, <code>VGL_FORCEALPHA=0</code> otherwise</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL will create a Pbuffer whose pixel format matches the 
        specifications of the visual requested by the 3D application. However, 
        on some 3D hardware, this may produce suboptimal performance when 
        reading back the 3D pixels.  Thus, this option can be used to force 
        VirtualGL to create a 32-bit-per-pixel Pbuffer when the application 
        requests a 24-bit-per-pixel visual. <br /><br /> On some 3D hardware, it 
        is necessary to use a 32-bit-per-pixel Pbuffer to realize any 
        performance improvement from the use of pixel buffer objects 
        (PBO&rsquo;s).  Thus, unless this option is explicitly disabled, it will 
        be enabled by default whenever PBO readback mode is enabled.  See the 
        <a href="#VGL_READBACK"><code>VGL_READBACK</code></a><a name="idx0050"></a> 
        option for further information.
        <div class="important"><p class="important">
        <code>VGL_FORCEALPHA</code> overrides the application&rsquo;s choice of visuals.  It has no effect if the application is not explicitly choosing a visual.  In that case, use <a href="#VGL_DEFAULTFBCONFIG"><code>VGL_DEFAULTFBCONFIG</code></a><a name="idx0051"></a> instead.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_FPS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_FPS&nbsp;=&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-fps&nbsp;</code><em><code>{f}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Limit the client/server frame rate to <em><code>{f}</code></em> frames/second, where <em><code>{f}</code></em> is a floating point number &gt; 0.0</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11, XV, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">0.0 (No limit)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        This option prevents VirtualGL from sending frames at a rate faster than 
        the specified limit.  It can be used, for instance, as a crude way to 
        control network bandwidth or CPU usage in multi-user environments where 
        those resources are constrained. <br /><br /> If frame spoiling is 
        disabled, then setting <code>VGL_FPS</code> effectively limits the 
        server&rsquo;s 3D rendering frame rate as well.
    </dd>
</dl>

<p><a name="VGL_GAMMA"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GAMMA&nbsp;=&nbsp;</code><em><code>{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-gamma&nbsp;</code><em><code>{g}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify gamma correction factor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1.00 (no gamma correction)</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        &ldquo;Gamma&rdquo; refers to the relationship between the intensity of 
        light that your computer&rsquo;s monitor is instructed to display and 
        the intensity that it actually displays.  The curve is an exponential 
        curve of the form <em>Y = X<sup>G</sup></em>, where X is between 0 and 
        1.  G is called the &ldquo;gamma&rdquo; of the monitor.  PC monitors and 
        TV&rsquo;s usually have a gamma of around 2.2. <br /><br /> Some of the 
        math involved in 3D rendering assumes a linear gamma (G = 1.0), so 
        technically speaking, 3D applications will not display with mathematical 
        correctness unless the pixels are &ldquo;gamma corrected&rdquo; to 
        counterbalance the non-linear response curve of the monitor.  However, 
        some systems do not have any form of built-in gamma correction, so the 
        applications developed for such systems have usually been designed to 
        display properly without gamma correction.  Gamma correction involves 
        passing pixels through a function of the form <em>X = 
        W<sup>1/G</sup></em>, where G is the &ldquo;gamma correction 
        factor&rdquo; and should be equal to the gamma of the monitor.  So, the 
        final output is <em>Y = X<sup>G</sup> = (W<sup>1/G</sup>)<sup>G</sup> = 
        W</em>, which describes a linear relationship between the intensity of 
        the pixels drawn by the application and the intensity of the pixels 
        displayed by the monitor. <br /><br /> If <code>VGL_GAMMA</code> is set 
        to an arbitrary floating point value, then VirtualGL performs gamma 
        correction internally using the specified value as the gamma correction 
        factor.  You can also specify a negative value to apply a 
        &ldquo;de-gamma&rdquo; function.  Specifying a gamma correction factor 
        of G (where G &lt; 0) is equivalent to specifying a gamma correction 
        factor of -1/G.
    </dd>
</dl>

<p><a name="VGL_GLFLUSHTRIGGER"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GLFLUSHTRIGGER&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable reading back and sending the front buffer contents whenever the 3D application calls <code>glFlush()</code> while rendering to the front buffer</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        <code>glFlush()</code> is a sort of &ldquo;asynchronous 
        synchronization&rdquo; command.  It flushes the OpenGL command buffers, 
        which generally has the effect of ensuring that the commands have been 
        delivered to the 3D hardware. However, unlike <code>glFinish()</code>, 
        <code>glFlush()</code> does not wait until the commands have been 
        rendered before it returns. <br /><br /> The use of 
        <code>glFlush()</code> can vary widely from application to application. 
        When doing front buffer rendering, some applications call 
        <code>glFlush()</code> after each object is rendered.  Some call it only 
        at the end of the frame.  Others call <code>glFlush()</code> much more 
        often, even as frequently as every time a few lines are drawn.  This 
        creates problems for VirtualGL, since it has to guess what the 
        application is intending to do.  Not all applications that use front 
        buffer rendering call <code>glFinish()</code> to signal the end of a 
        frame, so VirtualGL can&rsquo;t usually get away with ignoring 
        <code>glFlush()</code>.  However, some applications call 
        <code>glFlush()</code> so often that VirtualGL can&rsquo;t usually get 
        away with reading back/sending a frame every time <code>glFlush()</code> 
        is called, either (see 
        <a href="#VGL_SPOILLAST">VGL_SPOILLAST</a><a name="idx0052"></a> for 
        more information on how VirtualGL tries to handle this, under normal 
        circumstances.) <br /><br /> Some 3D applications use 
        <code>glFlush()</code> very liberally and intend for it to be an 
        intermediate rather than a final synchronization command.  Such 
        applications will call <code>glFinish()</code> after a sequence of 
        <code>glFlush()</code> calls, so for those applications, reading back 
        and sending the rendered 3D image in response to <code>glFlush()</code> 
        calls is a waste of resources and can sometimes create visual artifacts 
        (for instance, if the application clears the front buffer with a 
        particular color, calls <code>glFlush()</code>, then clears it again 
        with another color.  We wouldn&rsquo;t mention it if it hadn&rsquo;t 
        happened before.)  For such applications, setting 
        <code>VGL_GLFLUSHTRIGGER</code> to <code>0</code> should allow them to 
        display properly.  See <a href="#Application_Recipes">Application 
        Recipes</a><a name="idx0053"></a> for a list of applications that are 
        known to require this.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GLLIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate OpenGL library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL tries to call any &ldquo;real&rdquo; GLX and OpenGL 
        functions it needs from the OpenGL library against which it is linked 
        (usually <code>/usr/lib/libGL.so.1</code>, 
        <code>/usr/lib64/libGL.so.1</code>,  or 
        <code>/usr/lib/64/libGL.so.1</code>).  Failing this, VirtualGL will then 
        try to call these functions from the first compatible library named 
        <code>libGL.so.1</code> that is found in the dynamic loader path.  You 
        can use the <code>VGL_GLLIB</code> environment variable to override this 
        behavior and specify a dynamic library from which VirtualGL will call 
        the &ldquo;real&rdquo; GLX and OpenGL functions. <br /><br /> You 
        shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t 
        work.  However, setting this environment variable is necessary when 
        using VirtualGL with 
        <a href="#Chromium">Chromium</a><a name="idx0054"></a>.  It is also 
        potentially useful if one wishes to insert another OpenGL interposer 
        between VirtualGL and the system&rsquo;s OpenGL library.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_GUI&nbsp;=&nbsp;</code><em><code>{k}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{k}</code></em> = the key sequence used to pop up the VirtualGL Configuration dialog, or <code>none</code> to disable the dialog</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">shift-ctrl-f9</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        VirtualGL will normally monitor an application&rsquo;s X event queue and 
        pop up the VirtualGL Configuration dialog whenever 
        <code>CTRL-SHIFT-F9</code> is pressed.  In the event that this 
        interferes with a key sequence that a 3D application is already using, 
        then you can redefine the key sequence used to pop up the VirtualGL 
        Configuration dialog by setting <code>VGL_GUI</code> to some combination 
        of <code>shift</code>, <code>ctrl</code>, <code>alt</code>, and one of 
        <code>f1,&nbsp;f2,&nbsp;...,&nbsp;f12</code>. You can also set 
        <code>VGL_GUI</code> to <code>none</code> to disable the configuration 
        dialog altogether.  See Chapter 
        <a href="#Config_Dialog" class="ref">19</a> for more details.
    </dd>
</dl>

<p><a name="VGL_INTERFRAME"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_INTERFRAME&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Enable or disable interframe image comparison</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG, RGB), Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The VGL Transport will normally compare each frame with the previous 
        frame and send only the portions of the image that have changed. Setting 
        <code>VGL_INTERFRAME</code> to <code>0</code> disables this behavior. 
        <br /><br /> This setting was introduced in order to work around a 
        specific application interaction issue, but since a proper fix for that 
        issue was introduced in VirtualGL 2.1.1, this option isn&rsquo;t really 
        useful anymore.
        <div class="important"><p class="important">
        When using the VGL Transport, interframe comparison is affected by the <a href="#VGL_TILESIZE"><code>VGL_TILESIZE</code></a><a name="idx0055"></a> option
        </p></div>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_LOG&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Redirect all messages from VirtualGL to a log file specified by <em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Print all messages to stderr</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Setting this environment variable to the pathname of a log file on the 
        VirtualGL server will cause VirtualGL to redirect all of its messages 
        (including profiling and trace output) to the specified log file rather 
        than to stderr.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_LOGO&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Enable or disable the display of a VGL logo in the 3D window</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Setting <code>VGL_LOGO</code> to <code>1</code> will cause VirtualGL to 
        display a small logo in the bottom right-hand corner of the 3D window.  
        This is meant as a debugging tool to allow users to determine whether or 
        not VirtualGL is active.
    </dd>
</dl>

<p><a name="VGL_NPROCS"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_NPROCS&nbsp;=&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-np&nbsp;</code><em><code>{n}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{n}</code></em> = the number of CPUs to use for multi-threaded compression</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG, RGB), Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The VGL Transport can divide the task of compressing each frame among 
        multiple server CPUs.  This might speed up the overall throughput in 
        rare circumstances where the server CPUs are significantly slower than 
        the client CPUs. <br /><br /> VirtualGL will not allow more than 4 
        processors total to be used for compression, nor will it allow you to 
        set this parameter to a value greater than the number of processors in 
        the system.
        <div class="important"><p class="important">
        When using the VGL Transport, multi-threaded compression is affected by the <a href="#VGL_TILESIZE"><code>VGL_TILESIZE</code></a><a name="idx0056"></a> option
        </p></div>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PIXMAP&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable the use of Pixmaps for 3D rendering</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL will redirect the 3D rendering from each OpenGL 
        window on the 2D X server into a corresponding Pbuffer on the 3D X 
        server, and it will likewise redirect the 3D rendering from each OpenGL 
        pixmap on the 2D X server into a corresponding Pixmap on the 3D X 
        server. Enabling this option causes VirtualGL to use pixmaps on the 3D X 
        server to represent all OpenGL drawables on the 2D X server.  This 
        option should be considered experimental and is only recommended for 
        systems on which Pbuffer support is incomplete or unstable.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-p&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = the TCP port to use when connecting to the VirtualGL Client</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Read from X property stored by VirtualGL Client</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The connection port for the VGL Transport is normally determined by 
        reading an X property that <code>vglclient</code> stores on the 2D X 
        server, so don&rsquo;t override this unless you know what you&rsquo;re 
        doing.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-pr</code> / <code>+pr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11, XV, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If profiling output is enabled, then VirtualGL will continuously 
        benchmark itself and periodically print out the throughput of various 
        stages in its image pipeline. <br /><br /> See Chapter 
        <a href="#Perf_Measurement" class="ref">18</a> for more details.
    </dd>
</dl>

<p><a name="VGL_QUAL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_QUAL&nbsp;=&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-q&nbsp;</code><em><code>{q}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{q}</code></em> = the JPEG compression quality, 1 &lt;= <em><code>{q}</code></em> &lt;= 100</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG), Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">95</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        In digital images, &ldquo;frequency&rdquo; refers to how quickly the 
        color changes between light and dark as you move either horizontally or 
        vertically in the image.  Images with very sharp, bright features on a 
        dark background, for instance, consist of both low-frequency and 
        high-frequency components, whereas images with smooth transitions 
        between neighboring pixels contain only low-frequency components.  JPEG 
        compression works by breaking down the image into its constituent 
        frequencies and then throwing out the highest of these frequencies.  The 
        JPEG image &ldquo;quality&rdquo; determines which frequencies are thrown 
        out.  A JPEG quality of 1 throws out all but the lowest frequencies and 
        thus produces a very impressionistic, but generally not very useful, 
        compressed image.  A JPEG quality of 100 retains all frequencies in the 
        original image (but, due to roundoff errors, the compressed image is 
        still not completely lossless.) <br /><br /> Because the human eye 
        usually can&rsquo;t detect the highest frequencies in the image, and 
        often because the image lacks those high-frequency elements to begin 
        with, a sufficiently high JPEG quality setting can produce a 
        &ldquo;perceptually lossless&rdquo; image.  A &ldquo;perceptually 
        lossless&rdquo; image contains a small amount of mathematical error when 
        compared to the original image, but this error is so small that, under 
        normal circumstances, the human visual system cannot distinguish it.  
        The threshold quality level at which JPEG compression becomes 
        perceptually lossless is different for each image, but experiments with 
        various visual difference benchmarks (such as 
        <span class="remote"><a class="remote" href="http://www.mpi-inf.mpg.de/resources/hdr/vdp/">HDR-VDP</a></span><a name="idx0057"></a>) 
        suggest that	a JPEG quality of 95 is sufficient to guarantee perceptual 
        losslessness for the types of applications (volume visualization apps, 
        in particular) in which image quality is critical.  As with any 
        benchmarks, Your Mileage May Vary. If image quality is of paramount 
        concern, consider setting the JPEG quality to 100 or using RGB encoding. 
        <br />
        <div class="important"><p class="important">
        If using an image transport plugin, then this setting need not necessarily correspond to JPEG image quality.  The plugin can choose to respond to the <code>VGL_QUAL</code> option as it sees fit.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_READBACK"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_READBACK&nbsp;=&nbsp;</code><em><code>none&nbsp;|&nbsp;pbo&nbsp;|&nbsp;sync</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the method used by VirtualGL to read back the 3D pixels from the 3D graphics hardware</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">sync</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
    </dd>
</dl>
<ul class="Itemize">
    <li class="Itemize-1 Itemize asterisk">
        <em>none</em> = Do not read back the 3D pixels at all.  On rare 
        occasions, it might be desirable to have VirtualGL redirect OpenGL 
        rendering from an application into a Pbuffer but not automatically read 
        back and send the rendered pixels.  Some applications have their own 
        mechanisms for reading back the rendered pixels, so setting 
        <code>VGL_READBACK=none</code> disables VirtualGL&rsquo;s readback 
        mechanism and prevents duplication of effort. <br /><br /> This option 
        was developed initially to support running 
        <span class="remote"><a class="remote" href="http://www.paraview.org/">ParaView</a></span><a name="idx0058"></a> 
        in parallel using MPI.  ParaView/MPI normally uses MPI processes 1 
        through N as rendering servers, each drawing a portion of the geometry 
        into a separate window on a separate X display. ParaView reads back 
        these server windows and composites the pixels into the main application 
        window, which is controlled by MPI process 0.  By creating a script that 
        passes a different value of <code>VGL_DISPLAY</code> and 
        <code>VGL_READBACK</code> to each MPI process, it is possible to make 
        all of the ParaView server processes render to off-screen buffers on 
        different graphics cards while preventing VirtualGL from displaying any 
        pixels except those generated by process 0. <br /><br /> This setting 
        can also be used to force Chromium to render into Pbuffers instead of 
        windows.  See Section <a href="#Force_Pbuffer" class="ref">14.2</a>. 
        <br /><br />
    </li>
    <li class="Itemize-1 Itemize asterisk">
        <em>pbo</em> = PBO readback mode.  Attempt to use pixel buffer objects 
        (PBO&rsquo;s) to accelerate the readback of the 3D pixels from the 3D 
        graphics card.  A PBO is an	opaque memory buffer managed by OpenGL, so 
        it can be locked down for direct DMA transfers.  This improves 
        performance as well as makes the pixel readback operation non-blocking.  
        However, the catch is that the pixel format requested in the pixel 
        readback operation must match the &ldquo;native&rdquo; pixel format of 
        the Pbuffer in order for PBO&rsquo;s to realize any performance benefit. 
        Otherwise, the 3D driver falls back to using the standard blocking pixel 
        readback operation. <br /><br /> Because the PBO is a managed buffer, 
        VirtualGL has to introduce an additional memory copy to transfer the 
        pixels out of the PBO and into the image transport&rsquo;s buffer.  On 
        high-end 3D hardware, PBO readback mode will generally perform better 
        than synchronous readback mode, even with this additional memory copy, 
        but there are a few platforms on which it performs worse, which is why 
        it is not enabled by default.  PBO&rsquo;s will significantly improve 
        performance on nVidia hardware when multiple users are sharing the GPU. 
        <br /><br /> VirtualGL will automatically fall back to synchronous 
        readback mode if it needs to read back pixels in a format other than the 
        native format of the Pbuffer.  This will generally be the case if 
        anaglyphic stereo is enabled, if RGB encoding is used with the VGL 
        Transport, or if the X11 Transport is used with a 2D X server whose 
        pixel format does not match that of the Pbuffer. Setting 
        <code>VGL_VERBOSE=1</code> will print a warning message whenever this 
        occurs. Since PBO&rsquo;s are not accelerated on some platforms unless 
        32-bit pixel formats are used, VirtualGL&rsquo;s default behavior is to 
        automatically create Pbuffers with 32 bits per pixel when PBO readback 
        mode is enabled (you can use the 
        <a href="#VGL_FORCEALPHA"><code>VGL_FORCEALPHA</code></a><a name="idx0059"></a> 
        option to override this.) <br /><br />
    </li>
    <li class="Itemize-1 Itemize asterisk">
        <em>sync</em> = Synchronous readback mode.  This disables the use of 
        PBO&rsquo;s altogether, which causes VirtualGL to always use blocking 
        pixel readback operations and to let the 3D driver perform any pixel 
        translation that is necessary.  This is the default behavior of 
        VirtualGL. <br /><br />
    </li>
</ul>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SAMPLES&nbsp;=&nbsp;</code><em><code>{s}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-ms&nbsp;</code><em><code>{s}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Force OpenGL multisampling to be enabled with <em><code>{s}</code></em> samples.  <em><code>{s}</code></em> = 0 to force OpenGL multisampling to be disabled.</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Allow the 3D application to determine the level of multisampling</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        This option was added primarily because certain vendor-specific methods 
        of enabling full-scene antialiasing at a global level (such as 
        nVidia&rsquo;s <code>__GL_FSAA_MODE</code> environment variable) do not 
        work with Pbuffers and, subsequently, do not work with VirtualGL.  If 
        <code>VGL_SAMPLES</code> is &gt; 0, then VirtualGL will attempt to 
        redirect 3D rendering to multisample-enabled Pbuffers with the specified 
        number (or a greater number) of samples.  This effectively forces the 3D 
        application to render with the specified multisampling level, as if the 
        application had explicitly passed parameters of 
        <code>GLX_SAMPLES</code>, <em><code>{s}</code></em> to 
        <code>glXChooseVisual()</code>. If <code>VGL_SAMPLES</code> is 
        <code>0</code>, then VirtualGL forces multisampling to be disabled, even 
        if the 3D application explicitly tries to enable it.
        <div class="important"><p class="important">
        <code>VGL_SAMPLES</code> overrides the application&rsquo;s choice of visuals.  It has no effect if the application is not explicitly choosing a visual.  In that case, use <a href="#VGL_DEFAULTFBCONFIG"><code>VGL_DEFAULTFBCONFIG</code></a><a name="idx0060"></a> instead.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_SPOIL"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SPOIL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sp</code> / <code>+sp</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable frame spoiling</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11, XV, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        In remote display environments, the mouse movement is generally sampled 
        at least 40 and sometimes 60 times per second.  Therefore, unless 
        VirtualGL is able to deliver at least this number of frames per second 
        to the client, the movement of a 3D scene will appear to drag behind the 
        mouse motion.  VirtualGL&rsquo;s default behavior is to compensate for 
        this by dropping frames.  This ensures that every mouse motion event 
        will result in a new frame being rendered on the server, even though not 
        all of these frames will actually be delivered to the client. 
        <br /><br /> Frame spoiling should produce the best results with 
        interactive applications, but it should be turned off when running 
        benchmarks or other non-interactive applications.  Turning off frame 
        spoiling will force every frame rendered on the server to be sent 
        through VirtualGL, and thus the frame rate reported by OpenGL benchmarks 
        will accurately reflect the frame rate of VirtualGL&rsquo;s image 
        pipeline (though, in X proxy environments, this may still not accurately 
        reflect the frame rate seen by the user.  See Section 
        <a href="#Frame_Spoiling" class="ref">18.2</a>.)  Disabling frame 
        spoiling also prevents non-interactive applications from wasting 
        graphics resources by rendering frames that will never be seen.
    </dd>
</dl>

<p><a name="VGL_SPOILLAST"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SPOILLAST&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable &ldquo;spoil last&rdquo; frame spoiling algorithm for frames triggered by <code>glFlush()</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11, XV, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Enabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        VirtualGL will commonly read back a rendered 3D image if the 3D 
        application calls <code>glXSwapBuffers()</code> while rendering to the 
        back buffer or if the 3D application calls <code>glFinish()</code>, 
        <code>glFlush()</code>, or <code>glXWaitGL()</code> while rendering to 
        the front buffer.  When frame spoiling is enabled and the frame queue is 
        busy compressing/sending a frame, the newly-rendered frame is normally 
        promoted to the head of the frame queue, and the rest of the frames in 
        the queue are &ldquo;spoiled&rdquo; (discarded.) This algorithm, called 
        &ldquo;spoil first&rdquo;,	ensures that when a frame is actually sent to 
        the client (rather than spoiled), the sent frame will be the most 
        recently rendered frame.  However, this algorithm requires that 
        VirtualGL read back every frame that the application renders, even if 
        the frame is ultimately discarded. <br /><br /> Some applications call 
        <code>glFlush()</code> many thousands of times per frame while rendering 
        to the front buffer.  Thus, VirtualGL&rsquo;s default behavior is to use 
        a different spoiling algorithm, &ldquo;spoil last&rdquo;, to process 
        frames triggered by <code>glFlush()</code> calls.  &ldquo;Spoil 
        last&rdquo; discards the most recently rendered frame if the frame queue 
        is busy.  Thus, the only frames that are read back from the graphics 
        card are the frames that are actually sent to the client. However, there 
        is no guarantee in this case that the frame sent to the client will be 
        the most recently rendered frame, so applications that perform front 
        buffer rendering and call <code>glFlush()</code> in response to an 
        interactive operation may not display properly.  For such applications, 
        setting the <code>VGL_SPOILLAST</code> environment variable to 
        <code>0</code> prior to launching the application with 
        <code>vglrun</code> will cause the &ldquo;spoil first&rdquo; algorithm 
        to be used for all frame triggers, including <code>glFlush()</code>.  
        This should fix the display problem, at the expense of increased load on 
        the graphics card (because VirtualGL is now reading back the rendered 3D 
        image every time <code>glFlush()</code> is called.)  See 
        <a href="#Application_Recipes">Application 
        Recipes</a><a name="idx0061"></a> for a list of applications that are 
        known to require this.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SSL&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-s</code> / <code>+s</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable SSL encryption of the image transport</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Enabling this option causes the VGL Transport to be tunneled through a 
        secure socket layer (SSL).
        <div class="important"><p class="important">
        This option has no effect unless both the VirtualGL server and client were built with OpenSSL support.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_STEREO"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_STEREO&nbsp;=&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc&nbsp;|&nbsp;gm&nbsp;|&nbsp;by&nbsp;|&nbsp;i&nbsp;|&nbsp;tb&nbsp;|&nbsp;ss</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-st&nbsp;</code><em><code>left&nbsp;|&nbsp;right&nbsp;|&nbsp;quad&nbsp;|&nbsp;rc&nbsp;|&nbsp;gm&nbsp;|&nbsp;by&nbsp;|&nbsp;i&nbsp;|&nbsp;tb&nbsp;|&nbsp;ss</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the delivery method for stereo images</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">quad</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
         <em>left</em> = When an application renders a stereo frame, send only 
         the left eye buffer <br /><br /> <em>right</em> = When an application 
         renders a stereo frame, send only the right eye buffer <br /><br /> 
         <em>quad</em> = Attempt to use quad-buffered stereo, which will result 
         in a pair of images being sent to the VirtualGL Client for every frame.  
         If using the VGL Transport and quad-buffered stereo is not available on 
         the client, or if using the X11 Transport, then fall back to using 
         anaglyphic stereo. Using quad-buffered stereo requires the VGL 
         Transport (or a transport plugin that can handle stereo image pairs.)  
         Using quad-buffered stereo with the VGL Transport also requires that 
         the 2D X server support OpenGL and be connected to a 3D accelerator 
         that supports stereo rendering.  Quad-buffered stereo is not supported 
         when using the VGL Transport with YUV encoding. <br /><br /> 
         <em>rc</em> = Use Red/Cyan (anaglyphic) stereo, even if quad-buffered 
         is available <br /><br /> <em>gm</em> = Use Green/Magenta (anaglyphic) 
         stereo, even if quad-buffered is available <br /><br /> <em>by</em> = 
         Use Blue/Yellow (anaglyphic) stereo, even if quad-buffered is available 
         <br /><br /> <em>i</em> = Use Interleaved (passive) stereo, even if 
         quad-buffered is available <br /><br /> <em>tb</em> = Use Top/Bottom 
         (passive) stereo, even if quad-buffered is available <br /><br /> 
         <em>ss</em> = Use Side-by-Side (passive) stereo, even if quad-buffered 
         is available <br /><br /> See Chapter 
         <a href="#Advanced_OpenGL" class="ref">17</a> for more details.
    </dd>
</dl>

<p><a name="VGL_SUBSAMP"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SUBSAMP&nbsp;=&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-samp&nbsp;</code><em><code>gray&nbsp;|&nbsp;1x&nbsp;|&nbsp;2x&nbsp;|&nbsp;4x&nbsp;|&nbsp;8x&nbsp;|&nbsp;16x</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the level of chrominance subsampling in the JPEG image compressor</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG), Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">1x</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When an image is encoded using JPEG, each pixel in the image is first 
        converted from RGB (Red/Green/Blue) to YUV.  An RGB pixel has three 
        values that specify the amounts of red, green, and blue that make up the 
        pixel&rsquo;s color.  A YUV pixel has three values that specify the 
        overall brightness of the pixel (Y, or &ldquo;luminance&rdquo;) and the 
        overall color of the pixel (U and V, or &ldquo;chrominance&rdquo;.) 
        <br /><br /> Since the human eye is less sensitive to changes in color 
        than it is to changes in brightness, the chrominance components for some 
        of the pixels can be discarded without much noticeable loss in image 
        quality.  This technique, called &ldquo;chrominance subsampling&rdquo;, 
        significantly reduces the size of the compressed image. <br /><br /> 
        <em>1x</em> = no chrominance subsampling <br /><br /> <em>2x</em> = 
        discard the chrominance components for every other pixel along the 
        image&rsquo;s X direction (this is also known as &ldquo;4:2:2&rdquo; or 
        &ldquo;2:1&rdquo; subsampling.) All else being equal, 2x subsampling 
        generally reduces the image size by about 20-25% when compared to no 
        subsampling.<br /> <br /> <em>4x</em> = discard the chrominance 
        components for every other pixel along both the X and Y directions of 
        the image (this is also known as &ldquo;4:2:0&rdquo; or 
        &ldquo;2:2&rdquo; subsampling.)   All else being equal, 4x subsampling 
        generally reduces the image size by about 35-40% when compared to no 
        subsampling. <br /><br /> <em>8x</em> = discard the chrominance 
        components for 3 out of every 4 pixels along the image&rsquo;s X 
        direction and half the pixels along the image&rsquo;s Y direction (this 
        is also known as &ldquo;4:1:0&rdquo; or &ldquo;4:2&rdquo; subsampling.)  
        <em>This option is available only when using an image transport plugin 
        that supports it.</em> <br /><br /> <em>16x</em> = discard the 
        chrominance components for 3 out of every 4 pixels along both the X and 
        Y directions of the image (this is also known as &ldquo;4:4&rdquo; 
        subsampling.)  <em>This option is available only when using an image 
        transport plugin that supports it.</em> <br /><br /> <em>gray</em> = 
        discard all chrominance components.  This is useful when running 
        applications (such as medical visualization applications) that are 
        already generating grayscale images. <br /><br /> Subsampling artifacts 
        are less noticeable with volume data, since it usually only contains 256 
        colors to begin with, but narrow, aliased lines and other sharp features 
        on a black background will tend to produce very noticeable artifacts 
        when subsampling is enabled. <br /><br /> The axis indicator from a 
        popular visualization app displayed with 1x, 2x, and 4x chrominance 
        subsampling (respectively):<br /> 
        <img src="444.gif" alt="444" class="inline" id="imgid_6" name="imgid_6"/><img src="422.gif" alt="422" class="inline" id="imgid_7" name="imgid_7"/><img src="411.gif" alt="411" class="inline" id="imgid_8" name="imgid_8"/> 
        <br />
        <div class="important"><p class="important">
        If using an image transport plugin, then this setting need not necessarily correspond to JPEG chrominance subsampling.  How the plugin responds to the <code>VGL_SUBSAMP</code> option is implementation-specific.
        </p></div>
    </dd>
</dl>

<p><a name="VGL_SYNC"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_SYNC&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-sync</code> / <code>+sync</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable strict 2D/3D synchronization</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL, X11, XV, Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL&rsquo;s operation is asynchronous from the point of 
        view of the application.  The application swaps the buffers or calls 
        <code>glFinish()</code> or <code>glFlush()</code> or 
        <code>glXWaitGL()</code>, and VirtualGL reads	back the framebuffer and 
        sends the pixels to the client&rsquo;s display &hellip; eventually. This 
        will work fine for the vast majority of applications, but it does not 
        strictly conform to the GLX spec.  Technically speaking, when an 
        application calls <code>glXWaitGL()</code> or <code>glFinish()</code>, 
        it is well within its rights to expect the 3D image to be immediately 
        available in the X window. Fortunately, very few applications actually 
        do expect this, but on rare occasions, an application may try to use 
        <code>XGetImage()</code> or other X11 functions to obtain a bitmap of 
        the pixels that were rendered by OpenGL. Enabling <code>VGL_SYNC</code> 
        is a somewhat extreme measure that may be needed to make such 
        applications work properly.  It was developed initially as a way to pass 
        the GLX conformance suite (<code>conformx</code>, specifically), but at 
        least one commercial application is known to require it as well (see 
        <a href="#Application_Recipes">Application 
        Recipes</a><a name="idx0062"></a>.)<br /><br />When 
        <code>VGL_SYNC</code> is enabled, every call to <code>glFinish()</code>, 
        <code>glXWaitGL()</code>, and <code>glXSwapBuffers()</code> will cause 
        the contents of the Pbuffer to be read back and <em>synchronously</em> 
        drawn into the application&rsquo;s window <em>using the X11 Transport 
        and no frame spoiling</em>.  The call to <code>glFinish()</code>, 
        <code>glXWaitGL()</code>, or <code>glXSwapBuffers()</code> will not 
        return until VirtualGL has verified that the pixels have been delivered 
        into the application&rsquo;s window.  As such, this mode can have 
        potentially dire effects on performance when used with a remote 2D X 
        server.  It is strongly recommended that <code>VGL_SYNC</code> be used 
        only in conjunction with an X proxy running on the same server as 
        VirtualGL.
        <div class="important"><p class="important">
        If an image transport plugin is being used, then VirtualGL does not automatically enable the X11 Transport or disable frame spoiling when <code>VGL_SYNC</code> is set.  This allows the plugin to handle synchronous image delivery as it sees fit (or to simply ignore this option.)
        </p></div>
    </dd>
</dl>

<p><a name="VGL_TILESIZE"></a></p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TILESIZE&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{t}</code></em> = the image tile size (<em><code>{t}</code></em> x <em><code>{t}</code></em> pixels) to use for multi-threaded compression and interframe comparison (8 &lt;= <em><code>{t}</code></em> &lt;= 1024)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">VGL (JPEG, RGB), Custom (if supported)</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">256</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, the VGL Transport will divide an OpenGL window into 
        equal-sized square tiles, compare each tile vs. the same tile in the 
        previous frame, then compress and send only the tiles that have changed 
        (assuming <a href="#VGL_INTERFRAME">interframe 
        comparison</a><a name="idx0063"></a> is enabled.)  The VGL Transport 
        will also divide up the task of compressing these tiles among the 
        available CPUs in a round robin fashion, if multi-threaded compression 
        is enabled (see 
        <a href="#VGL_NPROCS">VGL_NPROCS</a><a name="idx0064"></a>.) 
        <br /><br /> There are several tradeoffs that must be considered when 
        choosing a tile size: <br /><br /> <em>Parallel scalability:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            Smaller tiles can more easily be divided up among multiple CPUs. If 
            the 
            tile size if too large, then there may not be enough tiles to go 
            around.
        </li></ul> <br /> <em>Compression efficiency:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            There is a certain amount of fixed CPU overhead required when 
            compressing images, so compressing larger tiles makes more efficient 
            use 
            of the CPUs and increases the aggregate throughput of the compressor.
        </li></ul> <br /> <em>Inter-frame optimization:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            When using smaller tiles, there is more of a chance that a given 
            tile 
            will remain unchanged from frame to frame and thus not need to be 
            re-transmitted to the client.
        </li></ul> <br /> <em>Network efficiency:</em> 
        <ul class="Itemize"><li class="Itemize-0">
            Each tile has a certain amount of fixed overhead required to 
            represent 
            it on the network.  Thus, using smaller tiles will increase the 
            total 
            number of tiles per frame, which will increase the total network 
            usage.
        </li></ul> <br /> 256x256 was chosen as the default because, in 
        experiments, it provided the best balance between scalability and 
        efficiency on the platforms that VirtualGL supports.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRACE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-tr</code> / <code>+tr</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable tracing</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When tracing is enabled, VirtualGL will log all calls to the GLX and X11 
        functions it is intercepting, as well as the arguments, return values, 
        and execution times for those functions.  This is useful when diagnosing 
        interaction problems between VirtualGL and a particular OpenGL 
        application.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRANSPORT&nbsp;=&nbsp;</code><em><code>{t}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-trans&nbsp;</code><em><code>{t}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Use an image transport plugin</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">None</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If this option is specified, then VirtualGL will attempt to load an 
        image transport plugin contained in a dynamic library named 
        <code>libtransvgl_</code><em><code>{t}</code></em><code>.so</code> 
        located in the dynamic linker path.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_TRAPX11&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable VirtualGL&rsquo;s X11 error handler</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If an application does not install its own X11 error handler, then the 
        default X11 error handler is used.  The default X11 error handler will 
        cause the application to exit if an X11 error occurs.  Enabling the 
        <code>VGL_TRAPX11</code> option will cause VirtualGL to install its own 
        X11 error handler, which prints a warning message but allows the 
        application to continue running.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglrun</code> argument</td>
    <td class="standard"><code>-v</code> / <code>+v</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When verbose mode is enabled, VirtualGL will reveal some of the 
        decisions it makes behind the scenes, such as which code path it is 
        using to compress images, which type of X11 drawing it is using, etc.  
        This can be helpful when diagnosing performance problems.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_X11LIB&nbsp;=&nbsp;</code><em><code>{l}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{l}</code></em> = the location of an alternate X11 library</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Normally, VirtualGL tries to call any &ldquo;real&rdquo; X11 functions 
        it needs from the X11 library against which it is linked (usually 
        <code>/usr/lib/libX11.so.6</code>, <code>/usr/lib/64/libX11.so.6</code>, 
        <code>/usr/X11R6/lib/libX11.so.6</code>, or 
        <code>/usr/X11R6/lib64/libX11.so.6</code>). Failing this, VirtualGL will 
        then try to call these functions from the first compatible library named 
        <code>libX11.so.6</code> that is found in the dynamic loader path.  You 
        can use the <code>VGL_X11LIB</code> environment	variable to override 
        this behavior and specify a dynamic library from which VirtualGL will 
        call the &ldquo;real&rdquo; X11 functions. <br /><br /> You 
        shouldn&rsquo;t need to muck with this unless something doesn&rsquo;t 
        work.  However, it is potentially useful if one wishes to insert another 
        X11 interposer between VirtualGL and the system&rsquo;s X11 library.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_XVENDOR&nbsp;=&nbsp;</code><em><code>{v}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{v}</code></em> = a fake X11 vendor string to return when the application calls <code>XServerVendor()</code> or <code>ServerVendor()</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Image Transports</td>
    <td class="standard">All</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        Some applications expect the X11 vendor string to contain a particular 
        value, which the application (sometimes erroneously) uses to figure out 
        whether it is being displayed to a local or a remote X server. This 
        setting allows you to fool such applications into thinking that they are 
        being	displayed to a &ldquo;local&rdquo; X server rather than a remote 
        one.
    </dd>
</dl>



<h2 id="hd0020002">20.2&nbsp;Client Settings</h2>

<p>These settings control the VirtualGL Client, which is used only with the 
VGL Transport.  <code>vglclient</code> is normally launched 
automatically from <code>vglconnect</code> and should not require any 
further configuration except in exotic circumstances.  These settings 
are meant only for advanced users or those wishing to build additional 
infrastructure around VirtualGL.</p>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_DRAWMODE&nbsp;=&nbsp;</code><em><code>ogl&nbsp;|&nbsp;x11</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-gl</code> / <code>-x</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Specify the method used to draw pixels into the application window</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard"><code>x11</code></td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If the client machine has a 3D accelerator, then it may be faster in 
        some rare instances to draw pixels using OpenGL rather than using 2D 
        (X11) commands.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_LISTEN&nbsp;=&nbsp;</code><em><code>sslonly&nbsp;|&nbsp;nossl</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslonly</code> / <code>-nossl</code></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Accept only unencrypted or only SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Accept both SSL and unencrypted connections</td>
  </tr>
</table>
</div>


<div class="important"><p class="important">
This option is available only if the VirtualGL client was built with OpenSSL support.
</p></div>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_PORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-port&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for unencrypted connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The default behavior for <code>vglclient</code> is to first try 
        listening for unencrypted connections on port 4242, to maintain backward 
        compatibility with VirtualGL v2.0.x.  If port 4242 is not available, 
        then <code>vglclient</code> will try to find a free port in the range of 
        4200-4299.  If none of those ports is available, then 
        <code>vglclient</code> will request a free port from the operating 
        system. <br /><br /> Setting this option circumvents the automatic 
        behavior described above and causes <code>vglclient</code> to listen 
        only on the specified TCP port.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_PROFILE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable profiling output</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        If profiling output is enabled, then VirtualGL will continuously 
        benchmark itself and periodically print out the throughput of various 
        stages in its image pipelines. <br /><br /> See Chapter 
        <a href="#Perf_Measurement" class="ref">18</a> for more details.
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGLCLIENT_SSLPORT&nbsp;=&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard"><code>vglclient</code> argument</td>
    <td class="standard"><code>-sslport&nbsp;</code><em><code>{p}</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard"><em><code>{p}</code></em> = TCP port on which to listen for SSL connections from the VirtualGL server</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Automatically select a free port</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        The default behavior for <code>vglclient</code> is to first try 
        listening for SSL connections on port 4243, to maintain backward 
        compatibility with VirtualGL v2.0.x.  If port 4243 is not available, 
        then <code>vglclient</code> will try to find a free port in the range of 
        4200-4299.  If none of those ports is available, then 
        <code>vglclient</code> will request a free port from the operating 
        system. <br /><br /> Setting this option circumvents the automatic 
        behavior described above and causes <code>vglclient</code> to listen 
        only on the specified TCP port.
        <div class="important"><p class="important">
        This option is available only if the VirtualGL client was built with OpenSSL support.
        </p></div>
    </dd>
</dl>

<div class="table">
<table class="standard">
  <tr class="standard">
    <td class="high standard">Environment Variable</td>
    <td class="standard"><code>VGL_VERBOSE&nbsp;=&nbsp;</code><em><code>0&nbsp;|&nbsp;1</code></em></td>
  </tr>
  <tr class="standard">
    <td class="high standard">Summary</td>
    <td class="standard">Disable/enable verbose VirtualGL messages</td>
  </tr>
  <tr class="standard">
    <td class="high standard">Default Value</td>
    <td class="standard">Disabled</td>
  </tr>
</table>
</div>


<dl class="Description">
    <dt class="Description-1 Description">Description</dt>
    <dd class="Description-1 Description">
        When verbose mode is enabled, VirtualGL will reveal some of the 
        decisions it makes behind the scenes, such as which code path it is 
        using to decompress images, which type of X11 drawing it is using, etc.  
        This can be helpful when diagnosing performance problems.
    </dd>
</dl>

<p><br /></p>


</body>
</html>


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta content="text/html; charset=iso-8859-1" http-equiv="content-type">
  <title>VirtualGL User's Guide</title>


  <style type="text/css">
body {
background-color: rgb(255, 255, 255);
font-family: Arial,Helvetica,sans-serif;
}
a {
text-decoration: none;
}
dt {
font-weight: bold;
margin-left: 25px;
margin-top: 20px;
}
.valid {
border-width: 0px;
}
pre {
border: 1px solid rgb(0, 0, 255);
padding: 4px;
font-family: courier,monospace;
font-size: 14px;
background-color: rgb(238, 238, 255);
margin-left: 25px;
margin-right: 25px;
}
tr {
background-color: rgb(238, 238, 255);
color: rgb(32, 32, 32);
text-align: left;
}
th {
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
text-align: left;
}
td {
vertical-align: top;
text-align: left;
}
.colorheader {
padding: 2px;
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
margin-left: 3px;
margin-right: 3px;
font-weight: bold;
}
.newwin {
border-width: 0px;
}
.tip {
border: 1px solid rgb(0, 0, 0);
padding: 1px 5px;
font-weight: bold;
background-color: rgb(255, 255, 0);
margin-right: 10px;
}
.note {
border: 1px solid rgb(0, 0, 0);
padding: 1px 5px;
font-weight: bold;
background-color: blue;
color: rgb(255, 255, 255);
margin-right: 10px;
}
hr {
margin-bottom: 7px;
}
h2 {
padding: 5px;
color: rgb(255, 255, 255);
background-color: rgb(25, 25, 112);
}
h3 {
padding: 2px;
background-color: rgb(0, 0, 0);
color: rgb(255, 255, 255);
margin-left: 3px;
margin-right: 3px;
}
.top {
text-align: right;
}
  </style>
</head>


<body>

<h1>VirtualGL 2.0 User's Guide</h1>

<p><em>Intended audience:</em> System Administrators,
Graphics
Programmers,&nbsp;Researchers, and others with knowledge of the
Linux or Solaris
operating systems, OpenGL and GLX, and X windows. </p>

<h2>Contents</h2>

<ul>

  <li><a href="#legalinfo">Legal Information</a></li>

  <li><a href="#requirements">System Requirements</a></li>

  <li><a href="#linuxinstall">Installation (Linux)</a></li>

  <li><a href="#solarisinstall">Installation
(Solaris)</a></li>

  <li><a href="#windowsinstall">Installation
(Windows)</a></li>

  <li><a href="#basicusageunix">Basic Usage
(Linux/Solaris Client)</a></li>

  <li><a href="#basicusagewindows">Basic Usage
(Windows Client)</a></li>

  <li><a href="#solarisscripts">vglrun and Solaris
Shell Scripts</a></li>

  <li><a href="#glpusage">GLP Usage</a></li>

  <li><a href="#secureusage">Secure Usage</a></li>

  <li><a href="#vnc">Usage with VNC</a></li>

  <li><a href="#dynamicgl">Usage with Applications
That Manually Load OpenGL</a></li>

  <li><a href="#chromium">Usage with Chromium and
ModViz VGP<sup>TM</sup></a></li>

  <li><a href="#recipes">Application Recipes</a></li>

  <li><a href="#advancedopengl">Advanced OpenGL
Features</a></li>

  <li><a href="#perf">Performance Measurement</a></li>

  <li><a href="#configdialog">The VirtualGL
Configuration Dialog</a></li>

  <li><a href="#config">Advanced Configuration</a></li>

</ul>

<hr>
<h2><a name="legalinfo" id="legalinfo"></a>Legal
Information</h2>

<a rel="license" href="http://creativecommons.org/licenses/by/2.5/"><img alt="Creative Commons License" src="somerights20.png?rev=HEAD&amp;root=VirtualGL" border="0"> </a>
<p>This document and all associated illustrations are licensed
under the <a rel="license" href="http://creativecommons.org/licenses/by/2.5/">Creative
Commons Attribution 2.5 License</a>. &nbsp;Any works which
contain material
derived from this document must cite The VirtualGL Project as the
source of
the material and list the current URL for the VirtualGL web-site.</p>

<p>This product includes software developed by the OpenSSL
Project for use in
the OpenSSL Toolkit (<a href="http://www.openssl.org/">http://www.openssl.org/</a>.)&nbsp;
Further
information is contained in <a href="LICENSE-OpenSSL.txt"><code>LICENSE-OpenSSL.txt</code></a>,
which can be
found in the same directory as this documentation.&nbsp;</p>

<p>VirtualGL is licensed under the&nbsp;<a href="LICENSE.txt">wxWindows Library
License, v3</a>, a derivative of the <a href="LGPL.txt">LGPL</a>.</p>

<p align="right"><a href="#" target="_top">top</a></p>

<hr>
<h2><a name="requirements"></a>System
Requirements</h2>

<h3>Linux/x86</h3>

<table style="" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"></td>

      <td class="colorheader">Server (32-bit)</td>

      <td class="colorheader">Server (64-bit)</td>

      <td class="colorheader">Client (32-bit)</td>

    </tr>

    <tr>

      <td class="colorheader">CPU<br>

      </td>

      <td>Pentium 4, 1.7 GHz or faster (or equivalent)
      <ul>

        <li>For optimal performance, the processor should support
SSE2 extensions</li>

        <li>Dual processors recommended</li>

      </ul>

      </td>

      <td>Pentium 4/Xeon with EM64T, or<br>

AMD Opteron or Athlon64, 1.8 GHz or faster
      <ul>

        <li>For optimal performance with 64-bit VirtualGL, the
processor should support SSE3 extensions.&nbsp; Only newer AMD
64-bit processors (mid-2005 and later) support SSE3 </li>

        <li>Dual processors recommended</li>

      </ul>

      </td>

      <td>Pentium III or Pentium 4, 1.0 GHz or faster (or
equivalent)</td>

    </tr>

    <tr>

      <td class="colorheader">Graphics</td>

      <td>Decent 3D graphics accelerator
      <ul>

        <li>nVidia strongly recommended</li>

        <li>If using ATI,&nbsp;driver v8.14 or older
recommended. &nbsp;Newer ATI drivers have known issues which may
prevent them from working with VirtualGL</li>

        <li>For applications that use stereo, a high-end 3D
accelerator such as the nVidia Quadro is required on the server</li>

      </ul>

      </td>

      <td>Decent 3D graphics accelerator
      <ul>

        <li>nVidia strongly recommended</li>

        <li>If using ATI,&nbsp;driver v8.14 or older
recommended. &nbsp;Newer ATI drivers have known issues which may
prevent them from working with VirtualGL</li>

        <li>For applications that use stereo, a high-end 3D
accelerator such as the nVidia Quadro is required on the server</li>

      </ul>

      </td>

      <td>Graphics card with decent 2D performance
      <ul>

        <li>For applications that use stereo or transparent
overlays, a high-end 3D accelerator such as the nVidia Quadro is
required on the client</li>

      </ul>

      </td>

    </tr>

    <tr>

      <td class="colorheader">O/S</td>

      <td>
      <ul>

        <li>RedHat Linux 7.2 or newer (or equivalent), or</li>

        <li>SuSE Linux 9 or newer</li>

      </ul>

      </td>

      <td>
      <ul>

        <li>RedHat Enterprise Linux 3.0 or 4.0 (64-bit) or
equivalent (Works with&nbsp;<a href="http://www.whiteboxlinux.org/">WhiteBox</a>,
and <a href="http://www.centos.org/">CentOS</a>), or</li>

        <li>SuSE&nbsp;Linux 9 or newer</li>

      </ul>

      </td>

      <td>
      <ul>

        <li>RedHat Linux 7.2 or newer (or equivalent), or</li>

        <li>SuSE Linux 9 or newer</li>

      </ul>

      </td>

    </tr>

    <tr>

      <td class="colorheader">Other Software</td>

      <td>X server configured for true color (24/32-bit)</td>

      <td>X server configured for true color (24/32-bit)</td>

      <td>X server configured for true color (24/32-bit)</td>

    </tr>

  </tbody>
</table>

<h3>Linux/Itanium</h3>

<p>VirtualGL should build and run on Itanium Linux, but it has
not been
thoroughly tested. &nbsp;<a href="http://sourceforge.net/users/dcommander">Contact us</a>
if you
encounter any difficulties.
</p>

<h3>Solaris/Sparc</h3>

<table style="" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"></td>

      <td class="colorheader">Server (32/64-bit)</td>

      <td class="colorheader">Client (32-bit)</td>

    </tr>

    <tr>

      <td class="colorheader">CPU</td>

      <td>UltraSPARC III 900 MHz or faster
      <ul>

        <li>Dual processors recommended</li>

      </ul>

      </td>

      <td>UltraSPARC III 900 MHz or faster</td>

    </tr>

    <tr>

      <td class="colorheader">Graphics</td>

      <td>Decent 3D graphics accelerator
      <ul>

        <li>Tested with XVR-1200 and XVR-2500</li>

        <li>For applications that use stereo, a frame buffer
which supports stereo Pbuffers (such as the XVR-2xxx series "kfb") is
required on the server</li>

      </ul>

      </td>

      <td>Graphics card with decent 2D performance
      <ul>

        <li>For applications that use stereo or
transparent&nbsp;overlays, a high-end 3D accelerator
such&nbsp;as the XVR-1200 or XVR-2500 is required on the client</li>

      </ul>

      </td>

    </tr>

    <tr>

      <td class="colorheader">O/S</td>

      <td>Solaris 8 or higher</td>

      <td>Solaris 8 or higher</td>

    </tr>

    <tr>

      <td class="colorheader">Other Software</td>

      <td>
      <ul>

        <li><a href="http://www.sun.com/software/graphics/opengl/">Sun
OpenGL</a> 1.3 (<a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage">patches</a>
113886-31 and 113887-31 recommended) or Sun OpenGL 1.5.
&nbsp;OpenGL 1.5 or later required for GLP support </li>

        <li><a href="http://www.sun.com/processors/vis/mlib.html">Sun
mediaLib</a></li>

        <li>In order to use the SSL features of VirtualGL on
Solaris 8 or 9, Blastwave OpenSSL is required.&nbsp; Download and
install the package from <a href="http://www.blastwave.org/">http://www.blastwave.org</a></li>

        <li>X server configured for true color (24/32-bit) [if
not using GLP]</li>

      </ul>

      </td>

      <td>
      <ul>

        <li>The VirtualGL client will use OpenGL if installed.
&nbsp;This may produce better performance on some graphics cards,
such as the XVR-1200.</li>

        <li><a href="http://www.sun.com/processors/vis/mlib.html">Sun
mediaLib</a></li>

        <li>In order to use the SSL features of VirtualGL on
Solaris 8 or 9, Blastwave OpenSSL is required.&nbsp; Download and
install the package from <a href="http://www.blastwave.org/">http://www.blastwave.org</a></li>

        <li>X server configured for true color (24/32-bit)</li>

      </ul>

      </td>

    </tr>

  </tbody>
</table>

<h3>Solaris/x86</h3>

<table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"></td>

      <td class="colorheader">Server (32-bit)</td>

      <td class="colorheader">Server (64-bit)</td>

      <td class="colorheader">Client (32-bit)</td>

    </tr>

    <tr>

      <td class="colorheader">CPU<br>

      </td>

      <td>Pentium 4, 1.7 GHz or faster (or equivalent)<br>

      <ul>

        <li>For optimal performance, the processor should support
SSE2 extensions</li>

        <li> Dual processors recommended</li>

      </ul>

      </td>

      <td>Pentium 4/Xeon with EM64T, or<br>

AMD Opteron or Athlon64, 1.8 GHz or faster
      <ul>

        <li>Dual processors recommended</li>

      </ul>

      </td>

      <td>Pentium III or Pentium 4, 1.0 GHz or faster (or
equivalent)</td>

    </tr>

    <tr>

      <td class="colorheader">Graphics<br>

      </td>

      <td>nVidia 3D graphics accelerator
      <ul>

        <li>For applications that use stereo, a high-end 3D
accelerator such as the nVidia Quadro is required on the server<br>

        </li>

      </ul>

      </td>

      <td>nVidia 3D graphics accelerator
      <ul>

        <li>For applications that use stereo, a high-end 3D
accelerator such as the nVidia Quadro is required on the server</li>

      </ul>

      </td>

      <td>Graphics card with decent 2D performance<br>

      <ul>

        <li>For applications that use stereo or transparent
overlays, a high-end 3D accelerator such as the nVidia Quadro is
required on the client</li>

      </ul>

      </td>

    </tr>

    <tr>

      <td class="colorheader">O/S<br>

      </td>

      <td>Solaris 10 or higher</td>

      <td>Solaris 10 or higher</td>

      <td>Solaris 10 or higher</td>

    </tr>

    <tr>

      <td class="colorheader">Other Software<br>

      </td>

      <td>
      <ul>

        <li><a href="http://www.sun.com/processors/vis/mlib.html">Sun
mediaLib</a> 2.4</li>

        <li>X server configured for true color (24/32-bit)</li>

      </ul>

      </td>

      <td>
      <ul>

        <li><a href="http://www.sun.com/processors/vis/mlib.html">Sun
mediaLib</a> 2.4</li>

        <li><a href="http://sunsolve.sun.com/pub-cgi/show.pl?target=patchpage">Solaris
Patch</a> 118345-04 (or later)</li>

        <li>X server configured for true color (24/32-bit)</li>

      </ul>

      </td>

      <td>
      <ul>

        <li><a href="http://www.sun.com/processors/vis/mlib.html">Sun
mediaLib</a> 2.4</li>

        <li>X server configured for true color (24/32-bit)</li>

      </ul>

      </td>

    </tr>

  </tbody>
</table>

<p><span class="note">Note:</span>Solaris/x86
version 10 comes with mediaLib
pre-installed, but it is strongly recommended that you upgrade this
version
of mediaLib to at least 2.4. &nbsp;This will greatly increase
the&nbsp;JPEG
decompression performance in the VirtualGL client as well as the JPEG
compression performance for 32-bit apps on the VirtualGL server.</p>

<h3>Windows</h3>

<table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr class="colorheader">

      <td></td>

      <td class="colorheader">Client (32-bit)</td>

    </tr>

    <tr>

      <td class="colorheader">CPU<br>

      </td>

      <td>Pentium III or Pentium 4, 1.0 GHz or faster (or
equivalent)</td>

    </tr>

    <tr>

      <td class="colorheader">Graphics<br>

      </td>

      <td>Graphics card with decent 2D performance<br>

      <ul>

        <li>For applications that use stereo or
transparent&nbsp;overlays, a high-end 3D accelerator
such&nbsp;as the nVidia Quadro or 3DLabs Wildcat Realizm is
required on the client</li>

      </ul>

      </td>

    </tr>

    <tr>

      <td class="colorheader">O/S<br>

      </td>

      <td>Windows 2000 or XP</td>

    </tr>

    <tr>

      <td class="colorheader">Other Software<br>

      </td>

      <td>
      <ul>

        <li><a href="http://www.hummingbird.com/">Hummingbird</a>
Exceed 8 or newer<br>

          <br>

          <span class="note">Note:</span>Contact
Gary Romualdez of Hummingbird Ltd. [tel. (416) 496-6393 or
<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#103;&#97;&#114;&#121;&#46;&#114;&#111;&#109;&#117;&#97;&#108;&#100;&#101;&#122;&#64;&#104;&#117;&#109;&#109;&#105;&#110;&#103;&#98;&#105;&#114;&#100;&#46;&#99;&#111;&#109;">&#103;&#97;&#114;&#121;&#46;&#114;&#111;&#109;&#117;&#97;&#108;&#100;&#101;&#122;&#64;&#104;&#117;&#109;&#109;&#105;&#110;&#103;&#98;&#105;&#114;&#100;&#46;&#99;&#111;&#109;</a>]
for Exceed pricing information.<br>

&nbsp;<br>

        </li>

        <li>For applications that use stereo or transparent
overlays, Exceed 3D is required on the client</li>

        <li>Client desktop currently needs to be true color (24
or 32-bit)</li>

      </ul>

      </td>

    </tr>

  </tbody>
</table>

<br>

<p align="right"><a href="#" target="_top">top</a></p>

<hr>
<h2><a name="linuxinstall"></a>Installation
(Linux)<br>

</h2>

<h4>Installing TurboJPEG</h4>

<ol>

  <li>
    <p>Obtain the latest TurboJPEG RPM from the files area of <a href="http://sourceforge.net/projects/virtualgl">http://sourceforge.net/projects/virtualgl</a>.</p>

    <p><span class="note">Note:</span>.tgz
packages are provided for users of non-RPM platforms.&nbsp; You can
use <a href="http://www.kitenet.net/programs/alien/">alien</a>
to convert these into .deb packages if you prefer.&nbsp;</p>

  </li>

  <li>
    <p>Log in as root, cd to the directory where you downloaded
the RPM package, and issue the following command:</p>

    <pre>rpm -Uvh turbojpeg*.rpm<br></pre>

  </li>

</ol>

<h4>Installing VirtualGL</h4>

<ol>

  <li>
    <p>If you are using RedHat/CentOS Enterprise Linux 2.1, 3, or
4 or SuSE Linux 9, obtain one of the pre-built VirtualGL RPMs from the
files area of <a href="http://sourceforge.net/projects/virtualgl">http://sourceforge.net/projects/virtualgl</a>.</p>

    <p> The Enterprise Linux 2.1 RPM should (theoretically) also
work with&nbsp;RedHat Linux 7.2 and 7.3 (and maybe 7.1 if patched.)<br>

The Enterprise Linux 3 RPM should (theoretically) also
work with&nbsp;RedHat Linux 8 (patched), RedHat Linux 9, and Fedora
Core 1 &amp; 2.<br>

The Enterprise Linux 4 RPM should (theoretically) also
work with Fedora Core 3 &amp; 4.<br>

The SuSE Linux 9 RPM should (theoretically) also work with
SuSE 10.</p>

  </li>

  <li>
    <p>Log in as root, cd to the directory where you downloaded
the RPM package, and issue the following command:</p>

    <pre>rpm -Uvh VirtualGL*.rpm</pre>

  </li>

</ol>

<h4>Installing VirtualGL from Source</h4>

<p>If you are using an RPM-based distribution of Linux but there
isn't a
pre-built VirtualGL RPM that matches your distribution, then you can
build
your own RPM using the VirtualGL Source RPM (SRPM.)</p>

<ol>

  <li>
    <p>Obtain the VirtualGL SRPM from the files area of <a href="http://sourceforge.net/projects/virtualgl">http://sourceforge.net/projects/virtualgl</a>.</p>

  </li>

  <li>
    <p>Log in as root, cd to the directory where you downloaded
the SRPM, and issue the following commands:</p>

    <pre>rpm -i VirtualGL*.src.rpm<br>cd /usr/src/redhat/SPECS<br>rpmbuild -ba virtualgl.spec</pre>

    <p><span class="note">Note:</span>On SuSE,
cd to <code>/usr/src/packages/SPECS</code> instead.
&nbsp;Some versions of SuSE symlink this to <code>/usr/src/redhat/SPECS</code>.</p>

  </li>

  <li>
    <p>Sit back and watch the fun.</p>

  </li>

  <li>
    <p>If the build completes successfully, it will produce a
binary RPM in <code>/usr/src/redhat/RPMS/<var>{your_cpu_architecture}</var></code>
(or <code>/usr/src/packages/RPMS/<var>{your_cpu_architecture}</var></code>),
which you can install using the instructions from the previous section.</p>

  </li>

</ol>

<p>If you are using a non-RPM based distribution of Linux, then
log in as root,
download the VirtualGL source tarball, uncompress it, <code>cd
vgl</code>,&nbsp;and
type <code>make install</code>. &nbsp;Refer to <code>BUILDING.html</code>
in the&nbsp;source
directory for further details.</p>

<h3>Display Configuration (Server Only)</h3>

<p>VirtualGL requires access to display :0 (or to the display
specified in
the <code>VGL_DISPLAY</code> environment variable) so that
it
can create and
render to off-screen Pbuffers on the server's 3D graphics
card.&nbsp; Normally,
this is only possible if someone has logged into the server locally and
explicitly granted this permission by issuing</p>

<pre>xhost +localhost</pre>

<p>However, it is possible to configure the server such that this
permission
is automatically granted regardless of whether anyone is logged in
locally.</p>

<ol>

  <li>
    <p>If the server machine is configured to boot into runlevel
5 (graphical login), then temporarily shut down its X server by issuing</p>

    <pre>init 3</pre>

    <p> as root</p>

  </li>

  <li>
    <p>Log in as root from the text console.</p>

  </li>

  <li>
    <p>If the server machine is configured to boot into runlevel
3 (text login), then configure it to boot into a graphical login by
changing the first line of <code>/etc/inittab</code> from</p>

    <p><code>id:3:initdefault:</code></p>

    <p> to</p>

    <p><code>id:5:initdefault:</code></p>

  </li>

  <li>
    <p>If the server is running version 1.0-71xx or earlier of
the NVidia accelerated GLX drivers, follow the instructions in <code>/usr/share/doc/NVIDIA_GLX-1.0/README</code>
regarding setting the appropriate permissions for <code>/dev/nvidia*</code>.&nbsp;
This is not necessary with more recent versions of the driver.&nbsp;</p>

  </li>

  <li>
    <p>Add</p>

    <pre>xhost +localhost</pre>

    <p> at the top of the display manager's client startup
script.&nbsp; The location of this script varies depending on the
particular Linux distribution and display manager being used.&nbsp;
The following table lists some common locations for this file:</p>

    <table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">

      <tbody>

        <tr>

          <td class="colorheader"></td>

          <td class="colorheader">xdm or kdm</td>

          <td class="colorheader">gdm<small><br>

(default display manager on most Linux systems)</small></td>

        </tr>

        <tr>

          <td class="colorheader">RedHat 7/8/9<br>

Enterprise Linux 2.1/3</td>

          <td><code>/etc/X11/xdm/Xsetup_0</code><br>

          <br>

(replace "0" with the display number of the X server you are
configuring)</td>

          <td><code>/etc/X11/gdm/Init/Default</code><br>

          <br>

(usually this is just symlinked to <code>/etc/X11/xdm/Xsetup_0</code>)</td>

        </tr>

        <tr>

          <td class="colorheader">Enterprise Linux 4<br>

Fedora Core 1/2/3</td>

          <td><code>/etc/X11/xdm/Xsetup_0</code><br>

          <br>

(replace "0" with the display number of the X server you are
configuring)</td>

          <td><code>/etc/X11/gdm/Init/:0</code><br>

          <br>

(usually this is just symlinked to<code>/etc/X11/xdm/Xsetup_0</code>)</td>

        </tr>

        <tr>

          <td class="colorheader">SuSE/United Linux</td>

          <td><code>/etc/X11/xdm/Xsetup</code></td>

          <td><code>/etc/opt/gnome/gdm/Init/Default</code></td>

        </tr>

      </tbody>
    </table>

&nbsp;</li>

  <li>
    <p>If the server is running gdm (the factory default
on&nbsp;most Linux systems), then you'll need to set up gdm to
allow TCP connections to the X server. &nbsp;To do this, edit the <code>gdm.conf</code>
file and add the following line under the <code>[security]</code>
section (or change it if it already exists):</p>

    <pre>DisallowTCP=false</pre>

    <p> See the table below for the location of <code>gdm.conf</code>
on various systems.</p>

  </li>

  <li>
    <p>Unless you know that you absolutely need it, disable the
XTEST extension.&nbsp; Disabling XTEST eliminates a potential
security loophole opened up by Step 5, whereby an authenticated user on
the server could theoretically send key/mouse events into the server's
local display.&nbsp; Even with XTEST disabled, it is generally a
good idea to leave the server's local display logged out when not in
use.</p>

    <p>Disabling XTEST is accomplished by passing an argument of <code>-tst</code>
on the command line used to launch the X server.&nbsp; The location
of this command line varies depending on the particular Linux
distribution and display manager being used.&nbsp;&nbsp; The
following table lists some common locations:</p>

    <table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">

      <tbody>

        <tr>

          <td class="colorheader"></td>

          <td class="colorheader">xdm <br>

          </td>

          <td class="colorheader">gdm<br>

          <small>(default on most Linux systems)</small><br>

          </td>

          <td class="colorheader">kdm</td>

        </tr>

        <tr>

          <td class="colorheader">RedHat (or equivalent)</td>

          <td><code>/etc/X11/xdm/Xservers</code><br>

          </td>

          <td><code>/etc/X11/gdm/gdm.conf</code><br>

          </td>

          <td><code>/etc/X11/xdm/Xservers</code></td>

        </tr>

        <tr>

          <td class="colorheader">SuSE/United Linux</td>

          <td><code>/etc/X11/xdm/Xservers</code></td>

          <td><code>/etc/opt/gnome/gdm/gdm.conf</code></td>

          <td><code>/etc/opt/kde3/share/config/kdm/Xservers</code></td>

        </tr>

      </tbody>
    </table>

    <p>For xdm-style configuration files, add <code>-tst</code>
to the line corresponding to the display number you are configuring,
e.g.: </p>

    <pre>:0 local /usr/X11R6/bin/X :0 vt07 -tst<br></pre>

    <p> For gdm-style configuration files, add <code>-tst</code>
to all lines that appear to be X server command lines, e.g.:</p>

    <pre>StandardXServer=/usr/X11R6/bin/X -tst</pre>

    <pre>[server-Standard]<br>command=/usr/X11R6/bin/X -tst -audit 0</pre>

    <pre>[server-Terminal]<br>command=/usr/X11R6/bin/X -tst -audit 0 -terminate</pre>

    <pre>[server-Chooser]<br>command=/usr/X11R6/bin/X -tst -audit 0<br></pre>

  </li>

  <li>
    <p>Restart the X server by issuing</p>

    <pre>init 5</pre>

    <p> as root.</p>

  </li>

  <li>
    <p>You can check your work by running</p>

    <pre>xdpyinfo -display :0</pre>

    <p> In particular, make sure that XTEST doesn't show up in
the list of extensions if you disabled it above.&nbsp; If <code>xdpyinfo</code>
fails to run, then the permissions on Display :0 are probably still too
restrictive, meaning that the change in Step 5 didn't take for some
reason.</p>

  </li>

</ol>

<h3>Automatically Starting the Linux Client<br>

</h3>

<p>The VirtualGL Linux client can be configured to start
automatically whenever
an X Windows session starts. &nbsp;To do this, run</p>

<pre>vglclient_config -install</pre>

<p>as root.</p>

<p>Depending on your system configuration, this script will
either tweak the
<code>/etc/X11/xinit/xinitrc</code> file&nbsp;or create
a
link in
<code>/etc/X11/xinit/xinitrc.d</code> so that
the&nbsp;VirtualGL client will be
automatically started whenever any X Windows session is started.
&nbsp;Running
<code>vglclient_config -install</code> also adds a line to
<code>/etc/X11/gdm/PostSession/Default</code> (or the
equivalent for your system)
to terminate the client whenever you log out of the X Windows session.
&nbsp;This
is known to work on RedHat- and SuSE-compatible platforms that use the
Gnome
Display Manager (gdm.) &nbsp;It&nbsp;probably won't work
on&nbsp;other distributions and
display managers.</p>

<p>To remove the auto-start feature, run</p>

<pre>vglclient_config -remove</pre>

<p>as root.</p>

<p>If <code>vglclient_config</code> doesn't work on
your
system, then you can
edit the appropriate X11 session files so that</p>

<pre>/usr/bin/vglclient_daemon start</pre>

<p>runs whenever an X session starts and</p>

<pre>/usr/bin/vglclient_daemon stop</pre>

<p>runs whenever the session terminates.</p>

<p><code>vglclient_daemon</code> will only start <code>vglclient</code>
if it is not
already running, so starting the client in this manner guarantees that
there
will never be more than one copy of it running on the system.
&nbsp;<code>vglclient_daemon</code> should work on any
Linux platform that conforms to
the Linux Standard Base (LSB.)</p>

<p>If additional X displays are started by the same user (:1, :2,
etc.), this
will not cause additional VirtualGL client instances to
start.&nbsp; Only one
VirtualGL client instance is needed to talk to all active
displays.&nbsp; However,
it is important to note that all active displays on the client machine
need
to be running under the same user privileges as the VirtualGL client,
or they
need to grant permissions to localhost (<code>xhost +localhost</code>)
so that
the VirtualGL client can access them.</p>

<p>If you wish to change the default port that the client listens
on, you will
need to edit <code>/usr/bin/vglclient_daemon</code> and
pass
the appropriate
argument (<code>-port <var>&lt;port number&gt;</var></code>
or
<code>-sslport
<var>&lt;port
number&gt;</var></code>) on the <code>vglclient</code>
command line located in that
file.&nbsp; By default, the client will listen on port 4242 for
unencrypted
connections and port 4243 for SSL connections. </p>

<h3>Removing the Linux Client and Server</h3>

<p>As root, issue the following command:</p>

<pre>rpm -e VirtualGL</pre>

<p style="text-align: right;"><a href="#" target="_top">top</a></p>

<hr>
<h2><a name="solarisinstall"></a>Installation
(Solaris)<br>

</h2>

<ol>

  <li>
    <p>Obtain the latest VirtualGL package from the files area of
    <a href="http://sourceforge.net/projects/virtualgl">http://sourceforge.net/projects/virtualgl</a>.</p>

    <br>

  </li>

  <li>
    <p>Log in as root, cd to the directory where you downloaded
the package, and issue the following commands:</p>

    <pre>bzip2 -d SUNWvgl-<var>{version}</var>.pkg.bz2<br>pkgadd -d SUNWvgl-<var>{version}</var>.pkg</pre>

  </li>

  <li>
    <p>Select the <code>SUNWvgl</code> package
(usually
option 1) from the menu.</p>

  </li>

</ol>

<p><span class="note">Note:</span>VirtualGL
for Solaris
installs into
<code>/opt/SUNWvgl</code>.</p>

<h3>Display Configuration (Server Only)</h3>

<p><span class="note">Note:</span>If you plan
to use VirtualGL only in <a href="#glpusage">GLP mode</a>,
then you need only perform steps 3 and 4 of
the following.</p>

<p>When VirtualGL is being used in GLX mode, it requires access
to display :0
(or to the display specified in the <code>VGL_DISPLAY</code>
environment
variable) so that it can create and render to off-screen Pbuffers on
the
server's 3D graphics card.&nbsp; Normally, this is only possible if
someone has
logged into the server locally and explicitly granted this permission
by
issuing</p>

<pre>xhost +localhost</pre>

<p>However, it is possible to configure the server such that this
permission
is automatically granted regardless of whether anyone is logged in
locally.</p>

<ol>

  <li>
    <p>Log in as root.</p>

  </li>

  <li>
    <p>Temporarily shut down the X server by issuing</p>

    <pre>/etc/init.d/dtlogin stop</pre>

  </li>

  <li>
    <p>Edit <code>/etc/logindevperm</code> and
change
the
mode for the <code>/dev/mouse</code>, <code>/dev/kbd</code>,
    <code>/dev/sound/*</code>, and <code>/dev/fbs/*</code>
entries to <code>0666</code>.&nbsp; e.g.:</p>

    <pre>/dev/console&nbsp;&nbsp;&nbsp; 0666&nbsp;&nbsp;&nbsp; /dev/mouse:/dev/kbd<br>/dev/console&nbsp;&nbsp;&nbsp; 0666&nbsp;&nbsp;&nbsp; /dev/sound/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # audio devices<br>/dev/console&nbsp;&nbsp;&nbsp; 0666&nbsp;&nbsp;&nbsp; /dev/fbs/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # frame buffers</pre>

  </li>

  <li>
    <p>Issue the following commands:</p>

    <pre>chmod 666 /dev/mouse /dev/kbd /dev/fbs/*<br>chmod 666 /dev/sound/*</pre>

    <p><span class="note">Note:</span><code>/dev/sound/*</code>
may not exist if there are no sound drivers on your system.&nbsp;</p>

  </li>

  <li>
    <p>If the <code>/etc/dt/config </code>directory
does
not exist, create it.</p>

    <pre>mkdir -p /etc/dt/config</pre>

  </li>

  <li>
    <p>If <code>/etc/dt/config/Xsetup</code> does
not
exist, then copy the default <code>Xsetup</code> file from
    <code>/usr/dt/config</code>
to that location:</p>

    <pre>cp /usr/dt/config/Xsetup /etc/dt/config/Xsetup</pre>

  </li>

  <li>
    <p>Edit <code>/etc/dt/config/Xsetup</code>, and
add
the following lines to the bottom of the file:</p>

    <pre>xhost +localhost<br>xhost +`hostname`</pre>

  </li>

  <li>
    <p>If <code>/etc/dt/config/Xconfig</code> does
not
exist, then copy the default <code>Xconfig</code> file
from <code>/usr/dt/config</code>
to that location:</p>

    <pre>cp /usr/dt/config/Xconfig /etc/dt/config/Xconfig</pre>

  </li>

  <li>
    <p>Edit <code>/etc/dt/config/Xconfig</code>, and
add
(or uncomment) the following line:</p>

    <pre>Dtlogin*grabServer: False<br></pre>

    <p><span class="note">Note:</span>If the
system you are configuring as a VirtualGL server is also being used as
a Sun Ray server,&nbsp;then make these same modifications to <code>/etc/dt/config/Xconfig.SUNWut.prototype</code>.
&nbsp;Otherwise, the modifications you just made to&nbsp;<code>/etc/dt/config/Xconfig&nbsp;</code>will
be overwritten the next time the system is restarted.</p>

  </li>

  <li>
    <p>Unless you know that you absolutely need it, disable the
XTEST extension.&nbsp; Disabling XTEST eliminates a potential
security loophole opened up by Step 6, whereby an authenticated user on
the server could theoretically send key/mouse events into the server's
local display.&nbsp; Even with XTEST disabled, it is generally a
good idea to leave the server's local display logged out when not in
use.</p>

    <ol style="list-style-type: lower-alpha;">

      <li>
        <p>If <code>/etc/dt/config/Xservers</code>
does
not exist, then copy the default <code>Xservers</code>
file
from <code>/usr/dt/config</code> to that location: </p>

        <pre>cp /usr/dt/config/Xservers /etc/dt/config/Xservers</pre>

      </li>

      <li>
        <p>Edit <code>/etc/dt/config/Xservers</code>
and
add an argument of <code>-tst</code> to the line
corresponding
to the display number you are configuring, e.g.:</p>

        <pre>:0&nbsp; Local local_uid@console root /usr/openwin/bin/Xsun :0 -nobanner -tst<br></pre>

        <p><span class="note">Note:</span>If
the system
you are configuring as a VirtualGL server is also being used as a Sun
Ray server, then make these same modifications to <code>/etc/dt/config/Xservers.SUNWut.prototype</code>.
&nbsp;Otherwise, the modifications you just made to&nbsp;<code>/etc/dt/config/Xservers&nbsp;</code>will
be overwritten the next time the system is restarted.</p>

      </li>

    </ol>

  </li>

  <li>
    <p>Verify that <code>/etc/dt/config</code> and <code>/etc/dt/config/Xsetup</code>
can be executed by all users, and verify that <code>/etc/dt/config/Xconfig</code>
and <code>/etc/dt/config/Xservers</code> can be read by
all
users</p>

  </li>

  <li>
    <p>Restart the X server by issuing</p>

    <pre>/etc/init.d/dtlogin start</pre>

  </li>

  <li>
    <p>You can check your work by running </p>

    <pre>/usr/openwin/bin/xdpyinfo -display :0</pre>

    <p>In particular, make sure that XTEST doesn't show up in the
list of
extensions if you disabled it above.&nbsp; If <code>xdpyinfo</code>
fails to run, then the permissions on Display :0 are probably still too
restrictive, meaning that the change in Step 7 didn't take for some
reason.</p>

  </li>

</ol>

<h3>Removing the Solaris Client and Server</h3>

<p>As root, issue the following command:</p>

<pre>pkgrm SUNWvgl</pre>

<p>Answer "yes" when prompted.</p>

<p align="right">
<a href="#" target="_top">top</a><br>

</p>

<hr>
<h2><a name="windowsinstall"></a>Installation
(Windows)</h2>

<ol>

  <li>
    <p>Download the latest VirtualGL installer package from the
files area of <a href="http://sourceforge.net/projects/virtualgl">http://sourceforge.net/projects/virtualgl</a>.
The installer will usually be named <code>VirtualGL-<var>{version}</var>.exe</code>.</p>

  </li>

  <li>
    <p>Run the VirtualGL installer.&nbsp; The installation of
VirtualGL should be self-explanatory.&nbsp; The only configuration
option is the directory in which you want the files to be installed. </p>

  </li>

  <li>
    <p>Install Hummingbird Exceed if it isn't already installed.</p>

  </li>

  <li>
    <p>Add the Exceed path (e.g. <code>C:\Program
Files\Hummingbird\Connectivity\9.00\Exceed</code>) to your system
    <code>PATH</code>
environment if it isn't already there.</p>

  </li>

  <li>
    <p>Load Exceed XConfig (right-click on the Exceed taskbar
icon, then select&nbsp;<em>Tools--&gt;Configuration</em>.)</p>

  </li>

  <li>
    <p>Open the "X Server Protocol" applet in XConfig.</p>

    <p><span class="tip">Tip:</span>If you are
using
the "Classic View" mode of XConfig, open the "Protocol" applet instead.</p>

  </li>

  <li>
    <p>In the "X Server Protocol" applet, select the "Protocol"
tab and make sure that "Use 32 bits per pixel for true color" is <em>not</em>
checked.</p>

    <p><img alt="" src="exceed1.png?rev=HEAD&amp;root=VirtualGL"></p>

  </li>

  <li>
    <p>Click "Validate and Apply Changes."&nbsp; If XConfig
asks whether you want to perform a server reset, click "Yes." </p>

  </li>

  <li>
    <p>Open the "Other Server Settings" applet in XConfig.<br>

    </p>

    <p><span class="tip">Tip:</span>If you are
using
the "Classic View" mode of XConfig, open the "Performance" applet
instead.&nbsp;</p>

  </li>

  <li>
    <p>Select the "Performance" tab and make sure that "Default
Backing Store" is set to "None."</p>

    <p><img alt="" src="exceed3.png?rev=HEAD&amp;root=VirtualGL"></p>

  </li>

  <li>
    <p>Click "Validate and Apply Changes."&nbsp; If XConfig
asks whether you want to perform a server reset, click "Yes." </p>

  </li>

</ol>

<h3>Obtaining Optimal Performance with Exceed</h3>

<p>VirtualGL has the ability to take advantage of the MIT-SHM
extension in
Hummingbird Exceed to accelerate image drawing on Windows.
&nbsp;This can improve
the overall performance of the VirtualGL pipeline by as much as 20% in
some
cases.</p>

<p>The bad news is that this extension has some issues in earlier
versions
of
Exceed. &nbsp;If you are using Exceed 8 or 9, you will need to
obtain the
following patches from the Hummingbird support site:</p>

<table cellpadding="3">

  <tbody>

    <tr>

      <th>Product</th>

      <th>Patches Required</th>

      <th>How to Obtain</th>

    </tr>

    <tr>

      <td>Hummingbird Exceed 8.0</td>

      <td><code>hclshm.dll</code> v9.0.0.1 (or higher)<br>

      <code>xlib.dll</code> v9.0.0.3 (or higher)<br>

      <code>exceed.exe</code> 8.0.0.28 (or higher)</td>

      <td>
      <p>Download all patches from the <a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html">Hummingbird
support site</a>.</p>

      <span class="note">Note:</span>Hummingbird
WebSupport account required</td>

    </tr>

    <tr>

      <td>Hummingbird Exceed 9.0</td>

      <td><code>hclshm.dll</code> v9.0.0.1 (or higher)<br>

      <code>xlib.dll</code> v9.0.0.3 (or higher)<br>

      <code>exceed.exe</code> 9.0.0.9 or higher</td>

      <td>
      <p><code>exceed.exe</code> can be patched by
running Hummingbird Update</p>

      <p>All other patches must be downloaded from the <a href="http://connectivity.hummingbird.com/support/nc/exceed_patches.html">Hummingbird
support site</a>.</p>

      <span class="note">Note:</span>Hummingbird
WebSupport account required<br>

      </td>

    </tr>

  </tbody>
</table>

<p>No patches should be necessary for Exceed 10 and above.</p>

<p>Next, you need to enable the MIT-SHM extension in Exceed:</p>

<ol>

  <li>
    <p>Load Exceed XConfig (right-click on the Exceed taskbar
icon, then select&nbsp;<em>Tools--&gt;Configuration</em>.)</p>

  </li>

  <li>
    <p>Open the "X Server Protocol" applet in XConfig.</p>

    <p><span class="tip">Tip:</span>If you are
using
the "Classic View" mode of XConfig, open the "Protocol" applet instead.</p>

  </li>

  <li>
    <p>Select the "Extensions" tab and make sure that "MIT-SHM"
is
checked.</p>

    <p><img alt="" src="exceed2.png?rev=HEAD&amp;root=VirtualGL"> </p>

  </li>

  <li>
    <p>Click "Validate and Apply Changes."&nbsp; If XConfig
asks whether you want to perform a server reset, click "Yes."</p>

  </li>

</ol>

<h3>Secure Shell</h3>

<p>It is recommended that you use SSh (Secure Shell) to log in to
the
application server and launch applications.&nbsp; Some servers are
configured to
allow telnet and RSh access, but telnet and RSh both send passwords
unencrypted over the network and are thus being phased out in favor of
SSh.&nbsp;
If you already have <a href="http://www.cygwin.com">CygWin</a>
installed on
your Windows machine, then you can use the SSh client included in that
package.&nbsp; Otherwise, download and install <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/">PuTTY</a>.</p>

<h3><a name="installsvc"></a>Installing the
Windows Client as a Service</h3>

<p>The&nbsp;VirtualGL Windows Client can be installed as a
Windows service (and
subsequently removed) using the links provided in the "VirtualGL
Client"
start menu group.&nbsp; Once installed, the service can be started
from the
Services applet in the Control Panel (located under "Administrative
Tools")
or by invoking</p>

<pre>net start vglclient</pre>

<p>from a command prompt. &nbsp;The service can be
subsequently stopped by
invoking</p>

<pre>net stop vglclient</pre>

<p>If you wish to install the client as a service and have it
listen on a
port other than the default (4242 for unencrypted connections or 4243
for&nbsp;SSL
connections), then you will need to install the service manually from
the
command line.</p>

<pre>vglclient -?</pre>

<p>gives a list of the relevant command-line options.</p>

<p align="right"><a href="#" target="_top">top</a></p>

<hr>
<h2><a name="basicusageunix"></a>Basic Usage
(Linux/Solaris Client)</h2>

<ol>

  <li>
    <p>If you haven't&nbsp;made an X11 connection between the
application server and your client
machine since the last time you logged in, then you will need to grant
the application server permission to use your X display.&nbsp; You
can do this by typing:</p>

    <pre>xhost +<var>{server_machine_name_or_IP}</var></pre>

    <p>inside a shell.</p>

    <p><span class="note">Note:</span>You only
need to
do this once per login, not every time you use VirtualGL.</p>

  </li>

  <li>
    <p>If you have not installed the VirtualGL client as a
service
or if your client is a Solaris machine, then you will need to start the
client manually.&nbsp; To do this, run</p>

    <pre>vglclient<br></pre>

    <p>on Linux or</p>

    <pre>/opt/SUNWvgl/bin/vglclient<br></pre>

    <p>on Solaris.<br>

    </p>

  </li>

  <li>
    <p>Open a Secure Shell (SSh) session into the application
server:</p>

    <pre>ssh -l <var>{your_user_name} {server_machine_name_or_IP}</var></pre>

  </li>

  <li>
    <p>In the SSh session, set the <code>DISPLAY</code>
environment variable on the server to point back to the client machine.
&nbsp;e.g.:</p>

    <pre>export DISPLAY=<var>{client_machine_name_or_IP}</var>:0.0</pre>

    <p>or</p>

    <pre>setenv DISPLAY <var>{client_machine_name_or_IP}</var>:0.0</pre>

  </li>

  <li>In the SSh session, launch your 3D application using:<br>

    <pre>vglrun <var>[vglrun options] {application_executable_or_script} {arguments}</var><br></pre>

    <p>if the application server is running Linux or</p>

    <pre>/opt/SUNWvgl/bin/vglrun <var>[vglrun options] {application_executable_or_script} {arguments}</var><br></pre>

    <p>if the application server is running Solaris.</p>

    <p>Consult the <a href="#config">Advanced
Configuration</a>
section for more information on <code>vglrun</code>
command
line options.</p>

  </li>

</ol>

<h3>Troubleshooting</h3>

<p>It's generally a good idea to make sure that a regular X
application
(such as
xterm) can be remotely displayed from the application server to your
client
workstation prior to running VirtualGL. &nbsp;Some
versions of Linux (most
notably SuSE) ship from the factory with the X server configured such
that it
cannot accept remote TCP connections at all. &nbsp;If you are using
such a machine
as a VirtualGL client, it is recommended that you&nbsp;tunnel X11
through SSh as a
work-around (see the <a href="#secureusage">Secure Usage</a>
section for more
details on how to run VirtualGL in such an environment.)</p>

<p>
Advanced users may also wish to remove the <code>-nolisten tcp</code>
switch from
the X server command line on the client machine and restart the X
server.
&nbsp;Refer to the table below for the location of the X server
command line on
various distributions and display managers:</p>

<table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"></td>

      <td class="colorheader">xdm <br>

      </td>

      <td class="colorheader">gdm<br>

      <small>(default on most Linux systems)</small><br>

      </td>

      <td class="colorheader">kdm</td>

    </tr>

    <tr>

      <td class="colorheader">RedHat (or equivalent)</td>

      <td><code>/etc/X11/xdm/Xservers</code><br>

      </td>

      <td><code>/etc/X11/gdm/gdm.conf</code><br>

      </td>

      <td><code>/etc/X11/xdm/Xservers</code></td>

    </tr>

    <tr>

      <td class="colorheader">SuSE/United Linux</td>

      <td><code>/etc/X11/xdm/Xservers</code></td>

      <td><code>/etc/opt/gnome/gdm/gdm.conf</code></td>

      <td><code>/etc/opt/kde3/share/config/kdm/Xservers</code></td>

    </tr>

  </tbody>
</table>

<br>

<p align="right"><a href="#" target="_top">top</a></p>

<hr style="width: 100%; height: 2px;">
<h2><a name="basicusagewindows"></a>Basic
Usage (Windows Client)</h2>

<ol>

  <li>
    <p>If you have not installed the VirtualGL client as a
service, then you will need to start the client manually.&nbsp; To
do this, use the link provided in the VirtualGL Client start menu group.</p>

  </li>

  <li>
    <p>Make sure that Exceed is running.</p>

  </li>

  <li>
    <p>If you have never made X11 connections between the
application server and your client
machine&nbsp;before, then you will need to grant the
application server permission to use your X display. </p>

    <ol style="list-style-type: lower-alpha;">

      <li>
        <p>Launch Exceed XConfig (right-click on the Exceed
taskbar icon, then select&nbsp;<em>Tools--&gt;Configuration</em>.)</p>

      </li>

      <li>
        <p>Open the "Security, Access Control, and System
Administration" applet in XConfig.</p>

        <p><span class="tip">Tip:</span>If you
are
using the "Classic View" mode of XConfig, open the "Security" applet
instead.</p>

      </li>

      <li>
        <p>To have Exceed prompt you each time a host tries to
connect, set "Host Access Control List" to "Enabled."</p>

        <p><img alt="" src="exceed4.png?rev=HEAD&amp;root=VirtualGL"></p>

      </li>

      <li>
        <p>To allow only the hosts you specify to connect, set
"Host Access Control List" to "File" and click "Edit" to edit the file
and add entries to it.&nbsp; You should add the name or IP address
of the application server to this file, save the file, then exit the
editor.</p>

        <p><img alt="" src="exceed5.png?rev=HEAD&amp;root=VirtualGL"></p>

      </li>

      <li type="a">
        <p>Click "Validate and Apply
Changes."&nbsp; If XConfig asks whether you want to perform a
server reset, click "Yes."</p>

      </li>

    </ol>

    <p><span class="note">Note:</span>You need
only perform Step 3 once, not every time you launch the client.</p>

  </li>

  <li>
    <p>Open a Secure Shell (SSh) connection to the application
server: </p>

    <p><strong>CygWin users:</strong></p>

    <p>Open a new command prompt and type:</p>

    <pre>ssh -l {your_user_name} {server_machine_name_or_IP}</pre>

    <p><strong>PuTTY users:</strong></p>

    <ol style="list-style-type: lower-alpha;">

      <li>Launch PuTTY. </li>

      <li>Select the "Session" category. </li>

      <li>Set the "Protocol" to "SSH," then enter the host name
or IP address of the application server.
        <p><img alt="" src="putty1.png?rev=HEAD&amp;root=VirtualGL"></p>

      </li>

      <li>
        <p>Click "Open"</p>

      </li>

    </ol>

  </li>

  <li>
    <p>In the remote shell session, set the <code>DISPLAY</code>
environment variable on the server to point back to the client machine:</p>

    <pre>export DISPLAY=<var>{client_machine_name_or_IP}</var>:0.0<br></pre>

    <p>or</p>

    <pre>setenv DISPLAY <var>{client_machine_name_or_IP}</var>:0.0<br></pre>

    <br>

  </li>

  <li>
    <p>In the SSh session, launch your 3D application: </p>

    <pre>vglrun <var>[vglrun options] {application_executable_or_script} {arguments}</var><br></pre>

    <p>if the application server is running Linux or</p>

    <pre>/opt/SUNWvgl/bin/vglrun <var>[vglrun options] {application_executable_or_script} {arguments}</var><br></pre>

    <p>if the application server is running Solaris.</p>

    <p>Consult the <a href="#config">Advanced
Configuration</a>
section for more information on <code>vglrun</code>
command
line options.</p>

  </li>

</ol>

<p align="right"><a href="#" target="_top">top</a></p>

<hr>
<h2><a name="solarisscripts"></a><code>vglrun</code>
and
Solaris Shell Scripts</h2>

<p><code>vglrun</code>&nbsp;can be used to launch
either
binary executables or shell
scripts, but there are a few things to keep in mind when using
<code>vglrun</code> to launch a shell script on Solaris.
&nbsp;When you vglrun a shell
script, the VirtualGL faker library will be preloaded into every
executable
that the script launches. &nbsp;Normally this is innocuous, but if
the script
calls any executables that are setuid root, then Solaris will refuse to
load
those executables because you are attempting to preload a library
(VirtualGL)
that is not in a "secure path." &nbsp;Solaris keeps a tight lid on
what goes into
<code>/usr/lib</code> and <code>/lib</code>,
and by
default, it will only allow
libraries in those paths to be preloaded into an executable that is
setuid
root. &nbsp;Generally, 3rd party packages are verboden from
installing anything
into <code>/usr/lib</code> or <code>/lib</code>.
&nbsp;But you can use the <code>crle</code>
utility to add other directories to the operating system's list of
secure
paths. &nbsp;In the case of VirtualGL, you would issue (as root):</p>

<pre>crle -u -s /opt/SUNWvgl/lib<br>crle -64 -u -s /opt/SUNWvgl/lib/sparcv9<br></pre>

<p>
Or on Solaris/x86:</p>

<pre>crle -u -s /opt/SUNWvgl/lib<br>crle -64 -u -s /opt/SUNWvgl/lib/64<br></pre>

<p>
But please be aware of the security ramifications of this before you do
it.
&nbsp;You are essentially telling Solaris that you trust the
security and
stability of the VirtualGL code as much as you trust the security and
stability of the operating system. &nbsp;And while we're flattered,
we're not sure
that we're necessarily deserving of that accolade, so if you are in a
security critical environment, apply the appropriate level of paranoia
here.</p>

<p>
An easier and perhaps more secure approach is to simply edit the
application
script and have it issue <code>vglrun</code> only for the
executables that you
wish to run in the VirtualGL environment. &nbsp;But sometimes that
is not an
option.</p>

<p><code>vglrun</code> on Solaris has
two&nbsp;options that
are relevant to launching
scripts:</p>

<pre>vglrun -32 {script}</pre>

<p>
will preload VirtualGL only into 32-bit executables called by a script,
whereas</p>

<pre>vglrun -64 {script}</pre>

<p>
will preload VirtualGL only into 64-bit executables.</p>

<p align="right"><a href="#" target="_top">top</a></p>

<hr style="width: 100%; height: 2px;">
<h2><a name="glpusage"></a>GLP Usage</h2>

<p>Sun Microsystems has developed an extension to OpenGL called
GLP which
allows an application to directly access the rendering capabilities of
a 3D
graphics card even if there is no X display running on the
card.&nbsp; Apart from
greatly simplifying the process of setting up VirtualGL on a server,
GLP also
greatly improves&nbsp;the overall security of VirtualGL servers,
since it is no
longer necessary to grant every user access to display :0. &nbsp;In
addition,
GLP&nbsp;makes it quite simple to assign VirtualGL jobs to any
graphics pipe in a
multi-pipe system.<br>

</p>

<p>Version 2.0 of VirtualGL for Sparc/Solaris supports using GLP
if it is
available.&nbsp; Currently, GLP is available only in Sun OpenGL 1.5
for
Sparc/Solaris.</p>

<p>See <a href="http://www.opengl.org/about/arb/meeting_notes/notes/glP_presentation.pdf">http://www.opengl.org/about/arb/meeting_notes/notes/glP_presentation.pdf</a>
for more details on GLP.</p>

<p>If GLP is supported on your application server, it can be
enabled by
passing an argument of <code>-d glp</code> to <code>vglrun</code>,
e.g.:</p>

<pre>/opt/SUNWvgl/bin/vglrun -d glp <var>{application_executable_or_script} {arguments}</var><br></pre>

<p>This will tell the VirtualGL faker to enable GLP mode and
select the first
available GLP device.&nbsp; You can also set the <code>VGL_DISPLAY</code>
environment
variable to <code>glp</code> to achieve the same effect:</p>

<pre>export VGL_DISPLAY=glp<br>/opt/SUNWvgl/bin/vglrun <var>{application_executable_or_script} {arguments}</var><br></pre>

<p>Additionally, you can specify a specific GLP device to use for
rendering:</p>

<pre>export VGL_DISPLAY=/dev/fbs/jfb0<br>/opt/SUNWvgl/bin/vglrun <var>{application_executable_or_script} {arguments}</var><br></pre>

<p align="right"><a href="#" target="_top">top</a></p>

<hr style="width: 100%; height: 2px;">
<h2><a name="secureusage"></a>Secure Usage</h2>

<h3>SSL Tunneling of the Video Stream</h3>

<p>VirtualGL has built-in support for encrypting its compressed
image stream
inside a Secure Socket Layer (SSL.)&nbsp; For performance reasons,
this feature is
not enabled by default, but it can easily be&nbsp;enabled.
&nbsp;On the server,&nbsp;set&nbsp;the
environment variable <code>VGL_SSL</code> to <code>1</code>
prior to launching the
application, or pass an argument of <code>+s</code> to <code>vglrun</code>.
&nbsp;No
action is required on the client. &nbsp;The client will
automatically accept SSL
or unencrypted connections, unless you have configured it otherwise
(see <a href="index.html#config">Advanced Configuration</a>
for more details.)</p>

<h3>SSh Tunneling of the X11 Protocol Stream</h3>

<p>
Secure Shell (SSh) has built-in support for tunneling the X11 protocol
stream
through the SSh connection.&nbsp; Tunneling the X11 protocol stream
has several
advantages:</p>

<ul>

  <li>No one can snoop your X11 connection.</li>

  <li>You don't have to explicitly grant the remote host
permission to use your X display.</li>

  <li>You can take advantage of SSh's compression features (for
low-bandwidth connections.)</li>

</ul>

<p>The main disadvantage is performance.&nbsp; On a LAN,
tunneling the X11
protocol stream through SSh will probably slow things down, but on a
lower-bandwidth connection, it may actually speed things up, especially
if
you enable compression.</p>

<h4>Enabling X11 Tunneling from a Linux/Solaris Client</h4>

<p>
Pass a <code>-X</code> argument to ssh when connecting to
the
application server,
e.g.:</p>

<pre>ssh -X -l <var>{your_user_name} {server_machine_name_or_IP}</var></pre>

<p>
After opening the SSh connection into the application server, don't set
the
<code>DISPLAY</code> environment.&nbsp; Instead, set
the
environment variable
<code>VGL_CLIENT</code> to the client display, e.g.
</p>

<pre>export VGL_CLIENT=<var>{my_client_machine}</var>:0.0<br></pre>

<p><span class="note">Note:</span>Whether or
not this works will of course
depend on whether the SSh server has the X11 tunneling feature
enabled.&nbsp;&nbsp; It
is almost always enabled on Linux but may not be enabled on all Solaris
servers.<br>

</p>

<p><span class="tip">Tip:</span>If your
connection to the server is
low-bandwidth, you may wish to pass a <code>-C</code>
argument
to ssh when
establishing the connection.&nbsp; This will enable SSh protocol
compression and
may speed things up.&nbsp; Don't use protocol compression when
connecting over a
LAN or other high-speed network.</p>

<h4>Enabling X11 Tunneling from a Windows Client (CygWin)</h4>

<ol>

  <li>
    <p>Prior to opening the SSh connection into the application
server, set the <code>DISPLAY</code> environment on the
client
machine to point to whichever display Exceed is parking on:</p>

Example:<br>

    <pre>set DISPLAY=localhost:0.0</pre>

    <p>The "localhost" part is important.&nbsp; If you don't
anticipate
needing to launch multiple Exceed sessions, you can set this
environment variable globally (<em>Control
Panel--&gt;System--&gt;Advanced</em>.)</p>

  </li>

  <li>
    <p>Pass a <code>-X</code> argument to ssh when
connecting to the server.&nbsp; Example:</p>

    <pre>ssh -X -l <var>{your_user_name} {server_machine_name_or_IP}</var></pre>

  </li>

</ol>

<p><span class="tip">Tip:</span>If your
connection to
the server is
low-bandwidth, you may additionally wish to pass a <code>-C</code>
argument to
ssh when establishing the connection.&nbsp; This will enable SSh
protocol
compression and may speed things up.&nbsp; Don't use protocol
compression when
connecting over a LAN or other high-speed network.
</p>

<h4>Enabling X11 Tunneling from a Windows Client (PuTTY)</h4>

<ol>

  <li>Launch PuTTY.</li>

  <li>Select the <em>Connection--&gt;SSH--&gt;Tunnels</em>
category.</li>

  <li>Check "Enable X11 forwarding" and set the "X display
location" to <code>localhost:0.0</code> or whichever
display
Exceed is parking on.</li>

</ol>

<p><span class="tip">Tip:</span>If your
connection to
the server is
low-bandwidth, you may wish to enable SSh protocol compression when
establishing the connection.&nbsp; To do this, select the
<em>Connection--&gt;SSH</em> category in PuTTY and
check "Enable
compression."&nbsp; Don't use protocol compression when connecting
over a LAN or
other high-speed network.
</p>

<h4>Launching the Application</h4>

<p>After opening an SSh connection into the application server,
don't set
the
<code>DISPLAY</code> environment.&nbsp; Instead, set
the
environment variable
<code>VGL_CLIENT</code> to the client display.</p>

<p>Example:</p>

<pre>export VGL_CLIENT=<var>{my_client_machine}</var>:0.0<br></pre>

<p>Then <code>vglrun</code> the application as you
would
normally.</p>

<h3>A More Complex Scenario</h3>

<p>So what if your only path into the network is through SSh,
perhaps through
a single "gateway" machine.&nbsp; No problem, because SSh allows
you to tunnel
both incoming and outgoing TCP/IP connections on any port from one
machine to
another.&nbsp; Tunneling VirtualGL's compressed image stream
through SSh will not
be as fast as using the built-in SSL capabilities of VirtualGL, but
sometimes
it's the only option available.</p>

<p>Let's assume the following configuration:</p>

<p><img alt="" src="sshtunnel.png?rev=HEAD&amp;root=VirtualGL"> <br>

</p>

<p>What we want to do is tunnel both the X11 protocol stream and
VirtualGL's
compressed image stream through SSh.&nbsp; Here's one way to do it:</p>

<ol>

  <li>
    <p>Start the VirtualGL client</p>

  </li>

  <li>
    <p>If the client machine is running Windows,
    </p>

    <ol style="list-style-type: lower-alpha;">

      <li>Start Exceed</li>

      <li>Open a console and type<br>

        <pre>set DISPLAY=localhost:0.0<br></pre>

        <p>(replace ":0.0" with whatever display number Exceed is
parking on.)</p>

      </li>

    </ol>

  </li>

  <li>
    <p>In that same console:</p>

    <pre>ssh -X -R 4242:localhost:4242 <var>username</var>@<var>ssh_gateway_machine</var></pre>

    <p>This tells SSh to tunnel all X11 traffic from your session
on <var><code>ssh_gateway_machine</code></var>
to your client's display, and additionally it will tunnel all outbound
traffic to port 4242 on <var><code>ssh_gateway_machine</code></var>
to
inbound port 4242 on your client machine.</p>

    <p><span class="tip">Tip:</span>This
command line
also works with PuTTY.&nbsp; Just replace "ssh" with the path to
the PuTTY executable.&nbsp; You can also configure the same thing
through the PuTTY GUI as follows:</p>

    <img alt="" src="putty2.png?rev=HEAD&amp;root=VirtualGL">
    <br>

    <br>

  </li>

  <li>
    <p>Now you should have a terminal session open into <var><code>ssh_gateway_machine</code></var>.&nbsp;
Inside this session, issue the following command:</p>

    <pre>ssh -X -R 4242:localhost:4242 <var>username</var>@<var>app_server_machine</var></pre>

    <p>This tells SSh to tunnel all X11 traffic from your session
on <var><code>app_server_machine</code></var>
to your session on <var><code>ssh_gateway_machine</code></var>,
where
it
will be re-tunneled to the client display.&nbsp; Additionally, all
outbound traffic to port 4242 on <var><code>app_server_machine</code></var>
will be tunneled to port 4242 on <var><code>ssh_gateway_machine</code></var>,
which will then re-tunnel the traffic to inbound port 4242 on your
client machine.</p>

  </li>

  <li>You should now have a terminal session open into <var><code>app_server_machine</code></var>.&nbsp;
Inside that session, set the environment variable <code>VGL_CLIENT</code>
to <code>localhost:<var>n</var>.0</code>,
where <code><var>n</var> </code>is
the display number of the X server running on the Client machine.<br>

&nbsp;</li>

  <li><code>vglrun</code> your application.</li>

</ol>

<p>You can of course replace port 4242 in all of the steps above
with
whatever port you choose, but make sure that if you change the port,
you
configure both the client and server to talk on the port you choose
(using
the <code>-port</code> argument to <code>vglclient</code>
as well as the
<code>VGL_PORT</code> environment variable on the server.)</p>

<p><span class="tip">Tip:</span>This same
procedure would also work if you
needed to connect directly to <var><code>app_server_machine</code></var>
and tunnel everything
over
SSh.&nbsp; In that case, simply leave out Step 3. </p>

<p><span class="tip">Tip:</span>You might also
want to try enabling SSh
compression for the first stage of the trip, from your client to the
SSh
gateway.&nbsp; This could improve performance if the WAN connection
is
low-bandwidth.</p>

<div align="right"><a href="#" target="_top">top</a><br>

</div>

<hr style="width: 100%; height: 2px;">
<h2><a name="vnc"></a>Usage with VNC</h2>

<p>VirtualGL's default mode of operation, and its fastest mode of
operation
in a LAN environment, is "direct mode." &nbsp;In direct mode,
VirtualGL uses its
own built-in high-speed image compressors to send the rendered pixels
from a
3D window over the network to the client.&nbsp; A process running
on the client
machine then decompresses the compressed pixels and re-composites them
into
the appropriate X window.<br>

</p>

<p align="center"><span class="colorheader">VirtualGL
in Direct Mode<br>

</span></p>

<p align="center"><img alt="VirtualGL's Architecture" src="virtualgl.png?rev=HEAD&amp;root=VirtualGL"> </p>

<p>However, VirtualGL has a second mode of
operation,&nbsp;"raw mode", which
allows it to work in concert with VNC or other 3rd party X11
proxies.&nbsp; In raw
mode, VirtualGL&nbsp;bypasses its own image compressor and allows
VNC to do the
job of compressing and delivering images to the client(s).<br>

</p>

<p align="center"><span class="colorheader">VirtualGL
in Raw Mode</span></p>

<p align="center"><img alt="Ideal X11 Proxy" src="idealx11proxy.png?rev=HEAD&amp;root=VirtualGL"></p>

<p><strong>Advantages of using VirtualGL with VNC:<br>

</strong></p>

<ul>

  <li>The VNC protocol performs much better than X11 over
high-latency or low-bandwidth connections. &nbsp;The application
GUI will load and render much faster with VNC than with X11 on such
network connections.</li>

  <li>VNC provides rudimentary collaboration capabilities.
&nbsp;Multiple VNC clients can simultaneously view the same VNC
server session and pass around control of the keyboard and mouse.</li>

  <li>The VNC client is stateless. &nbsp;If the network
hiccups or the client is otherwise disconnected, the session remains
running on the server and can be rejoined from any machine on the
network.</li>

  <li>VNC clients are available for a variety of platforms
(including PDA's) that VirtualGL doesn't support.</li>

  <li>No X server is required on the client machine.
&nbsp;This reduces the deployment cost and complexity for Windows
clients.</li>

</ul>

<strong>Disadvantages of using VirtualGL with VNC:</strong>
<ul>

  <li>On a high-bandwidth, low-latency network, running VirtualGL
in raw mode with VNC will perform more slowly than running VirtualGL in
direct mode. &nbsp;On a typical 100 Mbit LAN, TurboVNC (see below)
can deliver images to the client with about 80% of
the&nbsp;performance of VirtualGL's direct mode, but other VNC
implementations will perform much worse, since their image codecs are
tuned for low-speed connections.</li>

  <li>VNC does not provide seamless windows. &nbsp;Rather
than each application window appearing as a separate client window, the
entire server desktop appears in a single client window.</li>

  <li>VNC requires more server resources, both because it has to
compress more pixels (an entire desktop rather than a single window)
and because 2D (X11) rendering occurs on the server rather than the
client.</li>

  <li>VNC cannot be used with <a href="#advancedopengl">advanced
OpenGL features</a>, such as stereo or overlays.</li>

</ul>

<p>When a VNC session is started on the server, VNC chooses a
unique display
number (such as :1, :2, etc.) and starts a customized X server (Xvnc)
on that
display number.&nbsp; Xvnc renders all graphical output from the
application into
a bitmap in memory, which it then&nbsp;compresses and
sends&nbsp;to the client(s).
&nbsp;Xvnc does not implement the GLX extension at all, and thus it
can't be used
as-is to run 3D applications.&nbsp; But since VirtualGL is designed
to intercept
and hand off all GLX commands to the hardware-accelerated root display
(usually display :0), VirtualGL can be used as a "3D to 2D converter"
to
allow 3D apps to run within VNC or another X11 proxy that doesn't
natively
support GLX.&nbsp; When used in "raw" mode, VirtualGL bypasses its
compressed
image delivery system and instead composites the 3D drawing
area&nbsp;back into
the window&nbsp;using standard X11 image drawing
commands.&nbsp; Normally, VirtualGL
and Xvnc are running on the same machine, so VirtualGL can pass drawing
commands to Xvnc very quickly using shared memory.</p>

<h3>TurboVNC</h3>

<p>TurboVNC&nbsp;is essentially just a version of <a href="http://www.tightvnc.com/">TightVNC</a> with
optimizations to make it
perform at peak efficiency with full-screen video workloads (which is,
in a
nutshell, what VirtualGL produces.) &nbsp;These optimizations
include:<br>

</p>

<ul>

  <li>Using VirtualGL's high-performance JPEG codec to handle
tight JPEG encoding </li>

  <li>Using only JPEG and Full color encoding (mono, gradient,
and indexed encoding are disabled.) &nbsp;High-performance JPEG
encoding is used in all cases except for very small image tiles for
which using full color (raw) encoding is more efficient due to JPEG's
compression overhead. </li>

  <li>Using the optimized tight protocol whenever possible.
&nbsp;Other VNC protocols (ZRLE, Hextile, etc.) are available on
the server so that it can talk to non-TurboVNC clients. &nbsp;But
if a TurboVNC client connects to a TurboVNC server, they will both use
optimized tight encoding at all times. </li>

  <li>Protocol tweaks to allow some stages of the VNC pipeline to
occur in parallel. &nbsp;This particularly improves performance on
low-bandwidth (broadband) connections.</li>

</ul>

<p>Other notable differences between TurboVNC and TightVNC:<br>

</p>

<ul>

  <li>
    <p>The compression level and quality parameters have been
changed as follows:<br>

    </p>

    <p>Compression Level = <em>0</em> for 4:4:4
subsampling, <em>1</em> for 4:1:1
subsampling,
or <em>2</em> for 4:2:2 subsampling<br>

Quality = <em>0 to 100</em> (JPEG quality level)</p>

  </li>

  <li>
    <p>The TurboVNC client supports double buffering.
&nbsp;This is enabled by default but can be disabled by passing an
argument of <code>-singlebuffer</code> to <code>vncviewer</code>
(or selecting the corresponding option in the configuration GUI.)</p>

  </li>

  <li>The TurboVNC client adds a special mode which optimizes the
client/server interaction to improve performance on high-latency
networks. &nbsp;Normally, the VNC client will wait until one screen
update has finished drawing before requesting the next one.
&nbsp;Enabling TurboVNC's high-latency network mode causes the
client to send a request for the next frame while it is drawing the
current one. &nbsp;This mode decreases performance on local-area
networks and is thus not enabled by default, but it can be
enabled&nbsp;by passing an argument of <code>-wan</code>
to <code>vncviewer</code> (or selecting the corresponding
option in the configuration GUI.)</li>

</ul>

<p>Using VirtualGL in direct mode&nbsp;is&nbsp;preferable
if seamless windows are a
requirement and if performance is critical. &nbsp;But if a bit of
performance can
be sacrificed and if collaboration and a stateless client are more
important
features than seamless windows, then VirtualGL+TurboVNC would be the
appropriate solution. &nbsp;In the long term, we are looking for a
way to combine
the best of both solutions into one. &nbsp;But such is not an
easy&nbsp;problem to
solve ...</p>

<p>TurboVNC&nbsp;allows VirtualGL to be used with respectable
performance over
low-bandwidth/high-latency networks, such as broadband or satellite.
&nbsp;As with
VirtualGL's direct mode, the quality and subsampling of TurboVNC's JPEG
image
stream can be adjusted to reduce the size of the&nbsp;image stream
without
reducing the number of image colors. &nbsp;TurboVNC provides a
preset mode
for&nbsp;broadband connections, which sets the quality to a low
level that is
noticeably lossy but still quite usable. &nbsp;It should be
possible to redraw a
1280x1024 window at greater than 10 frames/second&nbsp;on a
standard cable modem
connection using this preset mode.</p>

<p>For&nbsp;instructions on the usage of TurboVNC, please
refer to the TurboVNC
man pages:</p>

<p>On Linux:</p>

<pre>man -M /opt/TurboVNC/man {vncserver | Xvnc | vncviewer | vncconnect | vncpasswd}</pre>

<p>On Solaris:</p>

<pre>man -M /opt/SUNWtvnc/man {vncserver | Xvnc | vncviewer | vncconnect | vncpasswd}</pre>

<p>On Windows, use the embedded help feature (the question mark
button in the
upper right of the window.)</p>

<p>The TightVNC documentation:</p>

<p><a href="http://www.tightvnc.com/docs.html">http://www.tightvnc.com/docs.html</a></p>

<p>might also be helpful, since TurboVNC is based on TightVNC and
shares many
of its features.</p>

<h3>Enabling Raw Mode</h3>

<p>Raw mode is automatically enabled if VirtualGL detects that it
is running
on the same machine as the X server, which it assumes to be the case if
the
X display name begins with a colon (":") or with "<code>unix:</code>".&nbsp;
In most
cases, this will cause VirtualGL to automatically use raw mode when it
is
launched in an X proxy environment such as VNC or NX.&nbsp; But you
can override
this behavior by setting the <code>VGL_COMPRESS</code>
environment variable on
the server or passing an argument of <code>-c 0</code> or <code>-c
1</code> to
<code>vglrun</code> (see <a href="#config">Advanced
Configuration</a> for more
details.)&nbsp; Make sure that the <code>DISPLAY</code>
variable points to whatever
display number that VNC (or your X proxy of choice) is occupying (e.g.
:1,
:2, etc.)</p>

<div align="right"><a href="#" target="_top">top</a><br>

</div>

<hr style="width: 100%; height: 2px;">
<h2><a name="dynamicgl"></a>Usage with
Applications That Manually Load
OpenGL</h2>

<p>The lion's share of OpenGL applications are dynamically linked
against
<code>libGL.so</code>, and thus <code>libGL.so</code>
is automatically loaded
whenever the application loads. &nbsp;Whenever <code>vglrun</code>
is used to launch
such&nbsp;applications, VirtualGL is loaded ahead of <code>libGL.so</code>,
meaning
that&nbsp;OpenGL and GLX symbols are resolved from VirtualGL first
and the "real"
OpenGL library second.</p>

<p>However, some applications (particularly games) are not
dynamically linked
against <code>libGL.so</code>. &nbsp;These
applications
typically call
<code>dlopen()</code> and <code>dlsym()</code>
later
on in the program's execution to
manually load OpenGL and GLX symbols from <code>libGL.so</code>.
&nbsp;Such
applications also generally provide a mechanism (usually either an
environment variable or a command line argument) which allows the user
to
specify a library that can be loaded instead of <code>libGL.so</code>.</p>

<p>So let's assume that you just downloaded the latest version of
the Linux
game Foo Wars from the Internet, and (for whatever reason) you want to
run
the game in a VNC session. The game provides a command line
switch
<code>-g</code> which can be used to specify an OpenGL
library
to load other than
<code>libGL.so</code>. &nbsp;You would launch the game
using a command line such as
this:</p>

<pre>vglrun foowars -g /usr/lib/librrfaker.so</pre>

<p>You still need to use <code>vglrun</code> to
launch
the game, because
VirtualGL must also intercept a handful of X11 calls. &nbsp;Using <code>vglrun</code>
allows VGL to intercept these calls, whereas using the game's built-in
mechanism for loading a substitute OpenGL library allows VirtualGL to
intercept the GLX and OpenGL calls.</p>

<p>In some cases, the application doesn't provide an override
mechanism such
as the above.&nbsp; In these cases, you should pass an argument of <code>-dl</code>
to
<code>vglrun</code> when starting the application, e.g.:</p>

<pre>vglrun -dl foowars</pre>

<p>Passing <code>-dl</code> to <code>vglrun</code>
forces another library to be
loaded ahead of VirtualGL and <code>libGL.so</code>.&nbsp;
This new library intercepts
any calls to <code>dlopen()</code> and forces the
application
to open VirtualGL
instead of <code>libGL.so</code>.</p>

<p><a href="#recipes">This section</a>
contains specific recipes for getting
a variety of games and other applications to work with VirtualGL</p>

<div align="right"><a href="#" target="_top">top</a></div>

<hr style="width: 100%; height: 2px;">
<h2><a name="chromium"></a>Usage with Chromium
and ModViz
VGP<sup>TM</sup></h2>

<p>Chromium is a powerful framework for performing various types
of parallel
OpenGL rendering. &nbsp;It is usually used on clusters of commodity
Linux PC's to
divide up the task of rendering scenes with large geometries or large
pixel
counts (such as when driving a display wall.) &nbsp;Chromium is
most often used in
one of three configurations:</p>

<ol>

  <li>Sort-First Rendering (Image-Space Decomposition)</li>

  <li>Sort-First Rendering (Image-Space Decomposition) with
Readback</li>

  <li>Sort-Last Rendering (Object-Space Decomposition)</li>

</ol>

<h3>Configuration 1: Sort-First Rendering (Image-Space
Decomposition)</h3>

<p align="center"><img alt="" src="chromium-displaywall.png?rev=HEAD&amp;root=VirtualGL"></p>

<p style="text-align: left;">Sort-First Rendering
(Image-Space Decomposition)
is used to overcome the fill-rate limitations of individual graphics
cards.
&nbsp;When configured to use sort-first rendering, Chromium divides
up the scene
based on which polygons will be visible in a particular section of the
final
image. &nbsp;It then instructs each node of the cluster to render
only the
polygons that are necessary to generate the image section ("tile") for
that
node. &nbsp;This is primarily used&nbsp;to drive
high-resolution displays that would be
impractical to drive from a single graphics card due to limitations in
the
card's framebuffer memory, processing power, or both.
&nbsp;Configuration 1 could
be used, for instance, to drive a CAVE, video wall, or even an
extremely
high-resolution monitor. &nbsp;In this configuration, each Chromium
node&nbsp;generally
uses all of its screen real estate to render a section of
the&nbsp;multi-screen
image.</p>

<p style="text-align: left;">VirtualGL is generally not
very useful with
Configuration 1. &nbsp;You could theoretically&nbsp;install a
separate copy of
VirtualGL on each display node and use it to redirect the output of
each
<code>crserver</code> instance to a multi-screen X server
running elsewhere on
the network. &nbsp;But there would be no way
to&nbsp;synchronize the screens&nbsp;on the
remote end. &nbsp;Chromium uses DMX to synchronize the screens in a
multi-screen
configuration, and VirtualGL would have to be made DMX-aware for it to
perform the same job. &nbsp;Maybe at some point in the future ...
&nbsp;If you have a
need for such a configuration, <a href="http://sourceforge.net/users/dcommander">let us know</a>.</p>

<h3 style="text-align: left;"><strong>Configuration
2: Sort-First Rendering
(Image-Space Decomposition) with Readback</strong></h3>

<p align="center"><img alt="" src="chromium-sortfirst.png?rev=HEAD&amp;root=VirtualGL"></p>

<p>
Configuration 2 uses the same sort-first principle as Configuration 1,
except
that each tile is only a fraction of a single screen, and the tiles are
recombined into a single window on&nbsp;Node 0. &nbsp;This
configuration is perhaps the
least often used of the three, but it is useful in cases where the
scene
contains a large amount of textures (such as in volume rendering) and
thus
rendering the whole scene on a single node would be prohibitively slow
due to
fill-rate limitations.
</p>

<p style="text-align: left;">In this configuration, the
application is
allowed to choose a visual, create an X window, and manage the window
as it
would normally do. &nbsp;But all other OpenGL and GLX activity is
intercepted by
the Chromium App Faker (CrAppFaker) so that the rendering task can be
split
up among the rendering nodes. &nbsp;Once each node has rendered its
section of the
final image, the tiles get passed back to a Chromium Server (CrServer)
process running on Node 0. &nbsp;This CrServer process attaches to
the
previously-created application window and draws the pixels into it
using
<code>glDrawPixels()</code>.</p>

<p style="text-align: left;">The general strategy for
making this work with
VirtualGL is to first make it work without VirtualGL and then insert
VirtualGL only into the processes that run on Node 0.
&nbsp;VirtualGL must be
inserted into the CrAppFaker process&nbsp;to prevent CrAppFaker
from sending
<code>glXChooseVisual()</code> calls to the X server (which
would fail if the X
server is a VNC server or otherwise does not provide GLX.)
&nbsp;VirtualGL must be
inserted into the CrServer process on Node 0 to prevent it from sending
<code>glDrawPixels()</code> calls to the X server (which
would
effectively send
uncompressed images over the network.) &nbsp;Instead, VirtualGL
forces CrServer to
draw into a Pbuffer, and VGL takes charge of transmitting those pixels
to the
destination X server in the most efficient way possible.</p>

<p style="text-align: left;">Since Chromium uses <code>dlopen()</code>
to load
the system's OpenGL library,&nbsp;preloading VirtualGL into the
CrAppFaker and
CrServer processes using <code>vglrun</code> is not
sufficient. &nbsp;Fortunately,
Chromium provides an environment variable, <code>CR_SYSTEM_GL_PATH</code>,
which
allows one to specify an alternate path in which it will search for the
system's <code>libGL.so</code>. &nbsp;The VirtualGL
packages for Linux and Solaris
include a symbolic link named <code>libGL.so</code> which
really points to the
VirtualGL faker library (<code>librrfaker.so</code>)
instead.
This symbolic link
is located in its own isolated directory, so that directory can be
passed to
Chromium in the <code>CR_SYSTEM_GL_PATH</code> environment
variable, thus causing
Chromium to load VirtualGL rather than the "real" OpenGL library.
&nbsp;Refer to
the following table:</p>

<p style="text-align: center;"><span class="colorheader"><code>CR_SYSTEM_GL_PATH</code>
setting required to use
VirtualGL with Chromium</span></p>

<table style="text-align: left; margin-left: auto; margin-right: auto;" align="center" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"></td>

      <td class="colorheader">32-bit Applications</td>

      <td class="colorheader">64-bit Applications<br>

      </td>

    </tr>

    <tr>

      <td class="colorheader">Linux</td>

      <td><code>/opt/VirtualGL/lib</code><br>

      </td>

      <td><code>/opt/VirtualGL/lib64</code><br>

      </td>

    </tr>

    <tr>

      <td class="colorheader">Solaris/Sparc</td>

      <td><code>/opt/SUNWvgl/fakelib</code></td>

      <td><code>/opt/SUNWvgl/fakelib/sparcv9</code></td>

    </tr>

    <tr>

      <td class="colorheader">Solaris/x86</td>

      <td><code>/opt/SUNWvgl/fakelib</code></td>

      <td><code>/opt/SUNWvgl/fakelib/64</code></td>

    </tr>

  </tbody>
</table>

<p style="text-align: left;">Running the CrServer in
VirtualGL is simply a
matter of setting this environment variable and then invoking
<code>crserver</code> with <code>vglrun</code>,
e.g.:</p>

<pre>export CR_SYSTEM_GL_PATH=/opt/VirtualGL/lib<br>vglrun crserver</pre>

<p style="text-align: left;">In the case of CrAppFaker, it
is also necessary
to set <code>VGL_GLLIB</code> to the location of the
"real"
OpenGL library, e.g.
<code>/usr/lib/libGL.so.1</code>. &nbsp;CrAppFaker
creates
its own fake version of
<code>libGL.so</code> which is really just a copy of
Chromium's
<code>libcrfaker.so</code>. &nbsp;So VirtualGL, if left
to
its own devices, will
unwittingly try to load <code>libcrfaker.so</code> instead
of
the "real" OpenGL
library. &nbsp;Chromium's <code>libcrfaker.so</code>
will
in turn try to load
VirtualGL again, and an endless loop will occur.</p>

<p style="text-align: left;">So what we want to do is
something like this:</p>

<pre>export CR_SYSTEM_GL_PATH=/opt/VirtualGL/lib<br>export VGL_GLLIB=/usr/lib/libGL.so.1<br>crappfaker</pre>

<p>CrAppFaker will copy the application to a temp directory and
then&nbsp;copy&nbsp;<code>libcrfaker.so</code> to
that
same directory, renaming it as
<code>libGL.so</code>. &nbsp;So when the application is
started, it loads
<code>libcrfaker.so</code> instead of <code>libGL.so</code>.
&nbsp;<code>libcrfaker.so</code>
will then load VirtualGL instead of the "real" libGL, because we've
overridden <code>CR_SYSTEM_GL_PATH</code> to make Chromium
find VirtualGL's&nbsp;fake
<code>libGL.so</code> first. &nbsp;VirtualGL will then
use
the library specified in
<code>VGL_GLLIB</code> to make any "real" OpenGL calls that
it
needs to make.</p>

<p>Note that <code>crappfaker</code> should not be
invoked with
<code>vglrun</code>.</p>

<p>So, putting this all together, here is an example of how you
might start a
sort-first rendering job using Chromium and VirtualGL:</p>

<ol>

  <li>Start the mothership on Node 0 with an appropriate
configuration for performing sort-first rendering with readback</li>

  <li>Start <code>crserver</code> on each of the
rendering nodes</li>

  <li>On Node 0, set <code>CR_SYSTEM_GL_PATH</code>
to
the appropriate value for the operating system and application type
(see table above)</li>

  <li>On Node 0, <code>vglrun crserver &amp;</code></li>

  <li>On Node 0, set <code>VGL_GLLIB</code> to the
location of the "real" libGL, e.g. <code>/usr/lib/libGL.so.1&nbsp;</code>or&nbsp;<code>/usr/lib64/libGL.so.1</code></li>

  <li>On Node 0, launch <code>crappfaker</code> (do
not
use <code>vglrun</code> here)</li>

</ol>

<p>
Again, it's always a good idea to make sure this works without
VirtualGL
before adding VirtualGL into the mix.</p>

<p><span class="note">Note:</span>When using
VirtualGL
with this mode, resizing
the application window may not work properly. &nbsp;This is because
the resize
event is sent to the application process, and therefore the CrServer
process
that's actually drawing the pixels has no way of knowing that a window
resize
has occurred. &nbsp;A possible fix&nbsp;is to modify Chromium
such that it propagates
the resize event down the render chain so that all of the CrServer
processes
are aware that a resize event occurred.
</p>

<h3><span class="colorheader">Configuration 3:
Sort-Last Rendering
(Object-Space Decomposition)</span></h3>

<p align="center"><img alt="" src="chromium-sortlast.png?rev=HEAD&amp;root=VirtualGL"></p>

<p>Sort-Last Rendering is used when the scene contains a huge
number of
polygons and the rendering bottleneck is&nbsp;processing all of
that geometry on a
single graphics card. &nbsp;In this case, each node runs a separate
copy of the
application, and for best results, the application needs to be at least
partly aware that it's running in a parallel environment so that it can
give
Chromium hints as to how to distribute the various objects to be
rendered.
&nbsp;Each node generates an image of a particular portion of the
object space,
and these images must be composited in such a way that the
front-to-back
ordering of pixels is maintained. &nbsp;This is generally done by
collecting Z
buffer data from each node to determine whether a particular pixel on a
particular node is visible in the final image.
&nbsp;The&nbsp;rendered images from each
node are often composited&nbsp;using a "binary swap", whereby the
nodes combine
their images in a cascading tree so that the overall compositing time
is
proportional to log<sub>2</sub>(N) rather than N.</p>

<p>To make this configuration work with VirtualGL:</p>

<ol>

  <li>Start the mothership on Node 0 with an appropriate
configuration for performing sort-last rendering</li>

  <li>Start <code>crappfaker</code> on each of the
rendering nodes</li>

  <li>On Node 0, set <code>CR_SYSTEM_GL_PATH</code>
to
the appropriate value for the operating system and application type
(see table in the previous section)</li>

  <li>On Node 0, <code>vglrun crserver</code></li>

</ol>

<h4>CRUT</h4>

<p>The Chromium Utility Toolkit provides a convenient way for
graphics
applications to&nbsp;specifically take advantage of Chromium's
sort-last rendering
capabilities. &nbsp;Such applications can use CRUT to explicitly
specify how their
object space should be decomposed. &nbsp;CRUT applications require
an additional
piece of software, <code>crutserver</code>, to be running
on
Node 0. &nbsp;So to make
such applications work with VirtualGL:</p>

<ol>

  <li>Start the mothership on Node 0 with an appropriate
configuration for performing sort-last rendering</li>

  <li>Start <code>crappfaker</code> on each of the
rendering nodes</li>

  <li>On Node 0, set <code>CR_SYSTEM_GL_PATH</code>
to
the appropriate value for the operating system and application type
(see table in the previous section)</li>

  <li>On Node 0, <code>vglrun crutserver &amp;</code></li>

  <li>On Node 0, <code>vglrun crserver</code></li>

</ol>

<h3><span class="colorheader">A Note About
Performance</span></h3>

<p>
Chromium's use of X11 is generally not very optimal. &nbsp;It
assumes a very fast
connection between the X server and the Chromium Server. &nbsp;In
certain modes,
Chromium polls the X server on every frame to determine whether windows
have
been resized, etc. &nbsp;Thus, we have observed that, even on a
fast network, Chromium tends
to perform
much better with VirtualGL running in a&nbsp;TurboVNC session as
opposed to
VirtualGL running in direct mode.</p>

<h3><span class="colorheader">ModViz VGP<sup>TM</sup>
and
VirtualGL</span></h3>

<p>ModViz Virtual Graphics Platform<sup>TM</sup> is a
polished commercial
clustered rendering framework for Linux which supports all three of the
rendering modes described above and provides a much more
straightforward&nbsp;interface to configure and run these types of
parallel
rendering jobs.</p>

<p>All VGP jobs, regardless of configuration, are all spawned
through
<code>vglauncher</code>, a front-end program which
automatically takes care of
starting the appropriate processes on the rendering nodes, intercepting
OpenGL calls from the application instance(s), sending rendered images
back
to Node 0, and compositing the images as appropriate. &nbsp;In a
similar manner to
VirtualGL's <code>vglrun</code>, VGP's <code>vglauncher</code>&nbsp;preloads
a library
(<code>libVGP.so</code>) in place of <code>libGL.so</code>,
and this library
intercepts the OpenGL calls from the application.</p>

<p>So our strategy here is similar to our strategy for loading
the Chromium
App Faker. &nbsp;We want to insert VirtualGL between VGP and the
real system
OpenGL library, so that VGP will call VirtualGL and VirtualGL will call
<code>libGL.so</code>. &nbsp;Achieving this with VGP is
relatively simple:</p>

<pre>export VGP_BACKING_GL_LIB=librrfaker.so<br>vglrun vglauncher --preload=librrfaker.so:/usr/lib/libGL.so {application}</pre>

<p>Replace <code>/usr/lib/libGL.so</code> with the
full
path of your system's
OpenGL library (<code>/usr/lib64/libGL.so</code> if you are
launching a 64-bit
application.)</p>

<div align="right"><a href="#">top</a><br>

</div>

<hr>
<h2><a name="recipes"></a>Application Recipes</h2>

<table style="text-align: left; margin-left: auto; margin-right: auto;" border="0" cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader">Application</td>

      <td class="colorheader">Platform</td>

      <td class="colorheader">Recipe</td>

      <td class="colorheader">Notes<br>

      </td>

    </tr>

    <tr>

      <td>Army Ops</td>

      <td>Linux/x86</td>

      <td> <code>vglrun -dl armyops</code> </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Descent 3</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun descent3 -g /usr/lib/librrfaker.so</code>
      </p>

      <p>or</p>

      <p><code>vglrun -dl descent3</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Doom 3</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun doom3 +set r_glDriver
/usr/lib/librrfaker.so</code>
      </p>

      <p>or
      </p>

      <p><code>vglrun -dl doom3</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details<br>

      </td>

    </tr>

    <tr>

      <td>Enemy Territory (Return to Castle Wolfenstein)</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun et +set r_glDriver
/usr/lib/librrfaker.so</code>
      </p>

      <p>or
      </p>

      <p><code>vglrun -dl et</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Heretic II</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun heretic2 +set gl_driver
/usr/lib/librrfaker.so +set vid_ref glx</code>
      </p>

      <p>or
      </p>

      <p><code>vglrun -dl heretic2 +set vid_ref glx</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Heavy Gear II</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun hg2 -o /usr/lib/librrfaker.so</code>
      </p>

      <p>or
      </p>

      <p><code>vglrun -dl hg2</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Java2D applications that use OpenGL</td>

      <td>Linux, Solaris</td>

      <td>
      <p>Java2D will use OpenGL to perform its rendering if <code>sun.java2d.opengl</code>
is set to <code>True</code>, e.g.:</p>

      <pre>java -Dsun.java2d.opengl=True <var>MyAppClass</var></pre>

      <p>In order for this to work in VirtualGL, it is necessary
to invoke <code>vglrun</code> with the <code>-dl</code>
switch, e.g.:</p>

      <pre>vglrun -dl java -Dsun.java2d.opengl=True <var>MyAppClass</var></pre>

      <p>If you are using Java v6 b92 or later, you can also set
the environment variable <code>J2D_ALT_LIBGL_PATH</code>
to
the path of <code>librrfaker.so</code>, e.g.:</p>

      <pre>setenv J2D_ALT_LIBGL_PATH /opt/SUNWvgl/lib/librrfaker.so<br>vglrun java -Dsun.java2d.opengl=True <var>MyAppClass</var></pre>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Pro/ENGINEER Wildfire v2.0</td>

      <td>Solaris/Sparc</td>

      <td>
      <p>Add</p>

      <p><code>graphics opengl</code></p>

      <p>to <em>~/config.pro</em>.&nbsp; You may
also need to set the <code>VGL_XVENDOR</code> environment
variable to <code>"Sun Microsystems, Inc."</code> if you
are
running Pro/ENGINEER 2.0 over a remote X connection to a Linux or
Windows VirtualGL client.</p>

      </td>

      <td>Pro/E 2.0 for Solaris will disable OpenGL if it detects
a remote connection to a non-Sun X server.</td>

    </tr>

    <tr>

      <td>QGL (OpenGL Qt Widget)</td>

      <td>Linux</td>

      <td> <code>vglrun -dl {application}</code> </td>

      <td>
      <p>Qt can be built such that it either resolves symbols
from libGL automatically or uses <code>dlopen()</code> to
manually resolve those symbols from libGL.&nbsp; As of Qt v3.3, the
latter behavior is the default, so OpenGL programs built with later
versions of libQt will not work with VirtualGL unless the <code>-dl</code>
switch is used with <code>vglrun</code>.</p>

      <p>See <a href="#dynamicgl">this section</a>
for more details</p>

      </td>

    </tr>

    <tr>

      <td>Quake 3</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun quake3 +set r_glDriver
/usr/lib/librrfaker.so</code></p>

      <p>or</p>

      <p><code>vglrun -dl quake3</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Soldier of Fortune</td>

      <td>Linux/x86</td>

      <td>
      <p><code>vglrun sof +set gl_driver
/usr/lib/librrfaker.so</code></p>

      <p>or</p>

      <p><code>vglrun -dl sof</code></p>

      </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>Unreal Tournament 2004</td>

      <td>Linux/x86</td>

      <td> <code>vglrun -dl ut2004</code> </td>

      <td>See <a href="#dynamicgl">this section</a>
for more details</td>

    </tr>

    <tr>

      <td>VisConcept</td>

      <td>Solaris/Sparc</td>

      <td>Set the environment variable <code>VGL_GUI_XTTHREADINIT</code>
to 0</td>

      <td>Popping up the VirtualGL configuration dialog may cause
the application to hang unless you set this environment
variable.&nbsp; See <a href="#config">Advanced
Configuration</a> for more details</td>

    </tr>

  </tbody>
</table>

<a href="#">top</a>
<hr class="top" style="width: 100%; height: 2px;">
<h2><a name="advancedopengl"></a>Advanced
OpenGL Features</h2>

<h3>Stereo</h3>

<p>The general idea behind VirtualGL is to offload as much of the
rendering
work to the server as possible and pass only 2D&nbsp;commands to
the client. &nbsp;But
there are some cases in which VirtualGL must rely on the client to do
some of
the 3D rendering work as well.</p>

<p>There is no way to draw stereo images using regular 2D (X11)
commands, so
the VirtualGL client must use OpenGL to do this kind of drawing.
&nbsp;When an
application requests a stereo visual, VirtualGL will attempt to
ascertain
whether the client supports OpenGL and, if so, whether it
has&nbsp;stereo visuals
available. &nbsp;VirtualGL then checks the server's display to see
whether it has
stereo visuals available as well. &nbsp;If both are true, then
VirtualGL will
return a stereo visual to the application. &nbsp;If, for any given
frame,
VirtualGL detects&nbsp;that the application has drawn something to
one of
the&nbsp;right eye buffers, it will send a stereo image pair to the
VirtualGL
client. &nbsp;The VGL client then decodes the stereo image pair as
a single frame
and draws it to the client's display using OpenGL drawing commands. </p>

<p>The upshot of this is that, in order to use stereo in
VirtualGL, the
client machine must support OpenGL and GLX (Exceed 3D is required for
Windows
clients) and must have a graphics card (such as the nVidia Quadro,
etc.)
which is capable of drawing in stereo. &nbsp;It is usually
necessary to explicitly
enable stereo visuals in the graphics card configuration for both the
client
and server machines. &nbsp;Use <code>glxinfo</code> to
verify whether or not stereo
visuals are enabled on both client and server before attempting to run
VirtualGL with a stereo application.</p>

<p>It goes without saying that stereo does not work inside a VNC
session.</p>

<h3>Transparent Overlays</h3>

<p>Transparent overlays have similar requirements and
restrictions. &nbsp;In this
case, VirtualGL completely bypasses its own GLX faker and sends the
commands
associated with rendering transparent overlays directly to the client
machine. &nbsp;The underlay is still rendered on the server, as
always. &nbsp;This
approach is unfortunately necessary, because there is no reliable way
to draw
to an overlay using 2D (X11) functions, nor is there a reasonable way
to
composite the overlay and underlay on the server side. &nbsp;So
VirtualGL again
relies on the client's software and hardware to do this job.</p>

<p>As with stereo, overlays often must be explicitly enabled in
the graphics
card configuration. &nbsp;In the case of overlays, however, they
need only be
supported and enabled on the client machine.</p>

<p>Indexed color (8-bit) overlays have been tested and are known
to work with
nVidia Quadro hardware. &nbsp;True color (24-bit) overlays will
probably work as
well, but they have not been tested. &nbsp;Use <code>glxinfo</code>
to verify whether
your client's display supports overlays and whether they are enabled.
&nbsp;In
Exceed 3D, make sure that the "Overlay Support" option is checked in
the
"Exceed 3D and GLX" applet:</p>

<p><img src="exceed6.png?rev=HEAD&amp;root=VirtualGL">
</p>

<p>As with stereo, overlays do not work inside a VNC session.</p>

<h3>Indexed (PseudoColor) Rendering</h3>

<p>In a PseudoColor visual, each pixel is represented by an index
which
refers to a location in a color table. &nbsp;The color table stores
the actual
color values (256 of them in the case of 8-bit PseudoColor) which
correspond
to each index. &nbsp;An application merely tells the X server which
color index to
use when drawing, and the X server takes care of mapping that index to
an
actual color from the color table. &nbsp;OpenGL&nbsp;allows for
rendering to
Pseudocolor visuals, and it does so by being intentionally
ignorant&nbsp;of the
relationship between indices and actual colors. &nbsp;As far as
OpenGL is
concerned, each&nbsp;color index value is just a meaningless
number, and it is
only when the final image is drawn by the X server that these numbers
take on
meaning. &nbsp;As a result, many pieces of OpenGL's core
functionality, such as
lighting and shading, either have undefined behavior or do not work at
all
with PseudoColor rendering. &nbsp;PseudoColor rendering used to be
a common
technique to visualize scientific data, because such data often only
contained 8 bits per sample to begin with. &nbsp;Applications could
manipulate the
color table&nbsp;to allow the user to dynamically control the
relationship between
sample values and colors. &nbsp;As more and more graphics cards
drop support for
PseudoColor rendering, however, the applications which use it are a
vanishing
breed.</p>

<p>VirtualGL supports PseudoColor rendering if a PseudoColor
visual is
available
on the client's display. &nbsp;A PseudoColor visual need not be
present on the
server. &nbsp;On the server, VirtualGL uses the red channel of a
standard&nbsp;RGB
Pbuffer to store the color index. &nbsp;Upon receiving an end of
frame trigger,
VirtualGL reads back the red channel of the Pbuffer and uses
XPutImage() to
draw it into the appropriate window. &nbsp;The upshot of this is
that&nbsp;there is no
compression&nbsp;with PseudoColor rendering in VirtualGL.
&nbsp;However, since there is
only 1 byte per pixel in this mode, the images can still be sent to the
client reasonably quickly even though they are uncompressed.</p>

<p>
PseudoColor rendering should work in VNC, provided that the VNC server
is
configured for 8-bit Pseudocolor. &nbsp;TurboVNC does not support
PseudoColor, but
RealVNC and other VNC flavors do. &nbsp;Note, however, that VNC
cannot provide
both PseudoColor and TrueColor visuals at the same time.</p>

<div align="right"><a href="#" target="_top">top</a>&nbsp;
</div>

<hr>
<h2><a name="perf"></a>Performance Measurement</h2>

<h3>VirtualGL's Built-In Profiling System<br>

</h3>

<p>The easiest way to uncover bottlenecks in the VirtualGL
pipeline is to set
the <code>VGL_PROFILE</code> environment variable to 1 on
both
server and client
(passing an argument of <code>+pr</code> to <code>vglrun</code>
on the server has the
same effect.)&nbsp; This will cause VirtualGL to measure and report
the throughput
of the various stages in its pipeline.&nbsp; For example, here are
some
measurements from a dual P4 server communicating with a PIII client on
a 100
Mbit LAN</p>

<p style="margin-left: 40px;"><strong>Server:</strong></p>

<pre>Readback - 43.27 Mpixels/sec - 34.60 fps<br>Compress 0 - 33.56 Mpixels/sec - 26.84 fps<br>Total - 8.02 Mpixels/sec - 6.41 fps - 10.19 Mbits/sec (18.9:1)</pre>

<p style="margin-left: 40px;"><strong>Client:</strong></p>

<pre>Decompress - 10.35 Mpixels/sec - 8.28 fps<br>Blit - 35.75 Mpixels/sec - 28.59 fps<br>Total - 8.00 Mpixels/sec - 6.40 fps - 10.18 Mbits/sec (18.9:1)</pre>

<p>The total throughput of the pipeline is 8.0 Mpixels/sec, or
6.4
frames/sec, indicating that our frame is 8.0 / 6.4 = 1.25 Megapixels in
size
(a little less than 1280 x 1024 pixels.)&nbsp; The readback and
compress stages,
which occur in parallel on the server, are obviously not slowing things
down.&nbsp; And we're only using 1/10 of our available network
bandwidth. &nbsp;So we
look to the client and discover that its slow decompression speed is
the
primary bottleneck. &nbsp;Decompression and blitting on the client
do not occur in
parallel, so the aggregate performance is the harmonic mean of the two
rates:
[1/ (1/10.35 + 1/35.75)] = 8.0 Mpixels/sec.<br>

</p>

<h3>Frame Spoiling</h3>

<p>By default, VirtualGL will only send a frame to the client if
the client
is ready to receive it. &nbsp;If a rendered frame arrives at the
server's queue
and a previous frame is still being processed, the new frame is dropped
("spoiled.") &nbsp;This prevents a backlog of frames on the server,
which would
cause a perceptible delay in the responsiveness of interactive
applications.
&nbsp;But when running non-interactive applications, particularly
benchmarks, it
may be desirable to disable frame spoiling. &nbsp; With frame
spoiling disabled,
the server will render frames only as quickly as the VirtualGL pipeline
can
receive them, which will conserve server resources as well as allow
OpenGL
benchmarks to accurately measure the throughput of the VirtualGL
pipeline.
&nbsp;With frame spoiling enabled, these benchmarks will report
meaningless data,
since they are measuring the server's rendering rate, and that
rendering rate
is decoupled from the overall&nbsp;throughput of VirtualGL.</p>

<p>To disable frame spoiling, set the <code>VGL_SPOIL</code>
environment variable
to 0 on the server or pass an argument of <code>-sp</code>
to
vglrun. &nbsp;See <a href="#config">Advanced
Configuration</a> for more details.<br>

</p>

<h3>VirtualGL Diagnostic Tools</h3>

<p>VirtualGL includes several tools which can be useful in
diagnosing
performance problems with the system.<br>

</p>

<h4>NetTest</h4>

<p>NetTest is a low-level network benchmark that uses the same
network
classes
as VirtualGL. &nbsp;It can be used to test the latency and
throughput of any
TCP/IP connection, with or without SSL encryption.
&nbsp;The&nbsp;VirtualGL Linux
package installs NetTest in <code>/opt/VirtualGL/bin</code>.
&nbsp;The VirtualGL
Solaris package installs it in <code>/opt/SUNWvgl/bin</code>.
&nbsp;The Windows
installer installs it in <code>c:\program
files\VirtualGL-<var>{version}</var>-<var>{build}</var></code>
by default.
</p>

<p>To use NetTest, first start up the nettest server on one end
of the
connection:<br>

</p>

<pre>nettest -server [-ssl]</pre>

<p>(use <code>-ssl</code> if you want to test the
performance of SSL encryption
over this particular connection.)</p>

<p>Next, start the client on the other end of the connection:<br>

</p>

<pre>nettest -client <var>{server_name}</var> [-ssl]</pre>

<p>(<var><code>server_name</code></var>
is the hostname or IP
address of the machine where
the NetTest server is running. &nbsp;Use <code>-ssl</code>
if&nbsp;the NetTest server is
running in SSL mode.)</p>

<p>The nettest client will produce output similar to the
following:</p>

<pre>TCP transfer performance between localhost and {server}:<br><br>Transfer size&nbsp; 1/2 Round-Trip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Throughput<br>(bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (msec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (MB/sec)<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.176896&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.005391<br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.179391&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.010632<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.181600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.021006<br>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.181292&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.042083<br>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.181694&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.083981<br>32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.181690&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.167965<br>64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.182010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.335339<br>128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.182197&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.669991<br>256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.183593&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.329795<br>512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.183800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.656586<br>1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.186189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.245015<br>2048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.379702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.143834<br>4096&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.546805&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.143778<br>8192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.908712&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8.597335<br>16384&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.643810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9.505359<br>32768&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.961701&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.551368<br>65536&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5.769007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.833754<br>131072&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.313003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.049232<br>262144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22.412990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.154246<br>524288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44.760510&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.170561<br>1048576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89.294810&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.198859<br>2097152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 178.426602&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.209091<br>4194304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 356.547194&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11.218711</pre>

<p>We can see that the throughput peaks out at about 11.2 MB/sec.
&nbsp;1 MB =
1048576 bytes, so 11.2 MB/sec = 94 million bits per second, which is
pretty
good for a 100 Mbit connection. &nbsp;We can also see that, as the
transfer size
decreases, the round-trip time becomes dominated by latency.
&nbsp;The latency is
the same thing as the 1/2 round-trip time for a zero-byte packet, which
is
about 0.18 ms in this case.</p>

<h4>CPUstat</h4>

<p>CPUstat is available only in the VirtualGL Linux packages and
is located
in the same place as NetTest (<code>/opt/VirtualGL/bin</code>.)
&nbsp;It measures the
average, minimum, and peak CPU usage for all processors combined and
for each
processor individually. &nbsp;On Windows, this same functionality
is provided in
the Windows Performance Monitor, which is part of the operating system.</p>

<p>CPUstat measures the CPU usage over a given sample period (a
few
seconds) and
continuously reports how much the CPU was utilized since the last
sample
period. &nbsp;Output for a particular sample looks something like
this:
</p>

<pre>ALL :&nbsp; 51.0 (Usr= 47.5 Nice=&nbsp; 0.0 Sys=&nbsp; 3.5) / Min= 47.4 Max= 52.8 Avg= 50.8<br>cpu0:&nbsp; 20.5 (Usr= 19.5 Nice=&nbsp; 0.0 Sys=&nbsp; 1.0) / Min= 19.4 Max= 88.6 Avg= 45.7<br>cpu1:&nbsp; 81.5 (Usr= 75.5 Nice=&nbsp; 0.0 Sys=&nbsp; 6.0) / Min= 16.6 Max= 83.5 Avg= 56.3</pre>

<p>The first column indicates what percentage of time the CPU was
active
since the last sample period (this is then broken down into what
percentage
of time the CPU spent running user, nice, and system/kernel code.)
&nbsp;"ALL"
indicates the average utilization across all CPU's since the last
sample
period.&nbsp; "Min", "Max", and "Avg" indicate a
running&nbsp;minimum, maximum, and
average of all samples since cpustat was started.</p>

<p>Generally, if an application's CPU usage is fairly steady, you
can run CPUstat for a bit and wait for the Max. and Avg. for the "ALL"
category
to
stabilize, then that will tell you what the application's peak and
average %
CPU utilization is.</p>

<h4>TCBench</h4>

<p>TCBench was born out of the need to compare VirtualGL's
performance to
other
thin client packages, some of which had frame spoiling features that
couldn't
be disabled. &nbsp;TCBench measures the frame rate of a thin client
system as seen
from the client's point of view. &nbsp;It does this by attaching to
one of the
client windows and continuously reading back a small area at the center
of
the window. &nbsp;While this may seem to be a somewhat non-rigorous
test,
experiments have shown that if care is taken to make sure that the
application is updating the center of the window on every frame (such
as in a
spin animation), TCBench can produce quite accurate results.
&nbsp;It has been
sanity checked with VirtualGL's internal profiling mechanism and with a
variety of system-specific techniques, such as monitoring redraw events
on
the client's windowing system.</p>

<p>The&nbsp;VirtualGL Linux package installs TCBench in
<code>/opt/VirtualGL/bin</code>. &nbsp;The VirtualGL
Solaris package installs TCBench
in <code>/opt/SUNWvgl/bin</code>. &nbsp;The Windows
installer installs it in
<code>c:\program files\VirtualGL-<var>{version}</var>-<var>{build}</var></code>
by
default. &nbsp;Run
<code>tcbench</code> from the command line, and it will
prompt
you to click in
the window you want to measure. &nbsp; That window should already
have&nbsp;an
automated animation of some sort running before you launch TCBench.</p>

<p>TCBench can also be used to measure the frame rate of
applications that
are running on the local console, although for extremely fast
applications
(those that exceed 40 fps on the local console), you may need to
increase the
sampling rate of TCBench to get accurate results. &nbsp;The default
sampling rate
of 50 samples/sec should be fine for measuring the throughput of
VirtualGL
and other thin client systems.</p>

<pre>tcbench -?</pre>

<p>gives the relevant command line switches that can be used to
adjust the
benchmark time, the sampling rate, and the x and y offset of the
sampling
area within the window.</p>

<p style="text-align: right;"><a href="#" target="_top">top</a><br>

</p>

<hr>
<h2><a name="configdialog"></a>The VirtualGL
Configuration Dialog<br>

</h2>

<p>Several of VirtualGL's configuration parameters can be changed
on the fly
once an application has started. &nbsp;This is accomplished by
using the VirtualGL
configuration dialog, which can be activated by holding down the
<code>CTRL</code> and <code>SHIFT</code> keys
and
pressing the <code>F12</code> key while
any one of the application's windows is active. &nbsp;This displays
a dialog box
similar to the following:</p>

<p><img alt="VirtualGL Configuration Dialog" src="configdialog.gif?rev=HEAD&amp;root=VirtualGL">
</p>

<p>You can use this dialog to enable or disable frame spoiling or
to adjust
the JPEG quality and subsampling. &nbsp;Changes are reflected
immediately in the
application.</p>

<p><strong>Frame Spoiling</strong> -
&nbsp;Clicking on this button will toggle
frame spoiling on and off. &nbsp;If the button is highlighted
(black), then frame
spoiling is enabled.<br>

</p>

<p><strong>Qual Preset: Broadband/T1</strong> -
Clicking on this button will
set the JPEG quality to 30 and the JPEG subsampling to 4:1:1, settings
which
will produce good performance on broadband connections (but at the
expense of
image quality.)</p>

<p><strong>Qual Preset: LAN</strong> - Clicking on
this button will set the
JPEG quality to 95 and the JPEG subsampling to 4:4:4, settings which
will
produce perceptually lossless image quality (100 Mbit/sec switched LAN
recommended.)</p>

<p><strong>JPEG Quality</strong> - Click and drag the
slider to change the
JPEG quality to an arbitrary value between 1 and 100.</p>

<p><strong>JPEG Subsampling</strong> - Click on any
of the three buttons to
change the JPEG subsampling. &nbsp;The highlighted (black) button
indicates the
current value.</p>

<p><strong>Close Dialog</strong> - Close the dialog
(you can also use the
close gadget on the dialog window)</p>

<p><span class="note">Note:</span>The JPEG
quality and subsampling gadgets
will only be shown if VirtualGL is running in direct mode. &nbsp;In
raw mode, the
only setting that can be changed with this dialog is frame spoiling.</p>

<p>The <code>VGL_GUI </code>environment variable
can be
used to change the key
sequence used to pop up the dialog box. &nbsp;If the default of
<code>CTRL-SHIFT-F12</code> is not suitable, then set <code>VGL_GUI</code>
to any
combination of <code>ctrl</code>, <code>shift</code>,
<code>alt</code>, and one of
<code>{f1, f2,..., f12}</code> (these are not case
sensitive.)
&nbsp;e.g.</p>

<pre>export VGL_GUI=CTRL-F9</pre>

<p>will cause the dialog box to pop up whenever <code>CTRL-F9</code>
is
pressed.</p>

<p>To disable the VirtualGL dialog altogether, set <code>VGL_GUI</code>
to
<code>none</code>.</p>

<p><span class="note">Note:</span>VirtualGL
monitors the application's X
event loop to determine whenever a particular key sequence has been
pressed.
&nbsp;If an application is not monitoring key press events in its X
event loop,
then the VirtualGL configuration dialog might not work properly.</p>

<p align="right"><a href="#" target="_top">top</a></p>

<hr>
<h2 style="text-align: left;"><a name="config"></a>Advanced
Configuration<br>

</h2>

<h3>Server Settings</h3>

<p align="left">You can control the operation of the
VirtualGL faker in four
different ways.&nbsp; Each method of configuration takes precedence
over the
previous method:</p>

<ol>

  <li>Setting a configuration environment variable globally (e.g.
in <code>/etc/profile</code>)</li>

  <li>Setting a configuration environment variable on a per-user
basis (e.g. in <code>~/.bashrc</code>)</li>

  <li>Setting a configuration environment variable only for the
current shell session (e.g. <code>export VGL_<var>XXX</var>=<var>{whatever}</var></code>)</li>

  <li>Passing a configuration option as an argument to <code>vglrun</code>.&nbsp;
This effectively overrides any previous environment variable setting
corresponding to that configuration option.<br>

  </li>

</ol>

<table cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader">Environment<br>

Variable<br>

Name</td>

      <td class="colorheader"><code>vglrun</code><br>

Command-Line<br>

Override</td>

      <td class="colorheader">Description</td>

      <td class="colorheader">Default<br>

Value</td>

    </tr>

    <tr>

      <td><strong><code>VGL_CLIENT</code><br>

      </strong> <br>

      </td>

      <td><strong><code>-cl <var>&lt;client
display&gt;</var></code></strong></td>

      <td>
      <p><strong>The X display where VirtualGL should send
its image stream</strong><br>
When running in Direct Mode, VirtualGL uses a dedicated TCP/IP connection to transmit compressed
images of an application's OpenGL rendering area from the application
server to the client display.&nbsp; Thus, the server needs to know
on which machine the VirtualGL client software is running, and it needs
to know which X display on that machine will be used to draw the
application's windows and other 2D GUI elements.&nbsp; VirtualGL
can normally surmise this by reading the server's <code>DISPLAY</code>
environment variable.&nbsp; But in cases where X11 is tunneled
through SSh or another type of proxy, the <code>DISPLAY</code>
environment variable on the server may not point to the client
machine.&nbsp; In these cases, set <code>VGL_CLIENT</code>
to the display where the application's GUI will end up, e.g.</p>

      <pre>export VGL_CLIENT=<var>{my_client_machine}</var>:0.0<br></pre>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font></p>

      </td>

      <td><strong>Read from the <code>DISPLAY</code>
environment</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_COMPRESS=0<br>

VGL_COMPRESS=1<br>

      </code></strong> <br>

      </td>

      <td><strong><code>-c &lt;0, 1&gt;</code></strong></td>

      <td>
      <p><strong>0 = Raw Mode (no internal image compression or transport),<br>
1 = Direct Mode (internal JPEG compression and transport)</strong></p>
      <p><strong></strong>When this option is set to 0, VirtualGL will bypass its
compressed image delivery system and instead use <code>XPutImage()</code>
to composite the OpenGL-rendered pixels into the appropriate place in
the application window. &nbsp;This mode ("Raw Mode") is primarily useful in
conjunction with VNC, NX, or other remote display software
that performs X11 rendering on the server and uses its own&nbsp;mechanism for compressing and transmitting images to the
client.&nbsp; Enabling Raw Mode on a remote X11 connection is
not advisable, since it will result in uncompressed images being sent
over the network to the client machine.</p>

      <p>If <code>VGL_COMPRESS</code> is not
specified, VirtualGL's
default behavior is to use Direct Mode when the application is being
displayed to a remote X server and to use Raw Mode
otherwise.&nbsp; VirtualGL assumes that if the <code>DISPLAY</code>
environment variable begins with a colon or with "<code>unix:</code>"
(e.g. "<code>:0.0</code>", "<code>unix:1000.0</code>",
etc.), then the X11 connection is local and thus doesn't require image
compression.&nbsp; Otherwise, it assumes that the X11 connection is
remote and that compression is required. &nbsp;If the display
string begins with "<code>localhost</code>" or with the
server's hostname, VGL assumes that the display is being tunneled
through SSh, and it enables Direct Mode in this case. </p>

      <p><span class="note">Note:</span>Stereo
frames will always be compressed, regardless of this setting.&nbsp;
Raw mode cannot be used with stereo.</p>

      <p>See the <a href="#vnc">VNC Usage</a>
section for more details.</p>

      </td>

      <td><strong>Compression enabled ("Direct Mode") if the application is
displaying to a remote X server, disabled ("Raw Mode") otherwise</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_DISPLAY</strong></code><br>

      <br>

      </td>

      <td><strong><code>-d <var>&lt;display
or GLP
device&gt;</var></code></strong></td>

      <td>
      <p><strong>The display or GLP device to use for 3D
rendering</strong><br>

If your server has multiple 3D graphics cards and you want the OpenGL
rendering to be redirected to a display other than :0, set <code>VGL_DISPLAY=:1.0</code>
or whatever.&nbsp; This could be used, for instance, to support
many application instances on a beefy multi-pipe graphics server.</p>

      <p><strong>GLP mode (Solaris/Sparc only):</strong><br>

Setting this option to <code>GLP</code> will enable GLP
mode
and select the first available GLP device for rendering.&nbsp; You
can also set this option to the pathname of a specific GLP device (e.g.
      <code>/dev/fbs/jfb0</code>.)&nbsp; GLP is a
special
feature of Sun's OpenGL library which allows an application to render
into Pbuffers on a graphics card even if there is no X display running
on that graphics card.&nbsp; See the&nbsp;<a href="#glpusage">GLP
Usage</a> section&nbsp;for more details.</p>

      </td>

      <td><strong>:0</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_FPS</strong></code><br>

      <br>

      </td>

      <td><strong><code>-fps <var>&lt;floating
point
number greater than 0&gt;</var></code></strong></td>

      <td><strong>Limit the client/server frame rate to the
specified number of frames per second</strong><br>

Setting <code>VGL_FPS</code>&nbsp;or passing <code>-fps</code>
as an argument to <code>vglrun</code> will enable
VirtualGL's
frame rate governor. &nbsp;When enabled, the frame rate governor
will attempt to limit the overall throughput of the VirtualGL pipeline
to the specified number of frames/second. &nbsp;If frame spoiling
is disabled, this effectively limits the server's rendering frame rate
as well. &nbsp;This option applies regardless of whether VirtualGL
is being run in direct mode (with compression enabled) or in raw mode
(with compression disabled.)<br>

      </td>

      <td><strong>Frame rate governor disabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_GAMMA=0<br>

VGL_GAMMA=1<br>

      </code></strong></td>

      <td><strong><code>-g</code></strong><br>

or<br>

      <strong><code>+g</code></strong></td>

      <td>
      <p><strong>Enable/disable gamma correction
(Solaris/Sparc clients only)</strong><br>

On Solaris/Sparc, when an OpenGL application requests an X visual, it
will be given a gamma-corrected&nbsp;visual (Solaris calls these
"linear visuals") unless it specifically requests otherwise.
&nbsp;Gamma-corrected visuals are subject to the gamma correction
value assigned with <code>fbconfig</code>. &nbsp;If
the
gamma correction value is set to 1.0, then corrected visuals will look
the same as uncorrected visuals.</p>

      <p>When an OpenGL application is being remotely displayed
onto a
Solaris/Sparc client using VirtualGL, VirtualGL tries to emulate the
behavior of the Solaris/Sparc client machine by forcing the application
to use a gamma-corrected visual. &nbsp;But setting <code>VGL_GAMMA=0</code>
on the server (or passing <code>-g</code> to <code>vglrun</code>)
overrides that behavior and forces the application to use an
uncorrected visual.</p>

      <p>This setting has no effect if the client machine is not
running
Solaris/Sparc.</p>

      </td>

      <td><strong>Gamma correction enabled</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_GLLIB</strong></code><br>

      </td>

      <td><br>

      </td>

      <td>
      <p><strong>The location of an alternate OpenGL
library</strong><br>

Normally, VirtualGL loads the first OpenGL dynamic library that it
finds in the dynamic linker path (usually <code>/usr/lib/libGL.so.1</code>,
      <code>/usr/lib64/libGL.so.1</code>,&nbsp; or <code>/usr/lib/64/libGL.so.1</code>.)&nbsp;
You can use this setting to explicitly specify another OpenGL dynamic
library to use.</p>

      <p>Normally, you shouldn't need to muck with this unless
something doesn't
work.</p>

      </td>

      <td></td>

    </tr>

    <tr>

      <td><code><strong>VGL_GUI</strong></code><br>

      </td>

      <td><br>

      </td>

      <td><strong>Key sequence used to invoke the
configuration dialog<br>

      </strong>VirtualGL will normally monitor an application's X
event queue and pop up the VirtualGL configuration dialog
whenever&nbsp;<code>CTRL-SHIFT-F12</code>&nbsp;is
pressed. &nbsp;In the event that this interferes with a key
sequence that the application is already using, you can redefine the
key sequence used to pop up VGL's configuration dialog by setting <code>VGL_GUI</code>
to some combination of <code>shift</code>, <code>ctrl</code>,
      <code>alt</code>, and one of <code>{f1, f2,
..., f12}</code>.
&nbsp;You can also set <code>VGL_GUI</code> to <code>none</code>
to disable the configuration dialog altogether. &nbsp;See <a href="#configdialog">this section</a> for more details.<br>

      </td>

      <td><strong>shift-ctrl-f12</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_GUI_XTTHREADINIT</strong></code></td>

      <td>&nbsp;</td>

      <td>
      <p><strong>0 to prevent VGL from calling <code>XtToolkitThreadInitialize()</code></strong><br>

Xt &amp; Motif applications are supposed to call <code>XtToolkitThreadInitialize()</code>
if they plan to access Xt functions from two or more threads
simultaneously.&nbsp; But rarely, a multi-threaded Xt/Motif
application may avoid calling <code>XtToolkitThreadInitialize()</code>
and rely on the fact that avoiding this call disables application and
process locks.&nbsp; This behavior is generally considered errant
on the part of the application, but the application developers have
probably figured out other ways around the potential instability that
this situation creates. </p>

      <p>The problem arises whenever VirtualGL pops up its
configuration dialog (which is written using Xt.)&nbsp; In order to
create this dialog, VirtualGL creates a new Xt thread and calls <code>XtToolkitThreadInitialize()</code>
as it is supposed to do to guarantee thread safety.&nbsp; But if
the application into which VGL is loaded exhibits the errant behavior
described above, suddenly enabling application and process locks may
cause the application to deadlock.&nbsp; Setting <code>VGL_GUI_XTTHREADINIT</code>
to 0 will remove VGL's call to <code>XtToolkitThreadInitialize()</code>
and should thus eliminate the deadlock.</p>

      <p>In short, if you try to pop up the VirtualGL config
dialog and notice that it hangs the application, try setting <code>VGL_GUI_XTTHREADINIT</code>
to 0.</p>

      </td>

      <td><strong>1</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_NPROCS</code><br>

      <br>

      </strong></td>

      <td><strong><code>-np <var>&lt;# of
CPUs&gt;</var></code></strong><br>

or<br>

      <strong><code>-np 0</code><br>
      </strong>
(automatically determine the optimal&nbsp; number of CPUs to use)<br>

      </td>

      <td>
      <p><strong>Specify the number of CPUs to use for
multi-threaded compression</strong><br>
VirtualGL can divide the task of compressing each frame among multiple
server CPUs. &nbsp;This might speed up the overall throughput if
the compression stage of the pipeline is the primary bottleneck.
&nbsp;The default behavior (equivalent to setting <code>VGL_NPROCS=0</code>)
is to use all but one of the available CPUs, up to a maximum of 3
total. &nbsp;On a large multiprocessor system, the speedup is
almost linear up to 3 processors, but&nbsp;the algorithm scales
very little past that point. &nbsp;VirtualGL will not
allow&nbsp;more than 4 processors total to be used for compression,
nor will it allow you to assign more processors than are available in
the system.</p>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font></p>
      </td>

      <td><strong>1P system: 1<br>

2P&nbsp;system: 1<br>

3P system: 2<br>

4P &amp; larger: 3</strong><br>

      </td>

    </tr>

    <tr>

      <td><strong><code>VGL_PORT</code></strong><br>

      <br>

      </td>

      <td><strong><code>-p <var>&lt;port&gt;</var></code></strong></td>

      <td>
      <p>The TCP port to use when connecting to the client</p>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font></p>

      </td>

      <td><strong>4242 for unencrypted
connections,&nbsp; 4243 for SSL connections</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_PROFILE=0</code><br>

VGL_PROFILE=1<br>

      </strong></td>

      <td><strong><code>-pr</code></strong><br>

or<br>

      <strong><code>+pr</code></strong></td>

      <td><strong>Enable/disable profiling output</strong><br>

If enabled, this will cause the VirtualGL faker to continuously
benchmark itself and periodically print out the&nbsp;throughput of
reading back, compressing, and sending pixels to the client.<br>

      </td>

      <td><strong>Profiling disabled</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_QUAL</strong></code><br>

      <br>

      </td>

      <td><strong><code>-q &lt;1-100&gt;</code></strong></td>

      <td>
      <p><strong>An integer between 1 and 100 (inclusive)</strong><br>
This setting allows you to&nbsp;specify the quality of the JPEG
compression.&nbsp; Lower is faster but also grainier.&nbsp; The
default setting should produce perceptually lossless performance.</p>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font></p>

      </td>

      <td><strong>95</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_READBACK=0<br>

VGL_READBACK=1</strong></code> </td>

      <td></td>

      <td>
      <p><strong>Enable/disable readback</strong><br>

On rare occasions, it might be desirable to have VirtualGL
redirect&nbsp;OpenGL rendering from an application into a Pbuffer
but not automatically read back and send the rendered pixels.
&nbsp;Some applications&nbsp;have their own mechanisms for
reading back the&nbsp;buffer, so disabling VirtualGL's readback
mechanism prevents duplication of effort.</p>

      <p>This feature was developed initially to support running <a href="http://www.paraview.org/">ParaView</a> in
parallel using MPI. &nbsp; ParaView MPI normally uses MPI processes
1 through N as rendering servers, each drawing a portion of the
geometry into a separate window running on a separate X display.
&nbsp;ParaView&nbsp;reads back these server windows and
composites the pixels into the main application window, which is
controlled by MPI process 0.&nbsp;&nbsp;By creating a script
which passes a different value of <code>VGL_DISPLAY</code>
and <code>VGL_READBACK</code> to each MPI process, it is
possible to make all of the ParaView server processes
render&nbsp;to off-screen buffers on different graphics cards while
preventing VirtualGL from displaying any pixels except those generated
by process 0.</p>

      </td>

      <td><strong>Readback enabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_SPOIL=0<br>

VGL_SPOIL=1</code></strong><br>

      </td>

      <td><strong><code>-sp</code></strong><br>

or<br style="font-weight: bold;">

      <strong><code>+sp</code></strong></td>

      <td><strong>Enable/disable frame spoiling</strong><br>

By default, VirtualGL will drop frames so as not to slow down the
rendering rate of the server's graphics engine.&nbsp; This should
produce the best results with interactive applications, but it may be
desirable to turn off frame spoiling when running benchmarks or other
non-interactive applications.&nbsp; Turning off frame spoiling will
force one frame to be read back and sent on each buffer swap, thus
allowing benchmarks to accurately measure the frame rate of the entire
VirtualGL pipeline.&nbsp; Disabling frame spoiling will also
prevent non-interactive applications from wasting graphics resources by
rendering frames that will never be seen.&nbsp; With frame spoiling
turned off, the rendering pipeline behaves as if it's fill-rate limited
to about 30 or 40 Megapixels/second, the maximum throughput of the
VirtualGL system on current CPU's.</td>

      <td><strong>Spoiling enabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_SSL=0<br>

VGL_SSL=1</code><br>

      </strong></td>

      <td><strong><code>-s</code></strong><br>

or<br>

      <strong><code>+s</code></strong></td>

      <td><strong>Tunnel the VirtualGL compressed image
stream inside a secure socket layer</strong><br>

      <br>

      </td>

      <td><strong>SSL disabled</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_SUBSAMP</strong></code><br>

      <br>

      </td>

      <td><strong><code>-samp
&lt;411|422|444&gt;</code></strong></td>

      <td>
      <p><strong>411, 422, or 444</strong><br>

This allows you to manually specify the level of chrominance
subsampling in the JPEG compressor. </p>

      <p>By default, VirtualGL uses no chrominance subsampling
(AKA "4:4:4 subsampling") when it compresses images for delivery to the
client.&nbsp; Subsampling is premised on the fact that the human
eye is more sensitive to changes in brightness than to changes in
color.&nbsp; Since the JPEG image format uses a colorspace in which
brightness (luminance) and color (chrominance) are separated into
different channels, one can sample the brightness for every pixel and
the color for every other pixel and produce visually a 16-million color
image using on average only 16 bits per pixel instead of 24.&nbsp;
This is called "4:2:2 subsampling", since for every 4 pixels of
luminance, there are only 2 pixels of each chrominance
component.&nbsp; Likewise, one can sample every fourth chrominance
component to produce a 16-million color image with only 12 bits per
pixel.&nbsp; The latter is called "4:1:1 subsampling."&nbsp;
Subsampling increases the performance and reduces the network usage,
since there is less data to move around, but it can produce some
visible artifacts.&nbsp; Subsampling artifacts are rarely observed
with volume data, since it usually only contains 256 colors to begin
with.&nbsp; But narrow, aliased lines and other sharp features on a
black background will tend to produce subsampling artifacts.<br>

      <br>

      <strong>The Axis Indicator from a Popular Visualization App<br>

      </strong><br>

      </p>

      <table border="0" cellpadding="0" cellspacing="0">

        <tbody>

          <tr>

            <td>
            <p align="center">4:4:4<br>

Q95</p>

            </td>

            <td>
            <p align="center">4:2:2<br>

Q95</p>

            </td>

            <td>
            <p align="center">4:1:1<br>

Q95</p>

            </td>

          </tr>

          <tr>

            <td><img alt="4:4:4" src="444.gif?rev=HEAD&amp;root=VirtualGL"> </td>

            <td><img alt="4:2:2" src="422.gif?rev=HEAD&amp;root=VirtualGL"> </td>

            <td><img alt="4:1:1" src="411.gif?rev=HEAD&amp;root=VirtualGL"> </td>

          </tr>

        </tbody>
      </table>

      <p><span class="note">Note:</span>&nbsp;If
you select 4:1:1 subsampling, VirtualGL will in fact try to use 4:2:0
instead.&nbsp; 4:2:0 samples every other pixel both horizontally
and vertically rather than sampling every fourth pixel
horizontally.&nbsp; But not all JPEG codecs support 4:2:0, so 4:1:1
is used when 4:2:0 is not available.</p>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font>
      </p>

      </td>

      <td><strong>444</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_SYNC=0<br>

VGL_SYNC=1</code><br>

      </strong></td>

      <td><strong><code>-sync</code></strong><br>

or<br>

      <strong><code>+sync</code></strong></td>

      <td><strong>Enable/disable strict 2D/3D
synchronization (necessary to pass GLX conformance tests)<br>

      </strong>Normally, VirtualGL's operation is asynchronous
from the point of view of the application.&nbsp; The application
swaps the buffers or calls <code>glFinish()</code> or <code>glFlush()</code>
or <code>glXWaitGL()</code>, and VirtualGL reads back the
framebuffer and sends the pixels to the client's display ...
eventually.&nbsp; This will work fine for the vast majority of
applications, but it is not strictly conformant.&nbsp; Technically
speaking, when an application&nbsp;calls <code>glXWaitGL()</code>
or <code>glFinish()</code>, it is well within its rights
to
expect the OpenGL-rendered pixels to be immediately available in the X
window. &nbsp;Fortunately, very few applications actually do expect
this, but on rare occasions, an application may try to use <code>XGetImage()</code>
or other X11 functions to obtain a bitmap of the pixels that were
rendered by OpenGL. &nbsp;Enabling <code>VGL_SYNC</code>
is a somewhat extreme measure that may be needed to get such
applications to work properly.&nbsp; It was developed primarily as
a way to pass the GLX conformance suite (<code>conformx</code>,
specifically.)&nbsp; When <code>VGL_SYNC</code> is
enabled, every call to <code>glFinish()</code> or <code>glXWaitGL()</code>
will cause the contents of the server's framebuffer to be read back and
      <em>synchronously</em> drawn into the client's window
      <em>without compression or frame spoiling</em>.&nbsp;
The call to <code>glFinish()</code> or <code>glXWaitGL()</code>
will not return until VirtualGL has verified that the pixels have been
delivered into the client's window. &nbsp;As such, enabling this
mode can have potentially dire effects on performance.</td>

      <td><strong>Synchronization disabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_TILESIZE</code></strong></td>

      <td></td>

      <td>
      <p><strong>A number between 8 and 1024 (inclusive)<br>

      </strong>Normally, VirtualGL will divide an OpenGL window
into tiles of 256x256 pixels, compare each tile vs. the previous frame,
and only compress &amp; send the tiles which have changed.
&nbsp;It will also divide up the task of compressing these tiles
among the available CPUs in a round robin fashion. &nbsp;There are
several tradeoffs that must be considered when choosing a tile size:</p>

      <table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">

        <tbody>

          <tr class="colorheader">

            <td></td>

            <td class="colorheader">Smaller tile sizes</td>

            <td class="colorheader">Larger tile sizes</td>

          </tr>

          <tr>

            <td>ParallelScalability</td>

            <td>Better</td>

            <td>Worse</td>

          </tr>

          <tr>

            <td>Compression<br>

Efficiency</td>

            <td>Worse</td>

            <td>Better</td>

          </tr>

          <tr>

            <td>Inter-frame<br>

Optimization</td>

            <td>Better</td>

            <td>Worse</td>

          </tr>

          <tr>

            <td>Network<br>

Efficiency</td>

            <td>Worse</td>

            <td>Better</td>

          </tr>

        </tbody>
      </table>

      <br>

      <p>Smaller tiles can more easily be divided up among
multiple CPUs, but
they compress less efficiently (and less quickly) on an individual
basis. &nbsp;Using larger tiles can reduce traffic to the client by
allowing the server to send only one frame update instead of many.
&nbsp;But on the flip side, using larger tiles decreases the chance
that a tile will be unchanged from the previous frame. &nbsp;Thus,
the server may only send one or two packets per frame, but the
cumulative size of those packets may be much larger than if a smaller
tile size was used.</p>

      <p>256x256 was chosen as the default because it provides
the best balance
between scalability and efficiency on the platforms that VirtualGL
supports.</p>
      <p><font color="#0000ff"><em>This option has no effect in "Raw" Mode.</em></font></p>

      </td>

      <td><strong>256</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_TRACE=0<br>

VGL_TRACE=1</code></strong> </td>

      <td><strong><code>-tr</code></strong><br>

or<br>

      <strong><code>+tr</code></strong></td>

      <td><strong>Enable/disable tracing</strong><br>

When tracing is enabled, VirtualGL will log all calls to the GLX and
X11 functions it is intercepting, as well as the arguments and return
values for those functions. &nbsp;This is useful when diagnosing
interaction problems between VirtualGL and a particular OpenGL
application.</td>

      <td><strong>Tracing disabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_VERBOSE=0<br>

VGL_VERBOSE=1</code></strong></td>

      <td><strong><code>-v</code></strong><br>

or<br>

      <strong><code>+v</code></strong></td>

      <td><strong>Enable/disable verbosity</strong><br>

When in verbose mode, VirtualGL will reveal some of the decisions it
makes behind the scenes, such as which code path it is using to
compress JPEG images, which type of X11 drawing it is using, etc.
&nbsp;This can be helpful when diagnosing performance problems.<br>

      </td>

      <td><strong>Verbosity disabled</strong></td>

    </tr>

    <tr>

      <td><code><strong>VGL_X11LIB</strong></code><br>

      </td>

      <td><br>

      </td>

      <td>
      <p><strong>the location of an alternate X11 library<br>
      </strong>Normally, VirtualGL loads the first X11 dynamic
library that it finds in the dynamic linker path (usually <code>/usr/lib/libX11.so.?</code>, <code>/usr/lib/64/libX11.so.?</code>, <code>/usr/X11R6/lib/libX11.so.?</code>, or <code>/usr/X11R6/lib64/libX11.so.?</code>.) You
can use this setting to explicitly specify another X11 dynamic library
to use.</p>

      <p>Normally, you shouldn't need to muck with this unless something doesn't
work.</p>
      </td>

      <td></td>

    </tr>

    <tr>

      <td><strong><code>VGL_XVENDOR</code></strong></td>

      <td></td>

      <td><strong>Return&nbsp;a fake X11 vendor string
when the application&nbsp;calls XServerVendor()</strong><br>

Some applications expect XServerVendor() to return a particular value,
which the application (sometimes erroneously) uses to figure out
whether&nbsp;it's running locally or remotely. &nbsp;This
setting allows you to fool such applications into thinking they're
running on a "local" X server rather than a remote connection.</td>

      <td></td>

    </tr>

  </tbody>
</table>

<br>

<h3>Client Settings</h3>

<h4>Environment Variables</h4>

<table cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader">Environment<br>

Variable<br>

Name</td>

      <td class="colorheader">Description</td>

      <td class="colorheader">Default<br>

Value</td>

    </tr>

    <tr>

      <td><strong><code>VGL_PROFILE=0<br>

VGL_PROFILE=1</code><br>

      </strong></td>

      <td><strong>Enable/disable profiling output<br>

      </strong>If enabled, this will cause the VirtualGL client
to continuously benchmark itself and periodically print out
the&nbsp;throughput of decompressing and drawing pixels into the
application window<br>

      </td>

      <td><strong>Profiling disabled</strong></td>

    </tr>

    <tr>

      <td><strong><code>VGL_VERBOSE=0<br>

VGL_VERBOSE=1</code></strong></td>

      <td><strong>Enable/disable verbosity</strong><br>

When in verbose mode, VirtualGL will reveal some of the decisions it
makes behind the scenes, such as which code path it is using to
decompress JPEG images, which type of X11 drawing it is using, etc.
&nbsp;This can be helpful when diagnosing performance problems.<br>

      </td>

      <td><strong>Verbosity disabled</strong></td>

    </tr>

  </tbody>
</table>

<h4><code>vglclient</code> Command-Line Arguments</h4>

<table cellpadding="5" cellspacing="3">

  <tbody>

    <tr>

      <td class="colorheader"><code>vglclient</code><br>

Argument</td>

      <td class="colorheader">Description</td>

      <td class="colorheader">Default</td>

    </tr>

    <tr>

      <td><strong><code>-port <var>&lt;port
number&gt;</var></code></strong><br>

      </td>

      <td>Causes the client to listen for unencrypted connections
on the specified&nbsp;TCP port</td>

      <td><strong>4242</strong></td>

    </tr>

    <tr>

      <td><strong><code>-sslport <var>&lt;port
number&gt;</var></code><br>

      </strong></td>

      <td>Causes the client to listen for SSL connections on the
specified TCP port<br>

      </td>

      <td><strong>4243</strong></td>

    </tr>

    <tr>

      <td><code><strong>-sslonly</strong></code></td>

      <td>Causes the client to reject all unencrypted connections</td>

      <td><strong>Accept both SSL and unencrypted
connections</strong></td>

    </tr>

    <tr>

      <td><code><strong>-nossl</strong></code></td>

      <td>Causes the client to reject all SSL connections</td>

      <td><strong>Accept both SSL and unencrypted
connections</strong></td>

    </tr>

    <tr>

      <td><code><strong>-l <var>&lt;log
file&gt;</var></strong></code></td>

      <td>Redirect all output from the client to the specified
file</td>

      <td><strong>Output goes to stderr</strong></td>

    </tr>

    <tr>

      <td><code><strong>-x</strong></code></td>

      <td>Use X11 functions to draw pixels into the application
window</td>

      <td><strong>Use OpenGL on Solaris/Sparc or if stereo
is enabled; use X11 otherwise</strong></td>

    </tr>

    <tr>

      <td><code><strong>-gl</strong></code></td>

      <td>Use OpenGL functions to draw pixels into the
application window</td>

      <td><strong>Use OpenGL on Solaris/Sparc or if stereo
is enabled; use X11 otherwise</strong></td>

    </tr>

  </tbody>
</table>

<ul>

</ul>

</body>
</html>
